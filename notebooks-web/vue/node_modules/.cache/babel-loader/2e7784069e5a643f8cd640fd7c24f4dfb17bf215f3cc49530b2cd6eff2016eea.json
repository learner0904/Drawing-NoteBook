{"ast":null,"code":"import { extent, namespaces } from \"d3\";\nimport { create } from \"../context.js\";\nimport { composeRender } from \"../mark.js\";\nimport { hasXY, identity, indexOf } from \"../options.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles, getPatternId } from \"../style.js\";\nimport { template } from \"../template.js\";\nimport { maybeIdentityX, maybeIdentityY } from \"../transforms/identity.js\";\nimport { maybeIntervalX, maybeIntervalY } from \"../transforms/interval.js\";\nimport { maybeStackX, maybeStackY } from \"../transforms/stack.js\";\nimport { BarX, BarY } from \"./bar.js\";\nconst waffleDefaults = {\n  ariaLabel: \"waffle\"\n};\nexport class WaffleX extends BarX {\n  constructor(data, {\n    unit = 1,\n    gap = 1,\n    round,\n    render,\n    multiple,\n    ...options\n  } = {}) {\n    super(data, {\n      ...options,\n      render: composeRender(render, waffleRender(\"x\"))\n    }, waffleDefaults);\n    this.unit = Math.max(0, unit);\n    this.gap = +gap;\n    this.round = maybeRound(round);\n    this.multiple = maybeMultiple(multiple);\n  }\n}\nexport class WaffleY extends BarY {\n  constructor(data, {\n    unit = 1,\n    gap = 1,\n    round,\n    render,\n    multiple,\n    ...options\n  } = {}) {\n    super(data, {\n      ...options,\n      render: composeRender(render, waffleRender(\"y\"))\n    }, waffleDefaults);\n    this.unit = Math.max(0, unit);\n    this.gap = +gap;\n    this.round = maybeRound(round);\n    this.multiple = maybeMultiple(multiple);\n  }\n}\nfunction waffleRender(y) {\n  return function (index, scales, values, dimensions, context) {\n    const {\n      unit,\n      gap,\n      rx,\n      ry,\n      round\n    } = this;\n    const {\n      document\n    } = context;\n    const Y1 = values.channels[`${y}1`].value;\n    const Y2 = values.channels[`${y}2`].value;\n\n    // We might not use all the available bandwidth if the cells don’t fit evenly.\n    const barwidth = this[y === \"y\" ? \"_width\" : \"_height\"](scales, values, dimensions);\n    const barx = this[y === \"y\" ? \"_x\" : \"_y\"](scales, values, dimensions);\n\n    // The length of a unit along y in pixels.\n    const scale = unit * scaleof(scales.scales[y]);\n\n    // The number of cells on each row (or column) of the waffle.\n    const {\n      multiple = Math.max(1, Math.floor(Math.sqrt(barwidth / scale)))\n    } = this;\n\n    // The outer size of each square cell, in pixels, including the gap.\n    const cx = Math.min(barwidth / multiple, scale * multiple);\n    const cy = scale * multiple;\n\n    // TODO insets?\n    const transform = y === \"y\" ? ([x, y]) => [x * cx, -y * cy] : ([x, y]) => [y * cy, x * cx];\n    const tx = (barwidth - multiple * cx) / 2;\n    const x0 = typeof barx === \"function\" ? i => barx(i) + tx : barx + tx;\n    const y0 = scales[y](0);\n\n    // Create a base pattern with shared attributes for cloning.\n    const patternId = getPatternId();\n    const basePattern = document.createElementNS(namespaces.svg, \"pattern\");\n    basePattern.setAttribute(\"width\", y === \"y\" ? cx : cy);\n    basePattern.setAttribute(\"height\", y === \"y\" ? cy : cx);\n    basePattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n    const basePatternRect = basePattern.appendChild(document.createElementNS(namespaces.svg, \"rect\"));\n    basePatternRect.setAttribute(\"x\", gap / 2);\n    basePatternRect.setAttribute(\"y\", gap / 2);\n    basePatternRect.setAttribute(\"width\", (y === \"y\" ? cx : cy) - gap);\n    basePatternRect.setAttribute(\"height\", (y === \"y\" ? cy : cx) - gap);\n    if (rx != null) basePatternRect.setAttribute(\"rx\", rx);\n    if (ry != null) basePatternRect.setAttribute(\"ry\", ry);\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(g => g.selectAll().data(index).enter().append(() => basePattern.cloneNode(true)).attr(\"id\", i => `${patternId}-${i}`).select(\"rect\").call(applyDirectStyles, this).call(applyChannelStyles, this, values)).call(g => g.selectAll().data(index).enter().append(\"path\").attr(\"transform\", y === \"y\" ? template`translate(${x0},${y0})` : template`translate(${y0},${x0})`).attr(\"d\", i => `M${wafflePoints(round(Y1[i] / unit), round(Y2[i] / unit), multiple).map(transform).join(\"L\")}Z`).attr(\"fill\", i => `url(#${patternId}-${i})`).attr(\"stroke\", this.stroke == null ? null : i => `url(#${patternId}-${i})`)).node();\n  };\n}\n\n// A waffle is a approximately rectangular shape, but may have one or two corner\n// cuts if the starting or ending value is not an even multiple of the number of\n// columns (the width of the waffle in cells). We can represent any waffle by\n// 8 points; below is a waffle of five columns representing the interval 2–11:\n//\n// 1-0\n// |•7-------6\n// |• • • • •|\n// 2---3• • •|\n//     4-----5\n//\n// Note that points 0 and 1 always have the same y-value, points 1 and 2 have\n// the same x-value, and so on, so we don’t need to materialize the x- and y-\n// values of all points. Also note that we can’t use the already-projected y-\n// values because these assume that y-values are distributed linearly along y\n// rather than wrapping around in columns.\n//\n// The corner points may be coincident. If the ending value is an even multiple\n// of the number of columns, say representing the interval 2–10, then points 6,\n// 7, and 0 are the same.\n//\n// 1-----0/7/6\n// |• • • • •|\n// 2---3• • •|\n//     4-----5\n//\n// Likewise if the starting value is an even multiple, say representing the\n// interval 0–10, points 2–4 are coincident.\n//\n// 1-----0/7/6\n// |• • • • •|\n// |• • • • •|\n// 4/3/2-----5\n//\n// Waffles can also represent fractional intervals (e.g., 2.4–10.1). These\n// require additional corner cuts, so the implementation below generates a few\n// more points.\nfunction wafflePoints(i1, i2, columns) {\n  if (i1 < 0 || i2 < 0) {\n    const k = Math.ceil(-Math.min(i1, i2) / columns); // shift negative to positive\n    return wafflePoints(i1 + k * columns, i2 + k * columns, columns).map(([x, y]) => [x, y - k]);\n  }\n  if (i2 < i1) {\n    return wafflePoints(i2, i1, columns);\n  }\n  return [[0, Math.ceil(i1 / columns)], [Math.floor(i1 % columns), Math.ceil(i1 / columns)], [Math.floor(i1 % columns), Math.floor(i1 / columns) + i1 % 1], [Math.ceil(i1 % columns), Math.floor(i1 / columns) + i1 % 1], ...(i1 % columns > columns - 1 ? [] : [[Math.ceil(i1 % columns), Math.floor(i1 / columns)], [columns, Math.floor(i1 / columns)]]), [columns, Math.floor(i2 / columns)], [Math.ceil(i2 % columns), Math.floor(i2 / columns)], [Math.ceil(i2 % columns), Math.floor(i2 / columns) + i2 % 1], [Math.floor(i2 % columns), Math.floor(i2 / columns) + i2 % 1], ...(i2 % columns < 1 ? [] : [[Math.floor(i2 % columns), Math.ceil(i2 / columns)], [0, Math.ceil(i2 / columns)]])];\n}\nfunction maybeRound(round) {\n  if (round === undefined || round === false) return Number;\n  if (round === true) return Math.round;\n  if (typeof round !== \"function\") throw new Error(`invalid round: ${round}`);\n  return round;\n}\nfunction maybeMultiple(multiple) {\n  return multiple === undefined ? undefined : Math.max(1, Math.floor(multiple));\n}\nfunction scaleof({\n  domain,\n  range\n}) {\n  return spread(range) / spread(domain);\n}\nfunction spread(domain) {\n  const [min, max] = extent(domain);\n  return max - min;\n}\nexport function waffleX(data, options = {}) {\n  if (!hasXY(options)) options = {\n    ...options,\n    y: indexOf,\n    x2: identity\n  };\n  return new WaffleX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));\n}\nexport function waffleY(data, options = {}) {\n  if (!hasXY(options)) options = {\n    ...options,\n    x: indexOf,\n    y2: identity\n  };\n  return new WaffleY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));\n}","map":{"version":3,"names":["extent","namespaces","create","composeRender","hasXY","identity","indexOf","applyChannelStyles","applyDirectStyles","applyIndirectStyles","getPatternId","template","maybeIdentityX","maybeIdentityY","maybeIntervalX","maybeIntervalY","maybeStackX","maybeStackY","BarX","BarY","waffleDefaults","ariaLabel","WaffleX","constructor","data","unit","gap","round","render","multiple","options","waffleRender","Math","max","maybeRound","maybeMultiple","WaffleY","y","index","scales","values","dimensions","context","rx","ry","document","Y1","channels","value","Y2","barwidth","barx","scale","scaleof","floor","sqrt","cx","min","cy","transform","x","tx","x0","i","y0","patternId","basePattern","createElementNS","svg","setAttribute","basePatternRect","appendChild","call","_transform","g","selectAll","enter","append","cloneNode","attr","select","wafflePoints","map","join","stroke","node","i1","i2","columns","k","ceil","undefined","Number","Error","domain","range","spread","waffleX","x2","waffleY","y2"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/waffle.js"],"sourcesContent":["import {extent, namespaces} from \"d3\";\nimport {create} from \"../context.js\";\nimport {composeRender} from \"../mark.js\";\nimport {hasXY, identity, indexOf} from \"../options.js\";\nimport {applyChannelStyles, applyDirectStyles, applyIndirectStyles, getPatternId} from \"../style.js\";\nimport {template} from \"../template.js\";\nimport {maybeIdentityX, maybeIdentityY} from \"../transforms/identity.js\";\nimport {maybeIntervalX, maybeIntervalY} from \"../transforms/interval.js\";\nimport {maybeStackX, maybeStackY} from \"../transforms/stack.js\";\nimport {BarX, BarY} from \"./bar.js\";\n\nconst waffleDefaults = {\n  ariaLabel: \"waffle\"\n};\n\nexport class WaffleX extends BarX {\n  constructor(data, {unit = 1, gap = 1, round, render, multiple, ...options} = {}) {\n    super(data, {...options, render: composeRender(render, waffleRender(\"x\"))}, waffleDefaults);\n    this.unit = Math.max(0, unit);\n    this.gap = +gap;\n    this.round = maybeRound(round);\n    this.multiple = maybeMultiple(multiple);\n  }\n}\n\nexport class WaffleY extends BarY {\n  constructor(data, {unit = 1, gap = 1, round, render, multiple, ...options} = {}) {\n    super(data, {...options, render: composeRender(render, waffleRender(\"y\"))}, waffleDefaults);\n    this.unit = Math.max(0, unit);\n    this.gap = +gap;\n    this.round = maybeRound(round);\n    this.multiple = maybeMultiple(multiple);\n  }\n}\n\nfunction waffleRender(y) {\n  return function (index, scales, values, dimensions, context) {\n    const {unit, gap, rx, ry, round} = this;\n    const {document} = context;\n    const Y1 = values.channels[`${y}1`].value;\n    const Y2 = values.channels[`${y}2`].value;\n\n    // We might not use all the available bandwidth if the cells don’t fit evenly.\n    const barwidth = this[y === \"y\" ? \"_width\" : \"_height\"](scales, values, dimensions);\n    const barx = this[y === \"y\" ? \"_x\" : \"_y\"](scales, values, dimensions);\n\n    // The length of a unit along y in pixels.\n    const scale = unit * scaleof(scales.scales[y]);\n\n    // The number of cells on each row (or column) of the waffle.\n    const {multiple = Math.max(1, Math.floor(Math.sqrt(barwidth / scale)))} = this;\n\n    // The outer size of each square cell, in pixels, including the gap.\n    const cx = Math.min(barwidth / multiple, scale * multiple);\n    const cy = scale * multiple;\n\n    // TODO insets?\n    const transform = y === \"y\" ? ([x, y]) => [x * cx, -y * cy] : ([x, y]) => [y * cy, x * cx];\n    const tx = (barwidth - multiple * cx) / 2;\n    const x0 = typeof barx === \"function\" ? (i) => barx(i) + tx : barx + tx;\n    const y0 = scales[y](0);\n\n    // Create a base pattern with shared attributes for cloning.\n    const patternId = getPatternId();\n    const basePattern = document.createElementNS(namespaces.svg, \"pattern\");\n    basePattern.setAttribute(\"width\", y === \"y\" ? cx : cy);\n    basePattern.setAttribute(\"height\", y === \"y\" ? cy : cx);\n    basePattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n    const basePatternRect = basePattern.appendChild(document.createElementNS(namespaces.svg, \"rect\"));\n    basePatternRect.setAttribute(\"x\", gap / 2);\n    basePatternRect.setAttribute(\"y\", gap / 2);\n    basePatternRect.setAttribute(\"width\", (y === \"y\" ? cx : cy) - gap);\n    basePatternRect.setAttribute(\"height\", (y === \"y\" ? cy : cx) - gap);\n    if (rx != null) basePatternRect.setAttribute(\"rx\", rx);\n    if (ry != null) basePatternRect.setAttribute(\"ry\", ry);\n\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(this._transform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(() => basePattern.cloneNode(true))\n          .attr(\"id\", (i) => `${patternId}-${i}`)\n          .select(\"rect\")\n          .call(applyDirectStyles, this)\n          .call(applyChannelStyles, this, values)\n      )\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .attr(\"transform\", y === \"y\" ? template`translate(${x0},${y0})` : template`translate(${y0},${x0})`)\n          .attr(\n            \"d\",\n            (i) =>\n              `M${wafflePoints(round(Y1[i] / unit), round(Y2[i] / unit), multiple)\n                .map(transform)\n                .join(\"L\")}Z`\n          )\n          .attr(\"fill\", (i) => `url(#${patternId}-${i})`)\n          .attr(\"stroke\", this.stroke == null ? null : (i) => `url(#${patternId}-${i})`)\n      )\n      .node();\n  };\n}\n\n// A waffle is a approximately rectangular shape, but may have one or two corner\n// cuts if the starting or ending value is not an even multiple of the number of\n// columns (the width of the waffle in cells). We can represent any waffle by\n// 8 points; below is a waffle of five columns representing the interval 2–11:\n//\n// 1-0\n// |•7-------6\n// |• • • • •|\n// 2---3• • •|\n//     4-----5\n//\n// Note that points 0 and 1 always have the same y-value, points 1 and 2 have\n// the same x-value, and so on, so we don’t need to materialize the x- and y-\n// values of all points. Also note that we can’t use the already-projected y-\n// values because these assume that y-values are distributed linearly along y\n// rather than wrapping around in columns.\n//\n// The corner points may be coincident. If the ending value is an even multiple\n// of the number of columns, say representing the interval 2–10, then points 6,\n// 7, and 0 are the same.\n//\n// 1-----0/7/6\n// |• • • • •|\n// 2---3• • •|\n//     4-----5\n//\n// Likewise if the starting value is an even multiple, say representing the\n// interval 0–10, points 2–4 are coincident.\n//\n// 1-----0/7/6\n// |• • • • •|\n// |• • • • •|\n// 4/3/2-----5\n//\n// Waffles can also represent fractional intervals (e.g., 2.4–10.1). These\n// require additional corner cuts, so the implementation below generates a few\n// more points.\nfunction wafflePoints(i1, i2, columns) {\n  if (i1 < 0 || i2 < 0) {\n    const k = Math.ceil(-Math.min(i1, i2) / columns); // shift negative to positive\n    return wafflePoints(i1 + k * columns, i2 + k * columns, columns).map(([x, y]) => [x, y - k]);\n  }\n  if (i2 < i1) {\n    return wafflePoints(i2, i1, columns);\n  }\n  return [\n    [0, Math.ceil(i1 / columns)],\n    [Math.floor(i1 % columns), Math.ceil(i1 / columns)],\n    [Math.floor(i1 % columns), Math.floor(i1 / columns) + (i1 % 1)],\n    [Math.ceil(i1 % columns), Math.floor(i1 / columns) + (i1 % 1)],\n    ...(i1 % columns > columns - 1\n      ? []\n      : [\n          [Math.ceil(i1 % columns), Math.floor(i1 / columns)],\n          [columns, Math.floor(i1 / columns)]\n        ]),\n    [columns, Math.floor(i2 / columns)],\n    [Math.ceil(i2 % columns), Math.floor(i2 / columns)],\n    [Math.ceil(i2 % columns), Math.floor(i2 / columns) + (i2 % 1)],\n    [Math.floor(i2 % columns), Math.floor(i2 / columns) + (i2 % 1)],\n    ...(i2 % columns < 1\n      ? []\n      : [\n          [Math.floor(i2 % columns), Math.ceil(i2 / columns)],\n          [0, Math.ceil(i2 / columns)]\n        ])\n  ];\n}\n\nfunction maybeRound(round) {\n  if (round === undefined || round === false) return Number;\n  if (round === true) return Math.round;\n  if (typeof round !== \"function\") throw new Error(`invalid round: ${round}`);\n  return round;\n}\n\nfunction maybeMultiple(multiple) {\n  return multiple === undefined ? undefined : Math.max(1, Math.floor(multiple));\n}\n\nfunction scaleof({domain, range}) {\n  return spread(range) / spread(domain);\n}\n\nfunction spread(domain) {\n  const [min, max] = extent(domain);\n  return max - min;\n}\n\nexport function waffleX(data, options = {}) {\n  if (!hasXY(options)) options = {...options, y: indexOf, x2: identity};\n  return new WaffleX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));\n}\n\nexport function waffleY(data, options = {}) {\n  if (!hasXY(options)) options = {...options, x: indexOf, y2: identity};\n  return new WaffleY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}