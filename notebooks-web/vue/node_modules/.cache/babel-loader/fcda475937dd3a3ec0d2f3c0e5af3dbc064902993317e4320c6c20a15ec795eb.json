{"ast":null,"code":"import { select, format as numberFormat, utcFormat } from \"d3\";\nimport { getSource } from \"../channel.js\";\nimport { create } from \"../context.js\";\nimport { defined } from \"../defined.js\";\nimport { formatDefault } from \"../format.js\";\nimport { anchorX, anchorY } from \"../interactions/pointer.js\";\nimport { Mark } from \"../mark.js\";\nimport { maybeAnchor, maybeFrameAnchor, maybeTuple, number, string } from \"../options.js\";\nimport { applyDirectStyles, applyFrameAnchor, applyIndirectStyles, applyTransform, impliedString } from \"../style.js\";\nimport { identity, isIterable, isTemporal, isTextual } from \"../options.js\";\nimport { inferTickFormat } from \"./axis.js\";\nimport { applyIndirectTextStyles, defaultWidth, ellipsis, monospaceWidth } from \"./text.js\";\nimport { cut, clipper, splitter, maybeTextOverflow } from \"./text.js\";\nconst defaults = {\n  ariaLabel: \"tip\",\n  fill: \"var(--plot-background)\",\n  stroke: \"currentColor\"\n};\n\n// These channels are not displayed in the default tip; see formatChannels.\nconst ignoreChannels = new Set([\"geometry\", \"href\", \"src\", \"ariaLabel\", \"scales\"]);\nexport class Tip extends Mark {\n  constructor(data, options = {}) {\n    if (options.tip) options = {\n      ...options,\n      tip: false\n    };\n    if (options.title === undefined && isIterable(data) && isTextual(data)) options = {\n      ...options,\n      title: identity\n    };\n    const {\n      x,\n      y,\n      x1,\n      x2,\n      y1,\n      y2,\n      anchor,\n      preferredAnchor = \"bottom\",\n      monospace,\n      fontFamily = monospace ? \"ui-monospace, monospace\" : undefined,\n      fontSize,\n      fontStyle,\n      fontVariant,\n      fontWeight,\n      lineHeight = 1,\n      lineWidth = 20,\n      frameAnchor,\n      format,\n      textAnchor = \"start\",\n      textOverflow,\n      textPadding = 8,\n      title,\n      pointerSize = 12,\n      pathFilter = \"drop-shadow(0 3px 4px rgba(0,0,0,0.2))\"\n    } = options;\n    super(data, {\n      x: {\n        value: x1 != null && x2 != null ? null : x,\n        scale: \"x\",\n        optional: true\n      },\n      // ignore midpoint\n      y: {\n        value: y1 != null && y2 != null ? null : y,\n        scale: \"y\",\n        optional: true\n      },\n      // ignore midpoint\n      x1: {\n        value: x1,\n        scale: \"x\",\n        optional: x2 == null\n      },\n      y1: {\n        value: y1,\n        scale: \"y\",\n        optional: y2 == null\n      },\n      x2: {\n        value: x2,\n        scale: \"x\",\n        optional: x1 == null\n      },\n      y2: {\n        value: y2,\n        scale: \"y\",\n        optional: y1 == null\n      },\n      title: {\n        value: title,\n        optional: true\n      } // filter: defined\n    }, options, defaults);\n    this.anchor = maybeAnchor(anchor, \"anchor\");\n    this.preferredAnchor = maybeAnchor(preferredAnchor, \"preferredAnchor\");\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    this.textAnchor = impliedString(textAnchor, \"middle\");\n    this.textPadding = +textPadding;\n    this.pointerSize = +pointerSize;\n    this.pathFilter = string(pathFilter);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = string(fontFamily);\n    this.fontSize = number(fontSize);\n    this.fontStyle = string(fontStyle);\n    this.fontVariant = string(fontVariant);\n    this.fontWeight = string(fontWeight);\n    for (const key in defaults) if (key in this.channels) this[key] = defaults[key]; // apply default even if channel\n    this.splitLines = splitter(this);\n    this.clipLine = clipper(this);\n    this.format = typeof format === \"string\" || typeof format === \"function\" ? {\n      title: format\n    } : {\n      ...format\n    }; // defensive copy before mutate; also promote nullish to empty\n  }\n\n  render(index, scales, values, dimensions, context) {\n    const mark = this;\n    const {\n      x,\n      y,\n      fx,\n      fy\n    } = scales;\n    const {\n      ownerSVGElement: svg,\n      document\n    } = context;\n    const {\n      anchor,\n      monospace,\n      lineHeight,\n      lineWidth\n    } = this;\n    const {\n      textPadding: r,\n      pointerSize: m,\n      pathFilter\n    } = this;\n    const {\n      marginTop,\n      marginLeft\n    } = dimensions;\n\n    // The anchor position is the middle of x1 & y1 and x2 & y2, if available,\n    // or x & y; the former is considered more specific because it’s how we\n    // disable the implicit stack and interval transforms. If any dimension is\n    // unspecified, we fallback to the frame anchor. We also need to know the\n    // facet offsets to detect when the tip would draw outside the plot, and\n    // thus we need to change the orientation.\n    const {\n      x1: X1,\n      y1: Y1,\n      x2: X2,\n      y2: Y2,\n      x: X = X1 ?? X2,\n      y: Y = Y1 ?? Y2\n    } = values;\n    const ox = fx ? fx(index.fx) - marginLeft : 0;\n    const oy = fy ? fy(index.fy) - marginTop : 0;\n\n    // The order of precedence for the anchor position is: the middle of x1 & y1\n    // and x2 & y2; or x1 & y1 (e.g., area); or lastly x & y. If a dimension is\n    // unspecified, the frame anchor is used.\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const px = anchorX(values, cx);\n    const py = anchorY(values, cy);\n\n    // Resolve the text metric implementation. We may need an ellipsis for text\n    // truncation, so we optimistically compute the ellipsis width.\n    const widthof = monospace ? monospaceWidth : defaultWidth;\n    const ee = widthof(ellipsis);\n\n    // If there’s a title channel, display that as-is; otherwise, show multiple\n    // channels as name-value pairs.\n    let sources, format;\n    if (\"title\" in values) {\n      sources = getSourceChannels.call(this, {\n        title: values.channels.title\n      }, scales);\n      format = formatTitle;\n    } else {\n      sources = getSourceChannels.call(this, values.channels, scales);\n      format = formatChannels;\n    }\n\n    // We don’t call applyChannelStyles because we only use the channels to\n    // derive the content of the tip, not its aesthetics.\n    const g = create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this).call(applyTransform, this, {\n      x: X && x,\n      y: Y && y\n    }).call(g => g.selectAll().data(index).enter().append(\"g\").attr(\"transform\", i => `translate(${Math.round(px(i))},${Math.round(py(i))})`) // crisp edges\n    .call(applyDirectStyles, this).call(g => g.append(\"path\").attr(\"filter\", pathFilter)).call(g => g.append(\"text\").each(function (i) {\n      const that = select(this);\n      // prevent style inheritance (from path)\n      this.setAttribute(\"fill\", \"currentColor\");\n      this.setAttribute(\"fill-opacity\", 1);\n      this.setAttribute(\"stroke\", \"none\");\n      // iteratively render each channel value\n      const lines = format.call(mark, i, index, sources, scales, values);\n      if (typeof lines === \"string\") {\n        for (const line of mark.splitLines(lines)) {\n          renderLine(that, {\n            value: mark.clipLine(line)\n          });\n        }\n      } else {\n        const labels = new Set();\n        for (const line of lines) {\n          const {\n            label = \"\"\n          } = line;\n          if (label && labels.has(label)) continue;else labels.add(label);\n          renderLine(that, line);\n        }\n      }\n    })));\n\n    // Renders a single line (a name-value pair) to the tip, truncating the text\n    // as needed, and adding a title if the text is truncated. Note that this is\n    // just the initial layout of the text; in postrender we will compute the\n    // exact text metrics and translate the text as needed once we know the\n    // tip’s orientation (anchor).\n    function renderLine(selection, {\n      label,\n      value,\n      color,\n      opacity\n    }) {\n      label ??= \"\", value ??= \"\";\n      const swatch = color != null || opacity != null;\n      let title;\n      let w = lineWidth * 100;\n      const [j] = cut(label, w, widthof, ee);\n      if (j >= 0) {\n        // label is truncated\n        label = label.slice(0, j).trimEnd() + ellipsis;\n        title = value.trim();\n        value = \"\";\n      } else {\n        if (label || !value && !swatch) value = \" \" + value;\n        const [k] = cut(value, w - widthof(label), widthof, ee);\n        if (k >= 0) {\n          // value is truncated\n          title = value.trim();\n          value = value.slice(0, k).trimEnd() + ellipsis;\n        }\n      }\n      const line = selection.append(\"tspan\").attr(\"x\", 0).attr(\"dy\", `${lineHeight}em`).text(\"\\u200b\"); // zwsp for double-click\n      if (label) line.append(\"tspan\").attr(\"font-weight\", \"bold\").text(label);\n      if (value) line.append(() => document.createTextNode(value));\n      if (swatch) line.append(\"tspan\").text(\" ■\").attr(\"fill\", color).attr(\"fill-opacity\", opacity).style(\"user-select\", \"none\"); // prettier-ignore\n      if (title) line.append(\"title\").text(title);\n    }\n\n    // Only after the plot is attached to the page can we compute the exact text\n    // metrics needed to determine the tip size and orientation (anchor).\n    function postrender() {\n      const {\n        width,\n        height\n      } = dimensions.facet ?? dimensions;\n      g.selectChildren().each(function (i) {\n        let {\n          x: tx,\n          width: w,\n          height: h\n        } = this.getBBox();\n        w = Math.round(w), h = Math.round(h); // crisp edges\n        let a = anchor; // use the specified anchor, if any\n        if (a === undefined) {\n          const x = px(i) + ox;\n          const y = py(i) + oy;\n          const fitLeft = x + w + m + r * 2 < width;\n          const fitRight = x - w - m - r * 2 > 0;\n          const fitTop = y + h + m + r * 2 < height;\n          const fitBottom = y - h - m - r * 2 > 0;\n          a = fitLeft && fitRight ? fitTop && fitBottom ? mark.preferredAnchor : fitBottom ? \"bottom\" : \"top\" : fitTop && fitBottom ? fitLeft ? \"left\" : \"right\" : (fitLeft || fitRight) && (fitTop || fitBottom) ? `${fitBottom ? \"bottom\" : \"top\"}-${fitLeft ? \"left\" : \"right\"}` : mark.preferredAnchor;\n        }\n        const path = this.firstChild; // note: assumes exactly two children!\n        const text = this.lastChild; // note: assumes exactly two children!\n        path.setAttribute(\"d\", getPath(a, m, r, w, h));\n        if (tx) for (const t of text.childNodes) t.setAttribute(\"x\", -tx);\n        text.setAttribute(\"y\", `${+getLineOffset(a, text.childNodes.length, lineHeight).toFixed(6)}em`);\n        text.setAttribute(\"transform\", `translate(${getTextTranslate(a, m, r, w, h)})`);\n      });\n      g.attr(\"visibility\", null);\n    }\n\n    // Wait until the plot is inserted into the page so that we can use getBBox\n    // to compute the exact text dimensions. If the SVG is already connected, as\n    // when the pointer interaction triggers the re-render, use a faster\n    // microtask instead of an animation frame; if this SSR (e.g., JSDOM), skip\n    // this step. Perhaps this could be done synchronously; getting the\n    // dimensions of the SVG is easy, and although accurate text metrics are\n    // hard, we could use approximate heuristics.\n    if (index.length) {\n      g.attr(\"visibility\", \"hidden\"); // hide until postrender\n      if (svg.isConnected) Promise.resolve().then(postrender);else if (typeof requestAnimationFrame !== \"undefined\") requestAnimationFrame(postrender);\n    }\n    return g.node();\n  }\n}\nexport function tip(data, {\n  x,\n  y,\n  ...options\n} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = maybeTuple(x, y);\n  return new Tip(data, {\n    ...options,\n    x,\n    y\n  });\n}\nfunction getLineOffset(anchor, length, lineHeight) {\n  return /^top(?:-|$)/.test(anchor) ? 0.94 - lineHeight : /^bottom(?:-|$)/ ? -0.29 - length * lineHeight : length / 2 * lineHeight;\n}\nfunction getTextTranslate(anchor, m, r, width, height) {\n  switch (anchor) {\n    case \"middle\":\n      return [-width / 2, height / 2];\n    case \"top-left\":\n      return [r, m + r];\n    case \"top\":\n      return [-width / 2, m / 2 + r];\n    case \"top-right\":\n      return [-width - r, m + r];\n    case \"right\":\n      return [-m / 2 - width - r, height / 2];\n    case \"bottom-left\":\n      return [r, -m - r];\n    case \"bottom\":\n      return [-width / 2, -m / 2 - r];\n    case \"bottom-right\":\n      return [-width - r, -m - r];\n    case \"left\":\n      return [r + m / 2, height / 2];\n  }\n}\nfunction getPath(anchor, m, r, width, height) {\n  const w = width + r * 2;\n  const h = height + r * 2;\n  switch (anchor) {\n    case \"middle\":\n      return `M${-w / 2},${-h / 2}h${w}v${h}h${-w}z`;\n    case \"top-left\":\n      return `M0,0l${m},${m}h${w - m}v${h}h${-w}z`;\n    case \"top\":\n      return `M0,0l${m / 2},${m / 2}h${(w - m) / 2}v${h}h${-w}v${-h}h${(w - m) / 2}z`;\n    case \"top-right\":\n      return `M0,0l${-m},${m}h${m - w}v${h}h${w}z`;\n    case \"right\":\n      return `M0,0l${-m / 2},${-m / 2}v${m / 2 - h / 2}h${-w}v${h}h${w}v${m / 2 - h / 2}z`;\n    case \"bottom-left\":\n      return `M0,0l${m},${-m}h${w - m}v${-h}h${-w}z`;\n    case \"bottom\":\n      return `M0,0l${m / 2},${-m / 2}h${(w - m) / 2}v${-h}h${-w}v${h}h${(w - m) / 2}z`;\n    case \"bottom-right\":\n      return `M0,0l${-m},${-m}h${m - w}v${-h}h${w}z`;\n    case \"left\":\n      return `M0,0l${m / 2},${-m / 2}v${m / 2 - h / 2}h${w}v${h}h${-w}v${m / 2 - h / 2}z`;\n  }\n}\n\n// Note: mutates this.format!\nfunction getSourceChannels(channels, scales) {\n  const sources = {};\n\n  // Promote x and y shorthand for paired channels (in order).\n  let format = this.format;\n  format = maybeExpandPairedFormat(format, channels, \"x\");\n  format = maybeExpandPairedFormat(format, channels, \"y\");\n  this.format = format;\n\n  // Prioritize channels with explicit formats, in the given order.\n  for (const key in format) {\n    const value = format[key];\n    if (value === null || value === false) {\n      continue;\n    } else if (key === \"fx\" || key === \"fy\") {\n      sources[key] = true;\n    } else {\n      const source = getSource(channels, key);\n      if (source) sources[key] = source;\n    }\n  }\n\n  // Then fallback to all other (non-ignored) channels.\n  for (const key in channels) {\n    if (key in sources || key in format || ignoreChannels.has(key)) continue;\n    if ((key === \"x\" || key === \"y\") && channels.geometry) continue; // ignore x & y on geo\n    const source = getSource(channels, key);\n    if (source) {\n      // Ignore color channels if the values are all literal colors.\n      if (source.scale == null && source.defaultScale === \"color\") continue;\n      sources[key] = source;\n    }\n  }\n\n  // And lastly facet channels, but only if this mark is faceted.\n  if (this.facet) {\n    if (scales.fx && !(\"fx\" in format)) sources.fx = true;\n    if (scales.fy && !(\"fy\" in format)) sources.fy = true;\n  }\n\n  // Promote shorthand string formats, and materialize default formats.\n  for (const key in sources) {\n    const format = this.format[key];\n    if (typeof format === \"string\") {\n      const value = sources[key]?.value ?? scales[key]?.domain() ?? [];\n      this.format[key] = (isTemporal(value) ? utcFormat : numberFormat)(format);\n    } else if (format === undefined || format === true) {\n      // For ordinal scales, the inferred tick format can be more concise, such\n      // as only showing the year for yearly data.\n      const scale = scales[key];\n      this.format[key] = scale?.bandwidth ? inferTickFormat(scale, scale.domain()) : formatDefault;\n    }\n  }\n  return sources;\n}\n\n// Promote x and y shorthand for paired channels, while preserving order.\nfunction maybeExpandPairedFormat(format, channels, key) {\n  if (!(key in format)) return format;\n  const key1 = `${key}1`;\n  const key2 = `${key}2`;\n  if ((key1 in format || !(key1 in channels)) && (key2 in format || !(key2 in channels))) return format;\n  const entries = Object.entries(format);\n  const value = format[key];\n  entries.splice(entries.findIndex(([name]) => name === key) + 1, 0, [key1, value], [key2, value]);\n  return Object.fromEntries(entries);\n}\nfunction formatTitle(i, index, {\n  title\n}) {\n  return this.format.title(title.value[i], i);\n}\nfunction* formatChannels(i, index, channels, scales, values) {\n  for (const key in channels) {\n    if (key === \"fx\" || key === \"fy\") {\n      yield {\n        label: formatLabel(scales, channels, key),\n        value: this.format[key](index[key], i)\n      };\n      continue;\n    }\n    if (key === \"x1\" && \"x2\" in channels) continue;\n    if (key === \"y1\" && \"y2\" in channels) continue;\n    const channel = channels[key];\n    if (key === \"x2\" && \"x1\" in channels) {\n      yield {\n        label: formatPairLabel(scales, channels, \"x\"),\n        value: formatPair(this.format.x2, channels.x1, channel, i)\n      };\n    } else if (key === \"y2\" && \"y1\" in channels) {\n      yield {\n        label: formatPairLabel(scales, channels, \"y\"),\n        value: formatPair(this.format.y2, channels.y1, channel, i)\n      };\n    } else {\n      const value = channel.value[i];\n      const scale = channel.scale;\n      if (!defined(value) && scale == null) continue;\n      yield {\n        label: formatLabel(scales, channels, key),\n        value: this.format[key](value, i),\n        color: scale === \"color\" ? values[key][i] : null,\n        opacity: scale === \"opacity\" ? values[key][i] : null\n      };\n    }\n  }\n}\nfunction formatPair(formatValue, c1, c2, i) {\n  return c2.hint?.length // e.g., stackY’s y1 and y2\n  ? `${formatValue(c2.value[i] - c1.value[i], i)}` : `${formatValue(c1.value[i], i)}–${formatValue(c2.value[i], i)}`;\n}\nfunction formatPairLabel(scales, channels, key) {\n  const l1 = formatLabel(scales, channels, `${key}1`, key);\n  const l2 = formatLabel(scales, channels, `${key}2`, key);\n  return l1 === l2 ? l1 : `${l1}–${l2}`;\n}\nfunction formatLabel(scales, channels, key, defaultLabel = key) {\n  const channel = channels[key];\n  const scale = scales[channel?.scale ?? key];\n  return String(scale?.label ?? channel?.label ?? defaultLabel);\n}","map":{"version":3,"names":["select","format","numberFormat","utcFormat","getSource","create","defined","formatDefault","anchorX","anchorY","Mark","maybeAnchor","maybeFrameAnchor","maybeTuple","number","string","applyDirectStyles","applyFrameAnchor","applyIndirectStyles","applyTransform","impliedString","identity","isIterable","isTemporal","isTextual","inferTickFormat","applyIndirectTextStyles","defaultWidth","ellipsis","monospaceWidth","cut","clipper","splitter","maybeTextOverflow","defaults","ariaLabel","fill","stroke","ignoreChannels","Set","Tip","constructor","data","options","tip","title","undefined","x","y","x1","x2","y1","y2","anchor","preferredAnchor","monospace","fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight","lineWidth","frameAnchor","textAnchor","textOverflow","textPadding","pointerSize","pathFilter","value","scale","optional","key","channels","splitLines","clipLine","render","index","scales","values","dimensions","context","mark","fx","fy","ownerSVGElement","svg","document","r","m","marginTop","marginLeft","X1","Y1","X2","Y2","X","Y","ox","oy","cx","cy","px","py","widthof","ee","sources","getSourceChannels","call","formatTitle","formatChannels","g","selectAll","enter","append","attr","i","Math","round","each","that","setAttribute","lines","line","renderLine","labels","label","has","add","selection","color","opacity","swatch","w","j","slice","trimEnd","trim","k","text","createTextNode","style","postrender","width","height","facet","selectChildren","tx","h","getBBox","a","fitLeft","fitRight","fitTop","fitBottom","path","firstChild","lastChild","getPath","t","childNodes","getLineOffset","length","toFixed","getTextTranslate","isConnected","Promise","resolve","then","requestAnimationFrame","node","test","maybeExpandPairedFormat","source","geometry","defaultScale","domain","bandwidth","key1","key2","entries","Object","splice","findIndex","name","fromEntries","formatLabel","channel","formatPairLabel","formatPair","formatValue","c1","c2","hint","l1","l2","defaultLabel","String"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/tip.js"],"sourcesContent":["import {select, format as numberFormat, utcFormat} from \"d3\";\nimport {getSource} from \"../channel.js\";\nimport {create} from \"../context.js\";\nimport {defined} from \"../defined.js\";\nimport {formatDefault} from \"../format.js\";\nimport {anchorX, anchorY} from \"../interactions/pointer.js\";\nimport {Mark} from \"../mark.js\";\nimport {maybeAnchor, maybeFrameAnchor, maybeTuple, number, string} from \"../options.js\";\nimport {applyDirectStyles, applyFrameAnchor, applyIndirectStyles, applyTransform, impliedString} from \"../style.js\";\nimport {identity, isIterable, isTemporal, isTextual} from \"../options.js\";\nimport {inferTickFormat} from \"./axis.js\";\nimport {applyIndirectTextStyles, defaultWidth, ellipsis, monospaceWidth} from \"./text.js\";\nimport {cut, clipper, splitter, maybeTextOverflow} from \"./text.js\";\n\nconst defaults = {\n  ariaLabel: \"tip\",\n  fill: \"var(--plot-background)\",\n  stroke: \"currentColor\"\n};\n\n// These channels are not displayed in the default tip; see formatChannels.\nconst ignoreChannels = new Set([\"geometry\", \"href\", \"src\", \"ariaLabel\", \"scales\"]);\n\nexport class Tip extends Mark {\n  constructor(data, options = {}) {\n    if (options.tip) options = {...options, tip: false};\n    if (options.title === undefined && isIterable(data) && isTextual(data)) options = {...options, title: identity};\n    const {\n      x,\n      y,\n      x1,\n      x2,\n      y1,\n      y2,\n      anchor,\n      preferredAnchor = \"bottom\",\n      monospace,\n      fontFamily = monospace ? \"ui-monospace, monospace\" : undefined,\n      fontSize,\n      fontStyle,\n      fontVariant,\n      fontWeight,\n      lineHeight = 1,\n      lineWidth = 20,\n      frameAnchor,\n      format,\n      textAnchor = \"start\",\n      textOverflow,\n      textPadding = 8,\n      title,\n      pointerSize = 12,\n      pathFilter = \"drop-shadow(0 3px 4px rgba(0,0,0,0.2))\"\n    } = options;\n    super(\n      data,\n      {\n        x: {value: x1 != null && x2 != null ? null : x, scale: \"x\", optional: true}, // ignore midpoint\n        y: {value: y1 != null && y2 != null ? null : y, scale: \"y\", optional: true}, // ignore midpoint\n        x1: {value: x1, scale: \"x\", optional: x2 == null},\n        y1: {value: y1, scale: \"y\", optional: y2 == null},\n        x2: {value: x2, scale: \"x\", optional: x1 == null},\n        y2: {value: y2, scale: \"y\", optional: y1 == null},\n        title: {value: title, optional: true} // filter: defined\n      },\n      options,\n      defaults\n    );\n    this.anchor = maybeAnchor(anchor, \"anchor\");\n    this.preferredAnchor = maybeAnchor(preferredAnchor, \"preferredAnchor\");\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    this.textAnchor = impliedString(textAnchor, \"middle\");\n    this.textPadding = +textPadding;\n    this.pointerSize = +pointerSize;\n    this.pathFilter = string(pathFilter);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = string(fontFamily);\n    this.fontSize = number(fontSize);\n    this.fontStyle = string(fontStyle);\n    this.fontVariant = string(fontVariant);\n    this.fontWeight = string(fontWeight);\n    for (const key in defaults) if (key in this.channels) this[key] = defaults[key]; // apply default even if channel\n    this.splitLines = splitter(this);\n    this.clipLine = clipper(this);\n    this.format = typeof format === \"string\" || typeof format === \"function\" ? {title: format} : {...format}; // defensive copy before mutate; also promote nullish to empty\n  }\n  render(index, scales, values, dimensions, context) {\n    const mark = this;\n    const {x, y, fx, fy} = scales;\n    const {ownerSVGElement: svg, document} = context;\n    const {anchor, monospace, lineHeight, lineWidth} = this;\n    const {textPadding: r, pointerSize: m, pathFilter} = this;\n    const {marginTop, marginLeft} = dimensions;\n\n    // The anchor position is the middle of x1 & y1 and x2 & y2, if available,\n    // or x & y; the former is considered more specific because it’s how we\n    // disable the implicit stack and interval transforms. If any dimension is\n    // unspecified, we fallback to the frame anchor. We also need to know the\n    // facet offsets to detect when the tip would draw outside the plot, and\n    // thus we need to change the orientation.\n    const {x1: X1, y1: Y1, x2: X2, y2: Y2, x: X = X1 ?? X2, y: Y = Y1 ?? Y2} = values;\n    const ox = fx ? fx(index.fx) - marginLeft : 0;\n    const oy = fy ? fy(index.fy) - marginTop : 0;\n\n    // The order of precedence for the anchor position is: the middle of x1 & y1\n    // and x2 & y2; or x1 & y1 (e.g., area); or lastly x & y. If a dimension is\n    // unspecified, the frame anchor is used.\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const px = anchorX(values, cx);\n    const py = anchorY(values, cy);\n\n    // Resolve the text metric implementation. We may need an ellipsis for text\n    // truncation, so we optimistically compute the ellipsis width.\n    const widthof = monospace ? monospaceWidth : defaultWidth;\n    const ee = widthof(ellipsis);\n\n    // If there’s a title channel, display that as-is; otherwise, show multiple\n    // channels as name-value pairs.\n    let sources, format;\n    if (\"title\" in values) {\n      sources = getSourceChannels.call(this, {title: values.channels.title}, scales);\n      format = formatTitle;\n    } else {\n      sources = getSourceChannels.call(this, values.channels, scales);\n      format = formatChannels;\n    }\n\n    // We don’t call applyChannelStyles because we only use the channels to\n    // derive the content of the tip, not its aesthetics.\n    const g = create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyIndirectTextStyles, this)\n      .call(applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"g\")\n          .attr(\"transform\", (i) => `translate(${Math.round(px(i))},${Math.round(py(i))})`) // crisp edges\n          .call(applyDirectStyles, this)\n          .call((g) => g.append(\"path\").attr(\"filter\", pathFilter))\n          .call((g) =>\n            g.append(\"text\").each(function (i) {\n              const that = select(this);\n              // prevent style inheritance (from path)\n              this.setAttribute(\"fill\", \"currentColor\");\n              this.setAttribute(\"fill-opacity\", 1);\n              this.setAttribute(\"stroke\", \"none\");\n              // iteratively render each channel value\n              const lines = format.call(mark, i, index, sources, scales, values);\n              if (typeof lines === \"string\") {\n                for (const line of mark.splitLines(lines)) {\n                  renderLine(that, {value: mark.clipLine(line)});\n                }\n              } else {\n                const labels = new Set();\n                for (const line of lines) {\n                  const {label = \"\"} = line;\n                  if (label && labels.has(label)) continue;\n                  else labels.add(label);\n                  renderLine(that, line);\n                }\n              }\n            })\n          )\n      );\n\n    // Renders a single line (a name-value pair) to the tip, truncating the text\n    // as needed, and adding a title if the text is truncated. Note that this is\n    // just the initial layout of the text; in postrender we will compute the\n    // exact text metrics and translate the text as needed once we know the\n    // tip’s orientation (anchor).\n    function renderLine(selection, {label, value, color, opacity}) {\n      (label ??= \"\"), (value ??= \"\");\n      const swatch = color != null || opacity != null;\n      let title;\n      let w = lineWidth * 100;\n      const [j] = cut(label, w, widthof, ee);\n      if (j >= 0) {\n        // label is truncated\n        label = label.slice(0, j).trimEnd() + ellipsis;\n        title = value.trim();\n        value = \"\";\n      } else {\n        if (label || (!value && !swatch)) value = \" \" + value;\n        const [k] = cut(value, w - widthof(label), widthof, ee);\n        if (k >= 0) {\n          // value is truncated\n          title = value.trim();\n          value = value.slice(0, k).trimEnd() + ellipsis;\n        }\n      }\n      const line = selection.append(\"tspan\").attr(\"x\", 0).attr(\"dy\", `${lineHeight}em`).text(\"\\u200b\"); // zwsp for double-click\n      if (label) line.append(\"tspan\").attr(\"font-weight\", \"bold\").text(label);\n      if (value) line.append(() => document.createTextNode(value));\n      if (swatch) line.append(\"tspan\").text(\" ■\").attr(\"fill\", color).attr(\"fill-opacity\", opacity).style(\"user-select\", \"none\"); // prettier-ignore\n      if (title) line.append(\"title\").text(title);\n    }\n\n    // Only after the plot is attached to the page can we compute the exact text\n    // metrics needed to determine the tip size and orientation (anchor).\n    function postrender() {\n      const {width, height} = dimensions.facet ?? dimensions;\n      g.selectChildren().each(function (i) {\n        let {x: tx, width: w, height: h} = this.getBBox();\n        (w = Math.round(w)), (h = Math.round(h)); // crisp edges\n        let a = anchor; // use the specified anchor, if any\n        if (a === undefined) {\n          const x = px(i) + ox;\n          const y = py(i) + oy;\n          const fitLeft = x + w + m + r * 2 < width;\n          const fitRight = x - w - m - r * 2 > 0;\n          const fitTop = y + h + m + r * 2 < height;\n          const fitBottom = y - h - m - r * 2 > 0;\n          a =\n            fitLeft && fitRight\n              ? fitTop && fitBottom\n                ? mark.preferredAnchor\n                : fitBottom\n                ? \"bottom\"\n                : \"top\"\n              : fitTop && fitBottom\n              ? fitLeft\n                ? \"left\"\n                : \"right\"\n              : (fitLeft || fitRight) && (fitTop || fitBottom)\n              ? `${fitBottom ? \"bottom\" : \"top\"}-${fitLeft ? \"left\" : \"right\"}`\n              : mark.preferredAnchor;\n        }\n        const path = this.firstChild; // note: assumes exactly two children!\n        const text = this.lastChild; // note: assumes exactly two children!\n        path.setAttribute(\"d\", getPath(a, m, r, w, h));\n        if (tx) for (const t of text.childNodes) t.setAttribute(\"x\", -tx);\n        text.setAttribute(\"y\", `${+getLineOffset(a, text.childNodes.length, lineHeight).toFixed(6)}em`);\n        text.setAttribute(\"transform\", `translate(${getTextTranslate(a, m, r, w, h)})`);\n      });\n      g.attr(\"visibility\", null);\n    }\n\n    // Wait until the plot is inserted into the page so that we can use getBBox\n    // to compute the exact text dimensions. If the SVG is already connected, as\n    // when the pointer interaction triggers the re-render, use a faster\n    // microtask instead of an animation frame; if this SSR (e.g., JSDOM), skip\n    // this step. Perhaps this could be done synchronously; getting the\n    // dimensions of the SVG is easy, and although accurate text metrics are\n    // hard, we could use approximate heuristics.\n    if (index.length) {\n      g.attr(\"visibility\", \"hidden\"); // hide until postrender\n      if (svg.isConnected) Promise.resolve().then(postrender);\n      else if (typeof requestAnimationFrame !== \"undefined\") requestAnimationFrame(postrender);\n    }\n\n    return g.node();\n  }\n}\n\nexport function tip(data, {x, y, ...options} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = maybeTuple(x, y);\n  return new Tip(data, {...options, x, y});\n}\n\nfunction getLineOffset(anchor, length, lineHeight) {\n  return /^top(?:-|$)/.test(anchor)\n    ? 0.94 - lineHeight\n    : /^bottom(?:-|$)/\n    ? -0.29 - length * lineHeight\n    : (length / 2) * lineHeight;\n}\n\nfunction getTextTranslate(anchor, m, r, width, height) {\n  switch (anchor) {\n    case \"middle\":\n      return [-width / 2, height / 2];\n    case \"top-left\":\n      return [r, m + r];\n    case \"top\":\n      return [-width / 2, m / 2 + r];\n    case \"top-right\":\n      return [-width - r, m + r];\n    case \"right\":\n      return [-m / 2 - width - r, height / 2];\n    case \"bottom-left\":\n      return [r, -m - r];\n    case \"bottom\":\n      return [-width / 2, -m / 2 - r];\n    case \"bottom-right\":\n      return [-width - r, -m - r];\n    case \"left\":\n      return [r + m / 2, height / 2];\n  }\n}\n\nfunction getPath(anchor, m, r, width, height) {\n  const w = width + r * 2;\n  const h = height + r * 2;\n  switch (anchor) {\n    case \"middle\":\n      return `M${-w / 2},${-h / 2}h${w}v${h}h${-w}z`;\n    case \"top-left\":\n      return `M0,0l${m},${m}h${w - m}v${h}h${-w}z`;\n    case \"top\":\n      return `M0,0l${m / 2},${m / 2}h${(w - m) / 2}v${h}h${-w}v${-h}h${(w - m) / 2}z`;\n    case \"top-right\":\n      return `M0,0l${-m},${m}h${m - w}v${h}h${w}z`;\n    case \"right\":\n      return `M0,0l${-m / 2},${-m / 2}v${m / 2 - h / 2}h${-w}v${h}h${w}v${m / 2 - h / 2}z`;\n    case \"bottom-left\":\n      return `M0,0l${m},${-m}h${w - m}v${-h}h${-w}z`;\n    case \"bottom\":\n      return `M0,0l${m / 2},${-m / 2}h${(w - m) / 2}v${-h}h${-w}v${h}h${(w - m) / 2}z`;\n    case \"bottom-right\":\n      return `M0,0l${-m},${-m}h${m - w}v${-h}h${w}z`;\n    case \"left\":\n      return `M0,0l${m / 2},${-m / 2}v${m / 2 - h / 2}h${w}v${h}h${-w}v${m / 2 - h / 2}z`;\n  }\n}\n\n// Note: mutates this.format!\nfunction getSourceChannels(channels, scales) {\n  const sources = {};\n\n  // Promote x and y shorthand for paired channels (in order).\n  let format = this.format;\n  format = maybeExpandPairedFormat(format, channels, \"x\");\n  format = maybeExpandPairedFormat(format, channels, \"y\");\n  this.format = format;\n\n  // Prioritize channels with explicit formats, in the given order.\n  for (const key in format) {\n    const value = format[key];\n    if (value === null || value === false) {\n      continue;\n    } else if (key === \"fx\" || key === \"fy\") {\n      sources[key] = true;\n    } else {\n      const source = getSource(channels, key);\n      if (source) sources[key] = source;\n    }\n  }\n\n  // Then fallback to all other (non-ignored) channels.\n  for (const key in channels) {\n    if (key in sources || key in format || ignoreChannels.has(key)) continue;\n    if ((key === \"x\" || key === \"y\") && channels.geometry) continue; // ignore x & y on geo\n    const source = getSource(channels, key);\n    if (source) {\n      // Ignore color channels if the values are all literal colors.\n      if (source.scale == null && source.defaultScale === \"color\") continue;\n      sources[key] = source;\n    }\n  }\n\n  // And lastly facet channels, but only if this mark is faceted.\n  if (this.facet) {\n    if (scales.fx && !(\"fx\" in format)) sources.fx = true;\n    if (scales.fy && !(\"fy\" in format)) sources.fy = true;\n  }\n\n  // Promote shorthand string formats, and materialize default formats.\n  for (const key in sources) {\n    const format = this.format[key];\n    if (typeof format === \"string\") {\n      const value = sources[key]?.value ?? scales[key]?.domain() ?? [];\n      this.format[key] = (isTemporal(value) ? utcFormat : numberFormat)(format);\n    } else if (format === undefined || format === true) {\n      // For ordinal scales, the inferred tick format can be more concise, such\n      // as only showing the year for yearly data.\n      const scale = scales[key];\n      this.format[key] = scale?.bandwidth ? inferTickFormat(scale, scale.domain()) : formatDefault;\n    }\n  }\n\n  return sources;\n}\n\n// Promote x and y shorthand for paired channels, while preserving order.\nfunction maybeExpandPairedFormat(format, channels, key) {\n  if (!(key in format)) return format;\n  const key1 = `${key}1`;\n  const key2 = `${key}2`;\n  if ((key1 in format || !(key1 in channels)) && (key2 in format || !(key2 in channels))) return format;\n  const entries = Object.entries(format);\n  const value = format[key];\n  entries.splice(entries.findIndex(([name]) => name === key) + 1, 0, [key1, value], [key2, value]);\n  return Object.fromEntries(entries);\n}\n\nfunction formatTitle(i, index, {title}) {\n  return this.format.title(title.value[i], i);\n}\n\nfunction* formatChannels(i, index, channels, scales, values) {\n  for (const key in channels) {\n    if (key === \"fx\" || key === \"fy\") {\n      yield {\n        label: formatLabel(scales, channels, key),\n        value: this.format[key](index[key], i)\n      };\n      continue;\n    }\n    if (key === \"x1\" && \"x2\" in channels) continue;\n    if (key === \"y1\" && \"y2\" in channels) continue;\n    const channel = channels[key];\n    if (key === \"x2\" && \"x1\" in channels) {\n      yield {\n        label: formatPairLabel(scales, channels, \"x\"),\n        value: formatPair(this.format.x2, channels.x1, channel, i)\n      };\n    } else if (key === \"y2\" && \"y1\" in channels) {\n      yield {\n        label: formatPairLabel(scales, channels, \"y\"),\n        value: formatPair(this.format.y2, channels.y1, channel, i)\n      };\n    } else {\n      const value = channel.value[i];\n      const scale = channel.scale;\n      if (!defined(value) && scale == null) continue;\n      yield {\n        label: formatLabel(scales, channels, key),\n        value: this.format[key](value, i),\n        color: scale === \"color\" ? values[key][i] : null,\n        opacity: scale === \"opacity\" ? values[key][i] : null\n      };\n    }\n  }\n}\n\nfunction formatPair(formatValue, c1, c2, i) {\n  return c2.hint?.length // e.g., stackY’s y1 and y2\n    ? `${formatValue(c2.value[i] - c1.value[i], i)}`\n    : `${formatValue(c1.value[i], i)}–${formatValue(c2.value[i], i)}`;\n}\n\nfunction formatPairLabel(scales, channels, key) {\n  const l1 = formatLabel(scales, channels, `${key}1`, key);\n  const l2 = formatLabel(scales, channels, `${key}2`, key);\n  return l1 === l2 ? l1 : `${l1}–${l2}`;\n}\n\nfunction formatLabel(scales, channels, key, defaultLabel = key) {\n  const channel = channels[key];\n  const scale = scales[channel?.scale ?? key];\n  return String(scale?.label ?? channel?.label ?? defaultLabel);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}