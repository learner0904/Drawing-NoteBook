{"ast":null,"code":"import { count, group, rank } from \"d3\";\nimport { column, identity, isObject, maybeInput, maybeZ, taker, valueof } from \"../options.js\";\nimport { basic } from \"./basic.js\";\nexport function mapX(mapper, options = {}) {\n  let {\n    x,\n    x1,\n    x2\n  } = options;\n  if (x === undefined && x1 === undefined && x2 === undefined) options = {\n    ...options,\n    x: x = identity\n  };\n  const outputs = {};\n  if (x != null) outputs.x = mapper;\n  if (x1 != null) outputs.x1 = mapper;\n  if (x2 != null) outputs.x2 = mapper;\n  return map(outputs, options);\n}\nexport function mapY(mapper, options = {}) {\n  let {\n    y,\n    y1,\n    y2\n  } = options;\n  if (y === undefined && y1 === undefined && y2 === undefined) options = {\n    ...options,\n    y: y = identity\n  };\n  const outputs = {};\n  if (y != null) outputs.y = mapper;\n  if (y1 != null) outputs.y1 = mapper;\n  if (y2 != null) outputs.y2 = mapper;\n  return map(outputs, options);\n}\nexport function map(outputs = {}, options = {}) {\n  const z = maybeZ(options);\n  const channels = Object.entries(outputs).map(([key, map]) => {\n    const input = maybeInput(key, options);\n    if (input == null) throw new Error(`missing channel: ${key}`);\n    const [output, setOutput] = column(input);\n    return {\n      key,\n      input,\n      output,\n      setOutput,\n      map: maybeMap(map)\n    };\n  });\n  return {\n    ...basic(options, (data, facets) => {\n      const Z = valueof(data, z);\n      const X = channels.map(({\n        input\n      }) => valueof(data, input));\n      const MX = channels.map(({\n        setOutput\n      }) => setOutput(new Array(data.length)));\n      for (const facet of facets) {\n        for (const I of Z ? group(facet, i => Z[i]).values() : [facet]) {\n          channels.forEach(({\n            map\n          }, i) => map.mapIndex(I, X[i], MX[i]));\n        }\n      }\n      return {\n        data,\n        facets\n      };\n    }),\n    ...Object.fromEntries(channels.map(({\n      key,\n      output\n    }) => [key, output]))\n  };\n}\nfunction maybeMap(map) {\n  if (map == null) throw new Error(\"missing map\");\n  if (typeof map.mapIndex === \"function\") return map;\n  if (typeof map.map === \"function\" && isObject(map)) return mapMap(map); // N.B. array.map\n  if (typeof map === \"function\") return mapFunction(taker(map));\n  switch (`${map}`.toLowerCase()) {\n    case \"cumsum\":\n      return mapCumsum;\n    case \"rank\":\n      return mapFunction((I, V) => rank(I, i => V[i]));\n    case \"quantile\":\n      return mapFunction((I, V) => rankQuantile(I, i => V[i]));\n  }\n  throw new Error(`invalid map: ${map}`);\n}\nfunction mapMap(map) {\n  console.warn(\"deprecated map interface; implement mapIndex instead.\");\n  return {\n    mapIndex: map.map.bind(map)\n  };\n}\nfunction rankQuantile(I, f) {\n  const n = count(I, f) - 1;\n  return rank(I, f).map(r => r / n);\n}\nfunction mapFunction(f) {\n  return {\n    mapIndex(I, S, T) {\n      const M = f(I, S);\n      if (M.length !== I.length) throw new Error(\"map function returned a mismatched length\");\n      for (let i = 0, n = I.length; i < n; ++i) T[I[i]] = M[i];\n    }\n  };\n}\nconst mapCumsum = {\n  mapIndex(I, S, T) {\n    let sum = 0;\n    for (const i of I) T[i] = sum += S[i];\n  }\n};","map":{"version":3,"names":["count","group","rank","column","identity","isObject","maybeInput","maybeZ","taker","valueof","basic","mapX","mapper","options","x","x1","x2","undefined","outputs","map","mapY","y","y1","y2","z","channels","Object","entries","key","input","Error","output","setOutput","maybeMap","data","facets","Z","X","MX","Array","length","facet","I","i","values","forEach","mapIndex","fromEntries","mapMap","mapFunction","toLowerCase","mapCumsum","V","rankQuantile","console","warn","bind","f","n","r","S","T","M","sum"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/map.js"],"sourcesContent":["import {count, group, rank} from \"d3\";\nimport {column, identity, isObject, maybeInput, maybeZ, taker, valueof} from \"../options.js\";\nimport {basic} from \"./basic.js\";\n\nexport function mapX(mapper, options = {}) {\n  let {x, x1, x2} = options;\n  if (x === undefined && x1 === undefined && x2 === undefined) options = {...options, x: (x = identity)};\n  const outputs = {};\n  if (x != null) outputs.x = mapper;\n  if (x1 != null) outputs.x1 = mapper;\n  if (x2 != null) outputs.x2 = mapper;\n  return map(outputs, options);\n}\n\nexport function mapY(mapper, options = {}) {\n  let {y, y1, y2} = options;\n  if (y === undefined && y1 === undefined && y2 === undefined) options = {...options, y: (y = identity)};\n  const outputs = {};\n  if (y != null) outputs.y = mapper;\n  if (y1 != null) outputs.y1 = mapper;\n  if (y2 != null) outputs.y2 = mapper;\n  return map(outputs, options);\n}\n\nexport function map(outputs = {}, options = {}) {\n  const z = maybeZ(options);\n  const channels = Object.entries(outputs).map(([key, map]) => {\n    const input = maybeInput(key, options);\n    if (input == null) throw new Error(`missing channel: ${key}`);\n    const [output, setOutput] = column(input);\n    return {key, input, output, setOutput, map: maybeMap(map)};\n  });\n  return {\n    ...basic(options, (data, facets) => {\n      const Z = valueof(data, z);\n      const X = channels.map(({input}) => valueof(data, input));\n      const MX = channels.map(({setOutput}) => setOutput(new Array(data.length)));\n      for (const facet of facets) {\n        for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n          channels.forEach(({map}, i) => map.mapIndex(I, X[i], MX[i]));\n        }\n      }\n      return {data, facets};\n    }),\n    ...Object.fromEntries(channels.map(({key, output}) => [key, output]))\n  };\n}\n\nfunction maybeMap(map) {\n  if (map == null) throw new Error(\"missing map\");\n  if (typeof map.mapIndex === \"function\") return map;\n  if (typeof map.map === \"function\" && isObject(map)) return mapMap(map); // N.B. array.map\n  if (typeof map === \"function\") return mapFunction(taker(map));\n  switch (`${map}`.toLowerCase()) {\n    case \"cumsum\":\n      return mapCumsum;\n    case \"rank\":\n      return mapFunction((I, V) => rank(I, (i) => V[i]));\n    case \"quantile\":\n      return mapFunction((I, V) => rankQuantile(I, (i) => V[i]));\n  }\n  throw new Error(`invalid map: ${map}`);\n}\n\nfunction mapMap(map) {\n  console.warn(\"deprecated map interface; implement mapIndex instead.\");\n  return {mapIndex: map.map.bind(map)};\n}\n\nfunction rankQuantile(I, f) {\n  const n = count(I, f) - 1;\n  return rank(I, f).map((r) => r / n);\n}\n\nfunction mapFunction(f) {\n  return {\n    mapIndex(I, S, T) {\n      const M = f(I, S);\n      if (M.length !== I.length) throw new Error(\"map function returned a mismatched length\");\n      for (let i = 0, n = I.length; i < n; ++i) T[I[i]] = M[i];\n    }\n  };\n}\n\nconst mapCumsum = {\n  mapIndex(I, S, T) {\n    let sum = 0;\n    for (const i of I) T[i] = sum += S[i];\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}