{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { blur2, contours, geoPath, max, min, nice, range, ticks, thresholdSturges } from \"d3\";\nimport { createChannels } from \"../channel.js\";\nimport { create } from \"../context.js\";\nimport { labelof, identity, arrayify, map } from \"../options.js\";\nimport { applyPosition } from \"../projection.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform, styles } from \"../style.js\";\nimport { initializer } from \"../transforms/basic.js\";\nimport { maybeThresholds } from \"../transforms/bin.js\";\nimport { AbstractRaster, maybeTuples, rasterBounds, sampler } from \"./raster.js\";\nconst defaults = {\n  ariaLabel: \"contour\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1,\n  pixelSize: 2\n};\nexport class Contour extends AbstractRaster {\n  constructor(data, {\n    smooth = true,\n    value,\n    ...options\n  } = {}) {\n    const channels = styles({}, options, defaults);\n\n    // If value is not specified explicitly, look for a channel to promote. If\n    // more than one channel is present, throw an error. (To disambiguate,\n    // specify the value option explicitly.)\n    if (value === undefined) {\n      for (const key in channels) {\n        if (channels[key].value != null) {\n          if (value !== undefined) throw new Error(\"ambiguous contour value\");\n          value = options[key];\n          options[key] = \"value\";\n        }\n      }\n    }\n\n    // For any channel specified as the literal (contour threshold) \"value\"\n    // (maybe because of the promotion above), propagate the label from the\n    // original value definition.\n    if (value != null) {\n      const v = {\n        transform: D => D.map(d => d.value),\n        label: labelof(value)\n      };\n      for (const key in channels) {\n        if (options[key] === \"value\") {\n          options[key] = v;\n        }\n      }\n    }\n\n    // If the data is null, then we’ll construct the raster grid by evaluating a\n    // function for each point in a dense grid. The value channel is populated\n    // by the sampler initializer, and hence is not passed to super to avoid\n    // computing it before there’s data.\n    if (data == null) {\n      if (value == null) throw new Error(\"missing contour value\");\n      options = sampler(\"value\", {\n        value,\n        ...options\n      });\n      value = null;\n    }\n\n    // Otherwise if data was provided, it represents a discrete set of spatial\n    // samples (often a grid, but not necessarily). If no interpolation method\n    // was specified, default to nearest.\n    else {\n      let {\n        interpolate\n      } = options;\n      if (value === undefined) value = identity;\n      if (interpolate === undefined) options.interpolate = \"nearest\";\n    }\n\n    // Wrap the options in our initializer that computes the contour geometries;\n    // this runs after any other initializers (and transforms).\n    super(data, {\n      value: {\n        value,\n        optional: true\n      }\n    }, contourGeometry(options), defaults);\n\n    // With the exception of the x, y, x1, y1, x2, y2, and value channels, this\n    // mark’s channels are not evaluated on the initial data but rather on the\n    // contour multipolygons generated in the initializer.\n    const contourChannels = {\n      geometry: {\n        value: identity\n      }\n    };\n    for (const key in this.channels) {\n      const channel = this.channels[key];\n      const {\n        scale\n      } = channel;\n      if (scale === \"x\" || scale === \"y\" || key === \"value\") continue;\n      contourChannels[key] = channel;\n      delete this.channels[key];\n    }\n    this.contourChannels = contourChannels;\n    this.smooth = !!smooth;\n  }\n  filter(index, {\n    x,\n    y,\n    value,\n    ...channels\n  }, values) {\n    // Only filter channels constructed by the contourGeometry initializer; the\n    // x, y, and value channels must be filtered by the initializer itself.\n    return super.filter(index, channels, values);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      geometry: G\n    } = channels;\n    const path = geoPath();\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(g => {\n      g.selectAll().data(index).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", i => path(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n}\nfunction contourGeometry({\n  thresholds,\n  interval,\n  ...options\n}) {\n  thresholds = maybeThresholds(thresholds, interval, thresholdSturges);\n  return initializer(options, function (data, facets, channels, scales, dimensions, context) {\n    const [x1, y1, x2, y2] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {\n      pixelSize: k,\n      width: w = Math.round(Math.abs(dx) / k),\n      height: h = Math.round(Math.abs(dy) / k)\n    } = this;\n    const kx = w / dx;\n    const ky = h / dy;\n    const V = channels.value.value;\n    const VV = []; // V per facet\n\n    // Interpolate the raster grid, as needed.\n    if (this.interpolate) {\n      const {\n        x: X,\n        y: Y\n      } = applyPosition(channels, scales, context);\n      // Convert scaled (screen) coordinates to grid (canvas) coordinates.\n      const IX = map(X, x => (x - x1) * kx, Float64Array);\n      const IY = map(Y, y => (y - y1) * ky, Float64Array);\n      // The contour mark normally skips filtering on x, y, and value, so here\n      // we’re careful to use different names (0, 1, 2) when filtering.\n      const ichannels = [channels.x, channels.y, channels.value];\n      const ivalues = [IX, IY, V];\n      for (const facet of facets) {\n        const index = this.filter(facet, ichannels, ivalues);\n        VV.push(this.interpolate(index, w, h, IX, IY, V));\n      }\n    }\n\n    // Otherwise, chop up the existing dense raster grid into facets, if needed.\n    // V must be a dense grid in projected coordinates; if there are multiple\n    // facets, then V must be laid out vertically as facet 0, 1, 2… etc.\n    else if (facets) {\n      const n = w * h;\n      const m = facets.length;\n      for (let i = 0; i < m; ++i) VV.push(V.slice(i * n, i * n + n));\n    } else {\n      VV.push(V);\n    }\n\n    // Blur the raster grid, if desired.\n    if (this.blur > 0) for (const V of VV) blur2({\n      data: V,\n      width: w,\n      height: h\n    }, this.blur);\n\n    // Compute the contour thresholds.\n    const T = maybeTicks(thresholds, V, ...finiteExtent(VV));\n    if (T === null) throw new Error(`unsupported thresholds: ${thresholds}`);\n\n    // Compute the (maybe faceted) contours.\n    const {\n      contour\n    } = contours().size([w, h]).smooth(this.smooth);\n    const contourData = [];\n    const contourFacets = [];\n    for (const V of VV) {\n      contourFacets.push(range(contourData.length, contourData.push(...map(T, t => contour(V, t)))));\n    }\n\n    // Rescale the contour multipolygon from grid to screen coordinates.\n    for (const {\n      coordinates\n    } of contourData) {\n      for (const rings of coordinates) {\n        for (const ring of rings) {\n          for (const point of ring) {\n            point[0] = point[0] / kx + x1;\n            point[1] = point[1] / ky + y1;\n          }\n        }\n      }\n    }\n\n    // Compute the deferred channels.\n    return {\n      data: contourData,\n      facets: contourFacets,\n      channels: createChannels(this.contourChannels, contourData)\n    };\n  });\n}\n\n// Apply the thresholds interval, function, or count, and return an array of\n// ticks. d3-contour unlike d3-array doesn’t pass the min and max automatically,\n// so we do that here to normalize, and also so we can share consistent\n// thresholds across facets. When an interval is used, note that the lowest\n// threshold should be below (or equal) to the lowest value, or else some data\n// will be missing.\nfunction maybeTicks(thresholds, V, min, max) {\n  if (typeof thresholds?.range === \"function\") return thresholds.range(thresholds.floor(min), max);\n  if (typeof thresholds === \"function\") thresholds = thresholds(V, min, max);\n  if (typeof thresholds !== \"number\") return arrayify(thresholds);\n  const tz = ticks(...nice(min, max, thresholds), thresholds);\n  while (tz[tz.length - 1] >= max) tz.pop();\n  while (tz[1] < min) tz.shift();\n  return tz;\n}\nexport function contour() {\n  return new Contour(...maybeTuples(\"value\", ...arguments));\n}\nfunction finiteExtent(VV) {\n  return [min(VV, V => min(V, finite)), max(VV, V => max(V, finite))];\n}\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}","map":{"version":3,"names":["blur2","contours","geoPath","max","min","nice","range","ticks","thresholdSturges","createChannels","create","labelof","identity","arrayify","map","applyPosition","applyChannelStyles","applyDirectStyles","applyIndirectStyles","applyTransform","styles","initializer","maybeThresholds","AbstractRaster","maybeTuples","rasterBounds","sampler","defaults","ariaLabel","fill","stroke","strokeMiterlimit","pixelSize","Contour","constructor","data","smooth","value","options","channels","undefined","key","Error","v","transform","D","d","label","interpolate","optional","contourGeometry","contourChannels","geometry","channel","scale","filter","index","x","y","values","render","scales","dimensions","context","G","path","call","g","selectAll","enter","append","attr","i","node","thresholds","interval","facets","x1","y1","x2","y2","dx","dy","k","width","w","Math","round","abs","height","h","kx","ky","V","VV","X","Y","IX","Float64Array","IY","ichannels","ivalues","facet","push","n","m","length","slice","blur","T","maybeTicks","finiteExtent","contour","size","contourData","contourFacets","t","coordinates","rings","ring","point","floor","tz","pop","shift","arguments","finite","isFinite","NaN"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/contour.js"],"sourcesContent":["import {blur2, contours, geoPath, max, min, nice, range, ticks, thresholdSturges} from \"d3\";\nimport {createChannels} from \"../channel.js\";\nimport {create} from \"../context.js\";\nimport {labelof, identity, arrayify, map} from \"../options.js\";\nimport {applyPosition} from \"../projection.js\";\nimport {applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform, styles} from \"../style.js\";\nimport {initializer} from \"../transforms/basic.js\";\nimport {maybeThresholds} from \"../transforms/bin.js\";\nimport {AbstractRaster, maybeTuples, rasterBounds, sampler} from \"./raster.js\";\n\nconst defaults = {\n  ariaLabel: \"contour\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1,\n  pixelSize: 2\n};\n\nexport class Contour extends AbstractRaster {\n  constructor(data, {smooth = true, value, ...options} = {}) {\n    const channels = styles({}, options, defaults);\n\n    // If value is not specified explicitly, look for a channel to promote. If\n    // more than one channel is present, throw an error. (To disambiguate,\n    // specify the value option explicitly.)\n    if (value === undefined) {\n      for (const key in channels) {\n        if (channels[key].value != null) {\n          if (value !== undefined) throw new Error(\"ambiguous contour value\");\n          value = options[key];\n          options[key] = \"value\";\n        }\n      }\n    }\n\n    // For any channel specified as the literal (contour threshold) \"value\"\n    // (maybe because of the promotion above), propagate the label from the\n    // original value definition.\n    if (value != null) {\n      const v = {transform: (D) => D.map((d) => d.value), label: labelof(value)};\n      for (const key in channels) {\n        if (options[key] === \"value\") {\n          options[key] = v;\n        }\n      }\n    }\n\n    // If the data is null, then we’ll construct the raster grid by evaluating a\n    // function for each point in a dense grid. The value channel is populated\n    // by the sampler initializer, and hence is not passed to super to avoid\n    // computing it before there’s data.\n    if (data == null) {\n      if (value == null) throw new Error(\"missing contour value\");\n      options = sampler(\"value\", {value, ...options});\n      value = null;\n    }\n\n    // Otherwise if data was provided, it represents a discrete set of spatial\n    // samples (often a grid, but not necessarily). If no interpolation method\n    // was specified, default to nearest.\n    else {\n      let {interpolate} = options;\n      if (value === undefined) value = identity;\n      if (interpolate === undefined) options.interpolate = \"nearest\";\n    }\n\n    // Wrap the options in our initializer that computes the contour geometries;\n    // this runs after any other initializers (and transforms).\n    super(data, {value: {value, optional: true}}, contourGeometry(options), defaults);\n\n    // With the exception of the x, y, x1, y1, x2, y2, and value channels, this\n    // mark’s channels are not evaluated on the initial data but rather on the\n    // contour multipolygons generated in the initializer.\n    const contourChannels = {geometry: {value: identity}};\n    for (const key in this.channels) {\n      const channel = this.channels[key];\n      const {scale} = channel;\n      if (scale === \"x\" || scale === \"y\" || key === \"value\") continue;\n      contourChannels[key] = channel;\n      delete this.channels[key];\n    }\n    this.contourChannels = contourChannels;\n    this.smooth = !!smooth;\n  }\n  filter(index, {x, y, value, ...channels}, values) {\n    // Only filter channels constructed by the contourGeometry initializer; the\n    // x, y, and value channels must be filtered by the initializer itself.\n    return super.filter(index, channels, values);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {geometry: G} = channels;\n    const path = geoPath();\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, scales)\n      .call((g) => {\n        g.selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .attr(\"d\", (i) => path(G[i]))\n          .call(applyChannelStyles, this, channels);\n      })\n      .node();\n  }\n}\n\nfunction contourGeometry({thresholds, interval, ...options}) {\n  thresholds = maybeThresholds(thresholds, interval, thresholdSturges);\n  return initializer(options, function (data, facets, channels, scales, dimensions, context) {\n    const [x1, y1, x2, y2] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {pixelSize: k, width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k)} = this;\n    const kx = w / dx;\n    const ky = h / dy;\n    const V = channels.value.value;\n    const VV = []; // V per facet\n\n    // Interpolate the raster grid, as needed.\n    if (this.interpolate) {\n      const {x: X, y: Y} = applyPosition(channels, scales, context);\n      // Convert scaled (screen) coordinates to grid (canvas) coordinates.\n      const IX = map(X, (x) => (x - x1) * kx, Float64Array);\n      const IY = map(Y, (y) => (y - y1) * ky, Float64Array);\n      // The contour mark normally skips filtering on x, y, and value, so here\n      // we’re careful to use different names (0, 1, 2) when filtering.\n      const ichannels = [channels.x, channels.y, channels.value];\n      const ivalues = [IX, IY, V];\n      for (const facet of facets) {\n        const index = this.filter(facet, ichannels, ivalues);\n        VV.push(this.interpolate(index, w, h, IX, IY, V));\n      }\n    }\n\n    // Otherwise, chop up the existing dense raster grid into facets, if needed.\n    // V must be a dense grid in projected coordinates; if there are multiple\n    // facets, then V must be laid out vertically as facet 0, 1, 2… etc.\n    else if (facets) {\n      const n = w * h;\n      const m = facets.length;\n      for (let i = 0; i < m; ++i) VV.push(V.slice(i * n, i * n + n));\n    } else {\n      VV.push(V);\n    }\n\n    // Blur the raster grid, if desired.\n    if (this.blur > 0) for (const V of VV) blur2({data: V, width: w, height: h}, this.blur);\n\n    // Compute the contour thresholds.\n    const T = maybeTicks(thresholds, V, ...finiteExtent(VV));\n    if (T === null) throw new Error(`unsupported thresholds: ${thresholds}`);\n\n    // Compute the (maybe faceted) contours.\n    const {contour} = contours().size([w, h]).smooth(this.smooth);\n    const contourData = [];\n    const contourFacets = [];\n    for (const V of VV) {\n      contourFacets.push(range(contourData.length, contourData.push(...map(T, (t) => contour(V, t)))));\n    }\n\n    // Rescale the contour multipolygon from grid to screen coordinates.\n    for (const {coordinates} of contourData) {\n      for (const rings of coordinates) {\n        for (const ring of rings) {\n          for (const point of ring) {\n            point[0] = point[0] / kx + x1;\n            point[1] = point[1] / ky + y1;\n          }\n        }\n      }\n    }\n\n    // Compute the deferred channels.\n    return {\n      data: contourData,\n      facets: contourFacets,\n      channels: createChannels(this.contourChannels, contourData)\n    };\n  });\n}\n\n// Apply the thresholds interval, function, or count, and return an array of\n// ticks. d3-contour unlike d3-array doesn’t pass the min and max automatically,\n// so we do that here to normalize, and also so we can share consistent\n// thresholds across facets. When an interval is used, note that the lowest\n// threshold should be below (or equal) to the lowest value, or else some data\n// will be missing.\nfunction maybeTicks(thresholds, V, min, max) {\n  if (typeof thresholds?.range === \"function\") return thresholds.range(thresholds.floor(min), max);\n  if (typeof thresholds === \"function\") thresholds = thresholds(V, min, max);\n  if (typeof thresholds !== \"number\") return arrayify(thresholds);\n  const tz = ticks(...nice(min, max, thresholds), thresholds);\n  while (tz[tz.length - 1] >= max) tz.pop();\n  while (tz[1] < min) tz.shift();\n  return tz;\n}\n\nexport function contour() {\n  return new Contour(...maybeTuples(\"value\", ...arguments));\n}\n\nfunction finiteExtent(VV) {\n  return [min(VV, (V) => min(V, finite)), max(VV, (V) => max(V, finite))];\n}\n\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}\n"],"mappings":";;;;AAAA,SAAQA,KAAK,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,GAAG,EAAEC,GAAG,EAAEC,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAEC,gBAAgB,QAAO,IAAI;AAC3F,SAAQC,cAAc,QAAO,eAAe;AAC5C,SAAQC,MAAM,QAAO,eAAe;AACpC,SAAQC,OAAO,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,GAAG,QAAO,eAAe;AAC9D,SAAQC,aAAa,QAAO,kBAAkB;AAC9C,SAAQC,kBAAkB,EAAEC,iBAAiB,EAAEC,mBAAmB,EAAEC,cAAc,EAAEC,MAAM,QAAO,aAAa;AAC9G,SAAQC,WAAW,QAAO,wBAAwB;AAClD,SAAQC,eAAe,QAAO,sBAAsB;AACpD,SAAQC,cAAc,EAAEC,WAAW,EAAEC,YAAY,EAAEC,OAAO,QAAO,aAAa;AAE9E,MAAMC,QAAQ,GAAG;EACfC,SAAS,EAAE,SAAS;EACpBC,IAAI,EAAE,MAAM;EACZC,MAAM,EAAE,cAAc;EACtBC,gBAAgB,EAAE,CAAC;EACnBC,SAAS,EAAE;AACb,CAAC;AAED,OAAO,MAAMC,OAAO,SAASV,cAAc,CAAC;EAC1CW,WAAWA,CAACC,IAAI,EAAE;IAACC,MAAM,GAAG,IAAI;IAAEC,KAAK;IAAE,GAAGC;EAAO,CAAC,GAAG,CAAC,CAAC,EAAE;IACzD,MAAMC,QAAQ,GAAGnB,MAAM,CAAC,CAAC,CAAC,EAAEkB,OAAO,EAAEX,QAAQ,CAAC;;IAE9C;IACA;IACA;IACA,IAAIU,KAAK,KAAKG,SAAS,EAAE;MACvB,KAAK,MAAMC,GAAG,IAAIF,QAAQ,EAAE;QAC1B,IAAIA,QAAQ,CAACE,GAAG,CAAC,CAACJ,KAAK,IAAI,IAAI,EAAE;UAC/B,IAAIA,KAAK,KAAKG,SAAS,EAAE,MAAM,IAAIE,KAAK,CAAC,yBAAyB,CAAC;UACnEL,KAAK,GAAGC,OAAO,CAACG,GAAG,CAAC;UACpBH,OAAO,CAACG,GAAG,CAAC,GAAG,OAAO;QACxB;MACF;IACF;;IAEA;IACA;IACA;IACA,IAAIJ,KAAK,IAAI,IAAI,EAAE;MACjB,MAAMM,CAAC,GAAG;QAACC,SAAS,EAAGC,CAAC,IAAKA,CAAC,CAAC/B,GAAG,CAAEgC,CAAC,IAAKA,CAAC,CAACT,KAAK,CAAC;QAAEU,KAAK,EAAEpC,OAAO,CAAC0B,KAAK;MAAC,CAAC;MAC1E,KAAK,MAAMI,GAAG,IAAIF,QAAQ,EAAE;QAC1B,IAAID,OAAO,CAACG,GAAG,CAAC,KAAK,OAAO,EAAE;UAC5BH,OAAO,CAACG,GAAG,CAAC,GAAGE,CAAC;QAClB;MACF;IACF;;IAEA;IACA;IACA;IACA;IACA,IAAIR,IAAI,IAAI,IAAI,EAAE;MAChB,IAAIE,KAAK,IAAI,IAAI,EAAE,MAAM,IAAIK,KAAK,CAAC,uBAAuB,CAAC;MAC3DJ,OAAO,GAAGZ,OAAO,CAAC,OAAO,EAAE;QAACW,KAAK;QAAE,GAAGC;MAAO,CAAC,CAAC;MAC/CD,KAAK,GAAG,IAAI;IACd;;IAEA;IACA;IACA;IAAA,KACK;MACH,IAAI;QAACW;MAAW,CAAC,GAAGV,OAAO;MAC3B,IAAID,KAAK,KAAKG,SAAS,EAAEH,KAAK,GAAGzB,QAAQ;MACzC,IAAIoC,WAAW,KAAKR,SAAS,EAAEF,OAAO,CAACU,WAAW,GAAG,SAAS;IAChE;;IAEA;IACA;IACA,KAAK,CAACb,IAAI,EAAE;MAACE,KAAK,EAAE;QAACA,KAAK;QAAEY,QAAQ,EAAE;MAAI;IAAC,CAAC,EAAEC,eAAe,CAACZ,OAAO,CAAC,EAAEX,QAAQ,CAAC;;IAEjF;IACA;IACA;IACA,MAAMwB,eAAe,GAAG;MAACC,QAAQ,EAAE;QAACf,KAAK,EAAEzB;MAAQ;IAAC,CAAC;IACrD,KAAK,MAAM6B,GAAG,IAAI,IAAI,CAACF,QAAQ,EAAE;MAC/B,MAAMc,OAAO,GAAG,IAAI,CAACd,QAAQ,CAACE,GAAG,CAAC;MAClC,MAAM;QAACa;MAAK,CAAC,GAAGD,OAAO;MACvB,IAAIC,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,GAAG,IAAIb,GAAG,KAAK,OAAO,EAAE;MACvDU,eAAe,CAACV,GAAG,CAAC,GAAGY,OAAO;MAC9B,OAAO,IAAI,CAACd,QAAQ,CAACE,GAAG,CAAC;IAC3B;IACA,IAAI,CAACU,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACf,MAAM,GAAG,CAAC,CAACA,MAAM;EACxB;EACAmB,MAAMA,CAACC,KAAK,EAAE;IAACC,CAAC;IAAEC,CAAC;IAAErB,KAAK;IAAE,GAAGE;EAAQ,CAAC,EAAEoB,MAAM,EAAE;IAChD;IACA;IACA,OAAO,KAAK,CAACJ,MAAM,CAACC,KAAK,EAAEjB,QAAQ,EAAEoB,MAAM,CAAC;EAC9C;EACAC,MAAMA,CAACJ,KAAK,EAAEK,MAAM,EAAEtB,QAAQ,EAAEuB,UAAU,EAAEC,OAAO,EAAE;IACnD,MAAM;MAACX,QAAQ,EAAEY;IAAC,CAAC,GAAGzB,QAAQ;IAC9B,MAAM0B,IAAI,GAAG/D,OAAO,CAAC,CAAC;IACtB,OAAOQ,MAAM,CAAC,OAAO,EAAEqD,OAAO,CAAC,CAC5BG,IAAI,CAAChD,mBAAmB,EAAE,IAAI,EAAE4C,UAAU,EAAEC,OAAO,CAAC,CACpDG,IAAI,CAAC/C,cAAc,EAAE,IAAI,EAAE0C,MAAM,CAAC,CAClCK,IAAI,CAAEC,CAAC,IAAK;MACXA,CAAC,CAACC,SAAS,CAAC,CAAC,CACVjC,IAAI,CAACqB,KAAK,CAAC,CACXa,KAAK,CAAC,CAAC,CACPC,MAAM,CAAC,MAAM,CAAC,CACdJ,IAAI,CAACjD,iBAAiB,EAAE,IAAI,CAAC,CAC7BsD,IAAI,CAAC,GAAG,EAAGC,CAAC,IAAKP,IAAI,CAACD,CAAC,CAACQ,CAAC,CAAC,CAAC,CAAC,CAC5BN,IAAI,CAAClD,kBAAkB,EAAE,IAAI,EAAEuB,QAAQ,CAAC;IAC7C,CAAC,CAAC,CACDkC,IAAI,CAAC,CAAC;EACX;AACF;AAEA,SAASvB,eAAeA,CAAC;EAACwB,UAAU;EAAEC,QAAQ;EAAE,GAAGrC;AAAO,CAAC,EAAE;EAC3DoC,UAAU,GAAGpD,eAAe,CAACoD,UAAU,EAAEC,QAAQ,EAAEnE,gBAAgB,CAAC;EACpE,OAAOa,WAAW,CAACiB,OAAO,EAAE,UAAUH,IAAI,EAAEyC,MAAM,EAAErC,QAAQ,EAAEsB,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;IACzF,MAAM,CAACc,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGvD,YAAY,CAACc,QAAQ,EAAEsB,MAAM,EAAEC,UAAU,EAAEC,OAAO,CAAC;IAC5E,MAAMkB,EAAE,GAAGF,EAAE,GAAGF,EAAE;IAClB,MAAMK,EAAE,GAAGF,EAAE,GAAGF,EAAE;IAClB,MAAM;MAAC9C,SAAS,EAAEmD,CAAC;MAAEC,KAAK,EAAEC,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,GAAG,CAACP,EAAE,CAAC,GAAGE,CAAC,CAAC;MAAEM,MAAM,EAAEC,CAAC,GAAGJ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,GAAG,CAACN,EAAE,CAAC,GAAGC,CAAC;IAAC,CAAC,GAAG,IAAI;IAC9G,MAAMQ,EAAE,GAAGN,CAAC,GAAGJ,EAAE;IACjB,MAAMW,EAAE,GAAGF,CAAC,GAAGR,EAAE;IACjB,MAAMW,CAAC,GAAGtD,QAAQ,CAACF,KAAK,CAACA,KAAK;IAC9B,MAAMyD,EAAE,GAAG,EAAE,CAAC,CAAC;;IAEf;IACA,IAAI,IAAI,CAAC9C,WAAW,EAAE;MACpB,MAAM;QAACS,CAAC,EAAEsC,CAAC;QAAErC,CAAC,EAAEsC;MAAC,CAAC,GAAGjF,aAAa,CAACwB,QAAQ,EAAEsB,MAAM,EAAEE,OAAO,CAAC;MAC7D;MACA,MAAMkC,EAAE,GAAGnF,GAAG,CAACiF,CAAC,EAAGtC,CAAC,IAAK,CAACA,CAAC,GAAGoB,EAAE,IAAIc,EAAE,EAAEO,YAAY,CAAC;MACrD,MAAMC,EAAE,GAAGrF,GAAG,CAACkF,CAAC,EAAGtC,CAAC,IAAK,CAACA,CAAC,GAAGoB,EAAE,IAAIc,EAAE,EAAEM,YAAY,CAAC;MACrD;MACA;MACA,MAAME,SAAS,GAAG,CAAC7D,QAAQ,CAACkB,CAAC,EAAElB,QAAQ,CAACmB,CAAC,EAAEnB,QAAQ,CAACF,KAAK,CAAC;MAC1D,MAAMgE,OAAO,GAAG,CAACJ,EAAE,EAAEE,EAAE,EAAEN,CAAC,CAAC;MAC3B,KAAK,MAAMS,KAAK,IAAI1B,MAAM,EAAE;QAC1B,MAAMpB,KAAK,GAAG,IAAI,CAACD,MAAM,CAAC+C,KAAK,EAAEF,SAAS,EAAEC,OAAO,CAAC;QACpDP,EAAE,CAACS,IAAI,CAAC,IAAI,CAACvD,WAAW,CAACQ,KAAK,EAAE6B,CAAC,EAAEK,CAAC,EAAEO,EAAE,EAAEE,EAAE,EAAEN,CAAC,CAAC,CAAC;MACnD;IACF;;IAEA;IACA;IACA;IAAA,KACK,IAAIjB,MAAM,EAAE;MACf,MAAM4B,CAAC,GAAGnB,CAAC,GAAGK,CAAC;MACf,MAAMe,CAAC,GAAG7B,MAAM,CAAC8B,MAAM;MACvB,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,CAAC,EAAE,EAAEjC,CAAC,EAAEsB,EAAE,CAACS,IAAI,CAACV,CAAC,CAACc,KAAK,CAACnC,CAAC,GAAGgC,CAAC,EAAEhC,CAAC,GAAGgC,CAAC,GAAGA,CAAC,CAAC,CAAC;IAChE,CAAC,MAAM;MACLV,EAAE,CAACS,IAAI,CAACV,CAAC,CAAC;IACZ;;IAEA;IACA,IAAI,IAAI,CAACe,IAAI,GAAG,CAAC,EAAE,KAAK,MAAMf,CAAC,IAAIC,EAAE,EAAE9F,KAAK,CAAC;MAACmC,IAAI,EAAE0D,CAAC;MAAET,KAAK,EAAEC,CAAC;MAAEI,MAAM,EAAEC;IAAC,CAAC,EAAE,IAAI,CAACkB,IAAI,CAAC;;IAEvF;IACA,MAAMC,CAAC,GAAGC,UAAU,CAACpC,UAAU,EAAEmB,CAAC,EAAE,GAAGkB,YAAY,CAACjB,EAAE,CAAC,CAAC;IACxD,IAAIe,CAAC,KAAK,IAAI,EAAE,MAAM,IAAInE,KAAK,CAAE,2BAA0BgC,UAAW,EAAC,CAAC;;IAExE;IACA,MAAM;MAACsC;IAAO,CAAC,GAAG/G,QAAQ,CAAC,CAAC,CAACgH,IAAI,CAAC,CAAC5B,CAAC,EAAEK,CAAC,CAAC,CAAC,CAACtD,MAAM,CAAC,IAAI,CAACA,MAAM,CAAC;IAC7D,MAAM8E,WAAW,GAAG,EAAE;IACtB,MAAMC,aAAa,GAAG,EAAE;IACxB,KAAK,MAAMtB,CAAC,IAAIC,EAAE,EAAE;MAClBqB,aAAa,CAACZ,IAAI,CAACjG,KAAK,CAAC4G,WAAW,CAACR,MAAM,EAAEQ,WAAW,CAACX,IAAI,CAAC,GAAGzF,GAAG,CAAC+F,CAAC,EAAGO,CAAC,IAAKJ,OAAO,CAACnB,CAAC,EAAEuB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClG;;IAEA;IACA,KAAK,MAAM;MAACC;IAAW,CAAC,IAAIH,WAAW,EAAE;MACvC,KAAK,MAAMI,KAAK,IAAID,WAAW,EAAE;QAC/B,KAAK,MAAME,IAAI,IAAID,KAAK,EAAE;UACxB,KAAK,MAAME,KAAK,IAAID,IAAI,EAAE;YACxBC,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG7B,EAAE,GAAGd,EAAE;YAC7B2C,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG5B,EAAE,GAAGd,EAAE;UAC/B;QACF;MACF;IACF;;IAEA;IACA,OAAO;MACL3C,IAAI,EAAE+E,WAAW;MACjBtC,MAAM,EAAEuC,aAAa;MACrB5E,QAAQ,EAAE9B,cAAc,CAAC,IAAI,CAAC0C,eAAe,EAAE+D,WAAW;IAC5D,CAAC;EACH,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,UAAUA,CAACpC,UAAU,EAAEmB,CAAC,EAAEzF,GAAG,EAAED,GAAG,EAAE;EAC3C,IAAI,OAAOuE,UAAU,EAAEpE,KAAK,KAAK,UAAU,EAAE,OAAOoE,UAAU,CAACpE,KAAK,CAACoE,UAAU,CAAC+C,KAAK,CAACrH,GAAG,CAAC,EAAED,GAAG,CAAC;EAChG,IAAI,OAAOuE,UAAU,KAAK,UAAU,EAAEA,UAAU,GAAGA,UAAU,CAACmB,CAAC,EAAEzF,GAAG,EAAED,GAAG,CAAC;EAC1E,IAAI,OAAOuE,UAAU,KAAK,QAAQ,EAAE,OAAO7D,QAAQ,CAAC6D,UAAU,CAAC;EAC/D,MAAMgD,EAAE,GAAGnH,KAAK,CAAC,GAAGF,IAAI,CAACD,GAAG,EAAED,GAAG,EAAEuE,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC3D,OAAOgD,EAAE,CAACA,EAAE,CAAChB,MAAM,GAAG,CAAC,CAAC,IAAIvG,GAAG,EAAEuH,EAAE,CAACC,GAAG,CAAC,CAAC;EACzC,OAAOD,EAAE,CAAC,CAAC,CAAC,GAAGtH,GAAG,EAAEsH,EAAE,CAACE,KAAK,CAAC,CAAC;EAC9B,OAAOF,EAAE;AACX;AAEA,OAAO,SAASV,OAAOA,CAAA,EAAG;EACxB,OAAO,IAAI/E,OAAO,CAAC,GAAGT,WAAW,CAAC,OAAO,EAAE,GAAGqG,SAAS,CAAC,CAAC;AAC3D;AAEA,SAASd,YAAYA,CAACjB,EAAE,EAAE;EACxB,OAAO,CAAC1F,GAAG,CAAC0F,EAAE,EAAGD,CAAC,IAAKzF,GAAG,CAACyF,CAAC,EAAEiC,MAAM,CAAC,CAAC,EAAE3H,GAAG,CAAC2F,EAAE,EAAGD,CAAC,IAAK1F,GAAG,CAAC0F,CAAC,EAAEiC,MAAM,CAAC,CAAC,CAAC;AACzE;AAEA,SAASA,MAAMA,CAACrE,CAAC,EAAE;EACjB,OAAOsE,QAAQ,CAACtE,CAAC,CAAC,GAAGA,CAAC,GAAGuE,GAAG;AAC9B"},"metadata":{},"sourceType":"module","externalDependencies":[]}