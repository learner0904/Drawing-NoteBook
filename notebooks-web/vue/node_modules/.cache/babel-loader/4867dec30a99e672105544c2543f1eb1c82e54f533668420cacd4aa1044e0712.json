{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { lengthof, reindex, slice } from \"../options.js\";\nexport function exclusiveFacets(data, facets) {\n  if (facets.length === 1) return {\n    data,\n    facets\n  }; // only one facet; trivially exclusive\n\n  const n = lengthof(data);\n  const O = new Uint8Array(n);\n  let overlaps = 0;\n\n  // Count the number of overlapping indexes across facets.\n  for (const facet of facets) {\n    for (const i of facet) {\n      if (O[i]) ++overlaps;\n      O[i] = 1;\n    }\n  }\n\n  // Do nothing if the facets are already exclusive.\n  if (overlaps === 0) return {\n    data,\n    facets\n  }; // facets are exclusive\n\n  // For each overlapping index (duplicate), assign a new unique index at the\n  // end of the existing array, duplicating the datum. For example, [[0, 1, 2],\n  // [2, 1, 3]] would become [[0, 1, 2], [4, 5, 3]]. Also attach a reindex to\n  // the data to preserve the association of channel values specified as arrays.\n  data = slice(data);\n  const R = data[reindex] = new Uint32Array(n + overlaps);\n  facets = facets.map(facet => slice(facet, Uint32Array));\n  let j = n;\n  O.fill(0);\n  for (const facet of facets) {\n    for (let k = 0, m = facet.length; k < m; ++k) {\n      const i = facet[k];\n      if (O[i]) facet[k] = j, data[j] = data[i], R[j] = i, ++j;else R[i] = i;\n      O[i] = 1;\n    }\n  }\n  return {\n    data,\n    facets\n  };\n}","map":{"version":3,"names":["lengthof","reindex","slice","exclusiveFacets","data","facets","length","n","O","Uint8Array","overlaps","facet","i","R","Uint32Array","map","j","fill","k","m"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js"],"sourcesContent":["import {lengthof, reindex, slice} from \"../options.js\";\n\nexport function exclusiveFacets(data, facets) {\n  if (facets.length === 1) return {data, facets}; // only one facet; trivially exclusive\n\n  const n = lengthof(data);\n  const O = new Uint8Array(n);\n  let overlaps = 0;\n\n  // Count the number of overlapping indexes across facets.\n  for (const facet of facets) {\n    for (const i of facet) {\n      if (O[i]) ++overlaps;\n      O[i] = 1;\n    }\n  }\n\n  // Do nothing if the facets are already exclusive.\n  if (overlaps === 0) return {data, facets}; // facets are exclusive\n\n  // For each overlapping index (duplicate), assign a new unique index at the\n  // end of the existing array, duplicating the datum. For example, [[0, 1, 2],\n  // [2, 1, 3]] would become [[0, 1, 2], [4, 5, 3]]. Also attach a reindex to\n  // the data to preserve the association of channel values specified as arrays.\n  data = slice(data);\n  const R = (data[reindex] = new Uint32Array(n + overlaps));\n  facets = facets.map((facet) => slice(facet, Uint32Array));\n  let j = n;\n  O.fill(0);\n  for (const facet of facets) {\n    for (let k = 0, m = facet.length; k < m; ++k) {\n      const i = facet[k];\n      if (O[i]) (facet[k] = j), (data[j] = data[i]), (R[j] = i), ++j;\n      else R[i] = i;\n      O[i] = 1;\n    }\n  }\n\n  return {data, facets};\n}\n"],"mappings":";;;AAAA,SAAQA,QAAQ,EAAEC,OAAO,EAAEC,KAAK,QAAO,eAAe;AAEtD,OAAO,SAASC,eAAeA,CAACC,IAAI,EAAEC,MAAM,EAAE;EAC5C,IAAIA,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO;IAACF,IAAI;IAAEC;EAAM,CAAC,CAAC,CAAC;;EAEhD,MAAME,CAAC,GAAGP,QAAQ,CAACI,IAAI,CAAC;EACxB,MAAMI,CAAC,GAAG,IAAIC,UAAU,CAACF,CAAC,CAAC;EAC3B,IAAIG,QAAQ,GAAG,CAAC;;EAEhB;EACA,KAAK,MAAMC,KAAK,IAAIN,MAAM,EAAE;IAC1B,KAAK,MAAMO,CAAC,IAAID,KAAK,EAAE;MACrB,IAAIH,CAAC,CAACI,CAAC,CAAC,EAAE,EAAEF,QAAQ;MACpBF,CAAC,CAACI,CAAC,CAAC,GAAG,CAAC;IACV;EACF;;EAEA;EACA,IAAIF,QAAQ,KAAK,CAAC,EAAE,OAAO;IAACN,IAAI;IAAEC;EAAM,CAAC,CAAC,CAAC;;EAE3C;EACA;EACA;EACA;EACAD,IAAI,GAAGF,KAAK,CAACE,IAAI,CAAC;EAClB,MAAMS,CAAC,GAAIT,IAAI,CAACH,OAAO,CAAC,GAAG,IAAIa,WAAW,CAACP,CAAC,GAAGG,QAAQ,CAAE;EACzDL,MAAM,GAAGA,MAAM,CAACU,GAAG,CAAEJ,KAAK,IAAKT,KAAK,CAACS,KAAK,EAAEG,WAAW,CAAC,CAAC;EACzD,IAAIE,CAAC,GAAGT,CAAC;EACTC,CAAC,CAACS,IAAI,CAAC,CAAC,CAAC;EACT,KAAK,MAAMN,KAAK,IAAIN,MAAM,EAAE;IAC1B,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGR,KAAK,CAACL,MAAM,EAAEY,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAE;MAC5C,MAAMN,CAAC,GAAGD,KAAK,CAACO,CAAC,CAAC;MAClB,IAAIV,CAAC,CAACI,CAAC,CAAC,EAAGD,KAAK,CAACO,CAAC,CAAC,GAAGF,CAAC,EAAIZ,IAAI,CAACY,CAAC,CAAC,GAAGZ,IAAI,CAACQ,CAAC,CAAC,EAAIC,CAAC,CAACG,CAAC,CAAC,GAAGJ,CAAC,EAAG,EAAEI,CAAC,CAAC,KAC1DH,CAAC,CAACD,CAAC,CAAC,GAAGA,CAAC;MACbJ,CAAC,CAACI,CAAC,CAAC,GAAG,CAAC;IACV;EACF;EAEA,OAAO;IAACR,IAAI;IAAEC;EAAM,CAAC;AACvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}