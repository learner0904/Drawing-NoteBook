{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { namespaces } from \"d3\";\nimport { create } from \"../context.js\";\nimport { nonempty } from \"../defined.js\";\nimport { formatDefault } from \"../format.js\";\nimport { Mark } from \"../mark.js\";\nimport { indexOf, identity, string, maybeNumberChannel, maybeTuple, numberChannel, isNumeric, isTemporal, keyword, maybeFrameAnchor, isTextual, isIterable } from \"../options.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyAttr, applyTransform, impliedString, applyFrameAnchor } from \"../style.js\";\nimport { template } from \"../template.js\";\nimport { maybeIntervalMidX, maybeIntervalMidY } from \"../transforms/interval.js\";\nconst defaults = {\n  ariaLabel: \"text\",\n  strokeLinejoin: \"round\",\n  strokeWidth: 3,\n  paintOrder: \"stroke\"\n};\nconst softHyphen = \"\\u00ad\";\nexport class Text extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x,\n      y,\n      text = isIterable(data) && isTextual(data) ? identity : indexOf,\n      frameAnchor,\n      textAnchor = /right$/i.test(frameAnchor) ? \"end\" : /left$/i.test(frameAnchor) ? \"start\" : \"middle\",\n      lineAnchor = /^top/i.test(frameAnchor) ? \"top\" : /^bottom/i.test(frameAnchor) ? \"bottom\" : \"middle\",\n      lineHeight = 1,\n      lineWidth = Infinity,\n      textOverflow,\n      monospace,\n      fontFamily = monospace ? \"ui-monospace, monospace\" : undefined,\n      fontSize,\n      fontStyle,\n      fontVariant,\n      fontWeight,\n      rotate\n    } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: y,\n        scale: \"y\",\n        optional: true\n      },\n      fontSize: {\n        value: vfontSize,\n        optional: true\n      },\n      rotate: {\n        value: numberChannel(vrotate),\n        optional: true\n      },\n      text: {\n        value: text,\n        filter: nonempty,\n        optional: true\n      }\n    }, options, defaults);\n    this.rotate = crotate;\n    this.textAnchor = impliedString(textAnchor, \"middle\");\n    this.lineAnchor = keyword(lineAnchor, \"lineAnchor\", [\"top\", \"middle\", \"bottom\"]);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = string(fontFamily);\n    this.fontSize = cfontSize;\n    this.fontStyle = string(fontStyle);\n    this.fontVariant = string(fontVariant);\n    this.fontWeight = string(fontWeight);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    if (!(this.lineWidth >= 0)) throw new Error(`invalid lineWidth: ${lineWidth}`);\n    this.splitLines = splitter(this);\n    this.clipLine = clipper(this);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x,\n      y\n    } = scales;\n    const {\n      x: X,\n      y: Y,\n      rotate: R,\n      text: T,\n      title: TL,\n      fontSize: FS\n    } = channels;\n    const {\n      rotate\n    } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, {\n      x: X && x,\n      y: Y && y\n    }).call(g => g.selectAll().data(index).enter().append(\"text\").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(\"transform\", template`translate(${X ? i => X[i] : cx},${Y ? i => Y[i] : cy})${R ? i => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``}`).call(applyAttr, \"font-size\", FS && (i => FS[i])).call(applyChannelStyles, this, channels)).node();\n  }\n}\nexport function maybeTextOverflow(textOverflow) {\n  return textOverflow == null ? null : keyword(textOverflow, \"textOverflow\", [\"clip\",\n  // shorthand for clip-end\n  \"ellipsis\",\n  // … ellipsis-end\n  \"clip-start\", \"clip-end\", \"ellipsis-start\", \"ellipsis-middle\", \"ellipsis-end\"]).replace(/^(clip|ellipsis)$/, \"$1-end\");\n}\nfunction applyMultilineText(selection, mark, T, TL) {\n  if (!T) return;\n  const {\n    lineAnchor,\n    lineHeight,\n    textOverflow,\n    splitLines,\n    clipLine\n  } = mark;\n  selection.each(function (i) {\n    const lines = splitLines(formatDefault(T[i]) ?? \"\").map(clipLine);\n    const n = lines.length;\n    const y = lineAnchor === \"top\" ? 0.71 : lineAnchor === \"bottom\" ? 1 - n : (164 - n * 100) / 200;\n    if (n > 1) {\n      let m = 0;\n      for (let i = 0; i < n; ++i) {\n        ++m;\n        if (!lines[i]) continue;\n        const tspan = this.ownerDocument.createElementNS(namespaces.svg, \"tspan\");\n        tspan.setAttribute(\"x\", 0);\n        if (i === m - 1) tspan.setAttribute(\"y\", `${(y + i) * lineHeight}em`);else tspan.setAttribute(\"dy\", `${m * lineHeight}em`);\n        tspan.textContent = lines[i];\n        this.appendChild(tspan);\n        m = 0;\n      }\n    } else {\n      if (y) this.setAttribute(\"y\", `${y * lineHeight}em`);\n      this.textContent = lines[0];\n    }\n    if (textOverflow && !TL && lines[0] !== T[i]) {\n      const title = this.ownerDocument.createElementNS(namespaces.svg, \"title\");\n      title.textContent = T[i];\n      this.appendChild(title);\n    }\n  });\n}\nexport function text(data, {\n  x,\n  y,\n  ...options\n} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = maybeTuple(x, y);\n  return new Text(data, {\n    ...options,\n    x,\n    y\n  });\n}\nexport function textX(data, {\n  x = identity,\n  ...options\n} = {}) {\n  return new Text(data, maybeIntervalMidY({\n    ...options,\n    x\n  }));\n}\nexport function textY(data, {\n  y = identity,\n  ...options\n} = {}) {\n  return new Text(data, maybeIntervalMidX({\n    ...options,\n    y\n  }));\n}\nexport function applyIndirectTextStyles(selection, mark, T) {\n  applyAttr(selection, \"text-anchor\", mark.textAnchor);\n  applyAttr(selection, \"font-family\", mark.fontFamily);\n  applyAttr(selection, \"font-size\", mark.fontSize);\n  applyAttr(selection, \"font-style\", mark.fontStyle);\n  applyAttr(selection, \"font-variant\", mark.fontVariant === undefined ? inferFontVariant(T) : mark.fontVariant);\n  applyAttr(selection, \"font-weight\", mark.fontWeight);\n}\nfunction inferFontVariant(T) {\n  return T && (isNumeric(T) || isTemporal(T)) ? \"tabular-nums\" : undefined;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\nconst fontSizes = new Set([\n// global keywords\n\"inherit\", \"initial\", \"revert\", \"unset\",\n// absolute keywords\n\"xx-small\", \"x-small\", \"small\", \"medium\", \"large\", \"x-large\", \"xx-large\", \"xxx-large\",\n// relative keywords\n\"larger\", \"smaller\"]);\n\n// The font size may be expressed as a constant in the following forms:\n// - number in pixels\n// - string keyword: see above\n// - string <length>: e.g., \"12px\"\n// - string <percentage>: e.g., \"80%\"\n// Anything else is assumed to be a channel definition.\nfunction maybeFontSizeChannel(fontSize) {\n  if (fontSize == null || typeof fontSize === \"number\") return [undefined, fontSize];\n  if (typeof fontSize !== \"string\") return [fontSize, undefined];\n  fontSize = fontSize.trim().toLowerCase();\n  return fontSizes.has(fontSize) || /^[+-]?\\d*\\.?\\d+(e[+-]?\\d+)?(\\w*|%)$/.test(fontSize) ? [undefined, fontSize] : [fontSize, undefined];\n}\n\n// This is a greedy algorithm for line wrapping. It would be better to use the\n// Knuth–Plass line breaking algorithm (but that would be much more complex).\n// https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap\nfunction lineWrap(input, maxWidth, widthof) {\n  const lines = [];\n  let lineStart,\n    lineEnd = 0;\n  for (const [wordStart, wordEnd, required] of lineBreaks(input)) {\n    // Record the start of a line. This isn’t the same as the previous line’s\n    // end because we often skip spaces between lines.\n    if (lineStart === undefined) lineStart = wordStart;\n\n    // If the current line is not empty, and if adding the current word would\n    // make the line longer than the allowed width, then break the line at the\n    // previous word end.\n    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {\n      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? \"-\" : \"\"));\n      lineStart = wordStart;\n    }\n\n    // If this is a required break (a newline), emit the line and reset.\n    if (required) {\n      lines.push(input.slice(lineStart, wordEnd));\n      lineStart = undefined;\n      continue;\n    }\n\n    // Extend the current line to include the new word.\n    lineEnd = wordEnd;\n  }\n  return lines;\n}\n\n// This is a rudimentary (and U.S.-centric) algorithm for finding opportunities\n// to break lines between words. A better and far more comprehensive approach\n// would be to use the official Unicode Line Breaking Algorithm.\n// https://unicode.org/reports/tr14/\nfunction* lineBreaks(input) {\n  let i = 0,\n    j = 0;\n  const n = input.length;\n  while (j < n) {\n    let k = 1;\n    switch (input[j]) {\n      case softHyphen:\n      case \"-\":\n        // hyphen\n        ++j;\n        yield [i, j, false];\n        i = j;\n        break;\n      case \" \":\n        yield [i, j, false];\n        while (input[++j] === \" \"); // skip multiple spaces\n        i = j;\n        break;\n      case \"\\r\":\n        if (input[j + 1] === \"\\n\") ++k;\n      // falls through\n      case \"\\n\":\n        yield [i, j, true];\n        j += k;\n        i = j;\n        break;\n      default:\n        ++j;\n        break;\n    }\n  }\n  yield [i, j, true];\n}\n\n// Computed as round(measureText(text).width * 10) at 10px system-ui. For\n// characters that are not represented in this map, we’d ideally want to use a\n// weighted average of what we expect to see. But since we don’t really know\n// what that is, using “e” seems reasonable.\nconst defaultWidthMap = {\n  a: 56,\n  b: 63,\n  c: 57,\n  d: 63,\n  e: 58,\n  f: 37,\n  g: 62,\n  h: 60,\n  i: 26,\n  j: 26,\n  k: 55,\n  l: 26,\n  m: 88,\n  n: 60,\n  o: 60,\n  p: 62,\n  q: 62,\n  r: 39,\n  s: 54,\n  t: 38,\n  u: 60,\n  v: 55,\n  w: 79,\n  x: 54,\n  y: 55,\n  z: 55,\n  A: 69,\n  B: 67,\n  C: 73,\n  D: 74,\n  E: 61,\n  F: 58,\n  G: 76,\n  H: 75,\n  I: 28,\n  J: 55,\n  K: 67,\n  L: 58,\n  M: 89,\n  N: 75,\n  O: 78,\n  P: 65,\n  Q: 78,\n  R: 67,\n  S: 65,\n  T: 65,\n  U: 75,\n  V: 69,\n  W: 98,\n  X: 69,\n  Y: 67,\n  Z: 67,\n  0: 64,\n  1: 48,\n  2: 62,\n  3: 64,\n  4: 66,\n  5: 63,\n  6: 65,\n  7: 58,\n  8: 65,\n  9: 65,\n  \" \": 29,\n  \"!\": 32,\n  '\"': 49,\n  \"'\": 31,\n  \"(\": 39,\n  \")\": 39,\n  \",\": 31,\n  \"-\": 48,\n  \".\": 31,\n  \"/\": 32,\n  \":\": 31,\n  \";\": 31,\n  \"?\": 52,\n  \"‘\": 31,\n  \"’\": 31,\n  \"“\": 47,\n  \"”\": 47,\n  \"…\": 82\n};\n\n// This is a rudimentary (and U.S.-centric) algorithm for measuring the width of\n// a string based on a technique of Gregor Aisch; it assumes that individual\n// characters are laid out independently and does not implement the Unicode\n// grapheme cluster breaking algorithm. It does understand code points, though,\n// and so treats things like emoji as having the width of a lowercase e (and\n// should be equivalent to using for-of to iterate over code points, while also\n// being fast). TODO Optimize this by noting that we often re-measure characters\n// that were previously measured?\n// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n// https://exploringjs.com/impatient-js/ch_strings.html#atoms-of-text\nexport function defaultWidth(text, start = 0, end = text.length) {\n  let sum = 0;\n  for (let i = start; i < end; i = readCharacter(text, i)) {\n    sum += defaultWidthMap[text[i]] ?? (isPictographic(text, i) ? 120 : defaultWidthMap.e);\n  }\n  return sum;\n}\n\n// Even for monospaced text, we can’t assume that the number of UTF-16 code\n// points (i.e., the length of a string) corresponds to the number of visible\n// characters; we still have to count graphemes. And note that pictographic\n// characters such as emojis are typically not monospaced!\nexport function monospaceWidth(text, start = 0, end = text.length) {\n  let sum = 0;\n  for (let i = start; i < end; i = readCharacter(text, i)) {\n    sum += isPictographic(text, i) ? 126 : 63;\n  }\n  return sum;\n}\nexport function splitter({\n  monospace,\n  lineWidth,\n  textOverflow\n}) {\n  if (textOverflow != null || lineWidth == Infinity) return text => text.split(/\\r\\n?|\\n/g);\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  return text => lineWrap(text, maxWidth, widthof);\n}\nexport function clipper({\n  monospace,\n  lineWidth,\n  textOverflow\n}) {\n  if (textOverflow == null || lineWidth == Infinity) return text => text;\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  switch (textOverflow) {\n    case \"clip-start\":\n      return text => clipStart(text, maxWidth, widthof, \"\");\n    case \"clip-end\":\n      return text => clipEnd(text, maxWidth, widthof, \"\");\n    case \"ellipsis-start\":\n      return text => clipStart(text, maxWidth, widthof, ellipsis);\n    case \"ellipsis-middle\":\n      return text => clipMiddle(text, maxWidth, widthof, ellipsis);\n    case \"ellipsis-end\":\n      return text => clipEnd(text, maxWidth, widthof, ellipsis);\n  }\n}\nexport const ellipsis = \"…\";\n\n// Cuts the given text to the given width, using the specified widthof function;\n// the returned [index, error] guarantees text.slice(0, index) fits within the\n// specified width with the given error. If the text fits naturally within the\n// given width, returns [-1, 0]. If the text needs cutting, the given inset\n// specifies how much space (in the same units as width and widthof) to reserve\n// for a possible ellipsis character.\nexport function cut(text, width, widthof, inset) {\n  const I = []; // indexes of read character boundaries\n  let w = 0; // current line width\n  for (let i = 0, j = 0, n = text.length; i < n; i = j) {\n    j = readCharacter(text, i); // read the next character\n    const l = widthof(text, i, j); // current character width\n    if (w + l > width) {\n      w += inset;\n      while (w > width && i > 0) j = i, i = I.pop(), w -= widthof(text, i, j); // remove excess\n      return [i, width - w];\n    }\n    w += l;\n    I.push(i);\n  }\n  return [-1, 0];\n}\nexport function clipEnd(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const e = widthof(ellipsis);\n  const [i] = cut(text, width, widthof, e);\n  return i < 0 ? text : text.slice(0, i).trimEnd() + ellipsis;\n}\nexport function clipMiddle(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const w = widthof(text);\n  if (w <= width) return text;\n  const e = widthof(ellipsis) / 2;\n  const [i, ei] = cut(text, width / 2, widthof, e);\n  const [j] = cut(text, w - width / 2 - ei + e, widthof, -e); // TODO read spaces?\n  return j < 0 ? ellipsis : text.slice(0, i).trimEnd() + ellipsis + text.slice(readCharacter(text, j)).trimStart();\n}\nexport function clipStart(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const w = widthof(text);\n  if (w <= width) return text;\n  const e = widthof(ellipsis);\n  const [j] = cut(text, w - width + e, widthof, -e); // TODO read spaces?\n  return j < 0 ? ellipsis : ellipsis + text.slice(readCharacter(text, j)).trimStart();\n}\nconst reCombiner = /[\\p{Combining_Mark}\\p{Emoji_Modifier}]+/uy;\nconst rePictographic = /\\p{Extended_Pictographic}/uy;\n\n// Reads a single “character” element from the given text starting at the given\n// index, returning the index after the read character. Ideally, this implements\n// the Unicode text segmentation algorithm and understands grapheme cluster\n// boundaries, etc., but in practice this is only smart enough to detect UTF-16\n// surrogate pairs, combining marks, and zero-width joiner (zwj) sequences such\n// as emoji skin color modifiers. https://unicode.org/reports/tr29/\nexport function readCharacter(text, i) {\n  i += isSurrogatePair(text, i) ? 2 : 1;\n  if (isCombiner(text, i)) i = reCombiner.lastIndex;\n  if (isZeroWidthJoiner(text, i)) return readCharacter(text, i + 1);\n  return i;\n}\n\n// We avoid more expensive regex tests involving Unicode property classes by\n// first checking for the common case of 7-bit ASCII characters.\nfunction isAscii(text, i) {\n  return text.charCodeAt(i) < 0x80;\n}\nfunction isSurrogatePair(text, i) {\n  const hi = text.charCodeAt(i);\n  if (hi >= 0xd800 && hi < 0xdc00) {\n    const lo = text.charCodeAt(i + 1);\n    return lo >= 0xdc00 && lo < 0xe000;\n  }\n  return false;\n}\nfunction isZeroWidthJoiner(text, i) {\n  return text.charCodeAt(i) === 0x200d;\n}\nfunction isCombiner(text, i) {\n  return isAscii(text, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text));\n}\nfunction isPictographic(text, i) {\n  return isAscii(text, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text));\n}","map":{"version":3,"names":["namespaces","create","nonempty","formatDefault","Mark","indexOf","identity","string","maybeNumberChannel","maybeTuple","numberChannel","isNumeric","isTemporal","keyword","maybeFrameAnchor","isTextual","isIterable","applyChannelStyles","applyDirectStyles","applyIndirectStyles","applyAttr","applyTransform","impliedString","applyFrameAnchor","template","maybeIntervalMidX","maybeIntervalMidY","defaults","ariaLabel","strokeLinejoin","strokeWidth","paintOrder","softHyphen","Text","constructor","data","options","x","y","text","frameAnchor","textAnchor","test","lineAnchor","lineHeight","lineWidth","Infinity","textOverflow","monospace","fontFamily","undefined","fontSize","fontStyle","fontVariant","fontWeight","rotate","vrotate","crotate","vfontSize","cfontSize","maybeFontSizeChannel","value","scale","optional","filter","maybeTextOverflow","Error","splitLines","splitter","clipLine","clipper","render","index","scales","channels","dimensions","context","X","Y","R","T","title","TL","FS","cx","cy","call","applyIndirectTextStyles","g","selectAll","enter","append","applyMultilineText","attr","i","node","replace","selection","mark","each","lines","map","n","length","m","tspan","ownerDocument","createElementNS","svg","setAttribute","textContent","appendChild","textX","textY","inferFontVariant","fontSizes","Set","trim","toLowerCase","has","lineWrap","input","maxWidth","widthof","lineStart","lineEnd","wordStart","wordEnd","required","lineBreaks","push","slice","j","k","defaultWidthMap","a","b","c","d","e","f","h","l","o","p","q","r","s","t","u","v","w","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","S","U","V","W","Z","defaultWidth","start","end","sum","readCharacter","isPictographic","monospaceWidth","split","clipStart","clipEnd","ellipsis","clipMiddle","cut","width","inset","pop","trimEnd","ei","trimStart","reCombiner","rePictographic","isSurrogatePair","isCombiner","lastIndex","isZeroWidthJoiner","isAscii","charCodeAt","hi","lo"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/text.js"],"sourcesContent":["import {namespaces} from \"d3\";\nimport {create} from \"../context.js\";\nimport {nonempty} from \"../defined.js\";\nimport {formatDefault} from \"../format.js\";\nimport {Mark} from \"../mark.js\";\nimport {\n  indexOf,\n  identity,\n  string,\n  maybeNumberChannel,\n  maybeTuple,\n  numberChannel,\n  isNumeric,\n  isTemporal,\n  keyword,\n  maybeFrameAnchor,\n  isTextual,\n  isIterable\n} from \"../options.js\";\nimport {\n  applyChannelStyles,\n  applyDirectStyles,\n  applyIndirectStyles,\n  applyAttr,\n  applyTransform,\n  impliedString,\n  applyFrameAnchor\n} from \"../style.js\";\nimport {template} from \"../template.js\";\nimport {maybeIntervalMidX, maybeIntervalMidY} from \"../transforms/interval.js\";\n\nconst defaults = {\n  ariaLabel: \"text\",\n  strokeLinejoin: \"round\",\n  strokeWidth: 3,\n  paintOrder: \"stroke\"\n};\n\nconst softHyphen = \"\\u00ad\";\n\nexport class Text extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x,\n      y,\n      text = isIterable(data) && isTextual(data) ? identity : indexOf,\n      frameAnchor,\n      textAnchor = /right$/i.test(frameAnchor) ? \"end\" : /left$/i.test(frameAnchor) ? \"start\" : \"middle\",\n      lineAnchor = /^top/i.test(frameAnchor) ? \"top\" : /^bottom/i.test(frameAnchor) ? \"bottom\" : \"middle\",\n      lineHeight = 1,\n      lineWidth = Infinity,\n      textOverflow,\n      monospace,\n      fontFamily = monospace ? \"ui-monospace, monospace\" : undefined,\n      fontSize,\n      fontStyle,\n      fontVariant,\n      fontWeight,\n      rotate\n    } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        fontSize: {value: vfontSize, optional: true},\n        rotate: {value: numberChannel(vrotate), optional: true},\n        text: {value: text, filter: nonempty, optional: true}\n      },\n      options,\n      defaults\n    );\n    this.rotate = crotate;\n    this.textAnchor = impliedString(textAnchor, \"middle\");\n    this.lineAnchor = keyword(lineAnchor, \"lineAnchor\", [\"top\", \"middle\", \"bottom\"]);\n    this.lineHeight = +lineHeight;\n    this.lineWidth = +lineWidth;\n    this.textOverflow = maybeTextOverflow(textOverflow);\n    this.monospace = !!monospace;\n    this.fontFamily = string(fontFamily);\n    this.fontSize = cfontSize;\n    this.fontStyle = string(fontStyle);\n    this.fontVariant = string(fontVariant);\n    this.fontWeight = string(fontWeight);\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n    if (!(this.lineWidth >= 0)) throw new Error(`invalid lineWidth: ${lineWidth}`);\n    this.splitLines = splitter(this);\n    this.clipLine = clipper(this);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, rotate: R, text: T, title: TL, fontSize: FS} = channels;\n    const {rotate} = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyIndirectTextStyles, this, T, dimensions)\n      .call(applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"text\")\n          .call(applyDirectStyles, this)\n          .call(applyMultilineText, this, T, TL)\n          .attr(\n            \"transform\",\n            template`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${\n              R ? (i) => ` rotate(${R[i]})` : rotate ? ` rotate(${rotate})` : ``\n            }`\n          )\n          .call(applyAttr, \"font-size\", FS && ((i) => FS[i]))\n          .call(applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\nexport function maybeTextOverflow(textOverflow) {\n  return textOverflow == null\n    ? null\n    : keyword(textOverflow, \"textOverflow\", [\n        \"clip\", // shorthand for clip-end\n        \"ellipsis\", // … ellipsis-end\n        \"clip-start\",\n        \"clip-end\",\n        \"ellipsis-start\",\n        \"ellipsis-middle\",\n        \"ellipsis-end\"\n      ]).replace(/^(clip|ellipsis)$/, \"$1-end\");\n}\n\nfunction applyMultilineText(selection, mark, T, TL) {\n  if (!T) return;\n  const {lineAnchor, lineHeight, textOverflow, splitLines, clipLine} = mark;\n  selection.each(function (i) {\n    const lines = splitLines(formatDefault(T[i]) ?? \"\").map(clipLine);\n    const n = lines.length;\n    const y = lineAnchor === \"top\" ? 0.71 : lineAnchor === \"bottom\" ? 1 - n : (164 - n * 100) / 200;\n    if (n > 1) {\n      let m = 0;\n      for (let i = 0; i < n; ++i) {\n        ++m;\n        if (!lines[i]) continue;\n        const tspan = this.ownerDocument.createElementNS(namespaces.svg, \"tspan\");\n        tspan.setAttribute(\"x\", 0);\n        if (i === m - 1) tspan.setAttribute(\"y\", `${(y + i) * lineHeight}em`);\n        else tspan.setAttribute(\"dy\", `${m * lineHeight}em`);\n        tspan.textContent = lines[i];\n        this.appendChild(tspan);\n        m = 0;\n      }\n    } else {\n      if (y) this.setAttribute(\"y\", `${y * lineHeight}em`);\n      this.textContent = lines[0];\n    }\n    if (textOverflow && !TL && lines[0] !== T[i]) {\n      const title = this.ownerDocument.createElementNS(namespaces.svg, \"title\");\n      title.textContent = T[i];\n      this.appendChild(title);\n    }\n  });\n}\n\nexport function text(data, {x, y, ...options} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = maybeTuple(x, y);\n  return new Text(data, {...options, x, y});\n}\n\nexport function textX(data, {x = identity, ...options} = {}) {\n  return new Text(data, maybeIntervalMidY({...options, x}));\n}\n\nexport function textY(data, {y = identity, ...options} = {}) {\n  return new Text(data, maybeIntervalMidX({...options, y}));\n}\n\nexport function applyIndirectTextStyles(selection, mark, T) {\n  applyAttr(selection, \"text-anchor\", mark.textAnchor);\n  applyAttr(selection, \"font-family\", mark.fontFamily);\n  applyAttr(selection, \"font-size\", mark.fontSize);\n  applyAttr(selection, \"font-style\", mark.fontStyle);\n  applyAttr(selection, \"font-variant\", mark.fontVariant === undefined ? inferFontVariant(T) : mark.fontVariant);\n  applyAttr(selection, \"font-weight\", mark.fontWeight);\n}\n\nfunction inferFontVariant(T) {\n  return T && (isNumeric(T) || isTemporal(T)) ? \"tabular-nums\" : undefined;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\nconst fontSizes = new Set([\n  // global keywords\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n  // absolute keywords\n  \"xx-small\",\n  \"x-small\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"x-large\",\n  \"xx-large\",\n  \"xxx-large\",\n  // relative keywords\n  \"larger\",\n  \"smaller\"\n]);\n\n// The font size may be expressed as a constant in the following forms:\n// - number in pixels\n// - string keyword: see above\n// - string <length>: e.g., \"12px\"\n// - string <percentage>: e.g., \"80%\"\n// Anything else is assumed to be a channel definition.\nfunction maybeFontSizeChannel(fontSize) {\n  if (fontSize == null || typeof fontSize === \"number\") return [undefined, fontSize];\n  if (typeof fontSize !== \"string\") return [fontSize, undefined];\n  fontSize = fontSize.trim().toLowerCase();\n  return fontSizes.has(fontSize) || /^[+-]?\\d*\\.?\\d+(e[+-]?\\d+)?(\\w*|%)$/.test(fontSize)\n    ? [undefined, fontSize]\n    : [fontSize, undefined];\n}\n\n// This is a greedy algorithm for line wrapping. It would be better to use the\n// Knuth–Plass line breaking algorithm (but that would be much more complex).\n// https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap\nfunction lineWrap(input, maxWidth, widthof) {\n  const lines = [];\n  let lineStart,\n    lineEnd = 0;\n  for (const [wordStart, wordEnd, required] of lineBreaks(input)) {\n    // Record the start of a line. This isn’t the same as the previous line’s\n    // end because we often skip spaces between lines.\n    if (lineStart === undefined) lineStart = wordStart;\n\n    // If the current line is not empty, and if adding the current word would\n    // make the line longer than the allowed width, then break the line at the\n    // previous word end.\n    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {\n      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? \"-\" : \"\"));\n      lineStart = wordStart;\n    }\n\n    // If this is a required break (a newline), emit the line and reset.\n    if (required) {\n      lines.push(input.slice(lineStart, wordEnd));\n      lineStart = undefined;\n      continue;\n    }\n\n    // Extend the current line to include the new word.\n    lineEnd = wordEnd;\n  }\n  return lines;\n}\n\n// This is a rudimentary (and U.S.-centric) algorithm for finding opportunities\n// to break lines between words. A better and far more comprehensive approach\n// would be to use the official Unicode Line Breaking Algorithm.\n// https://unicode.org/reports/tr14/\nfunction* lineBreaks(input) {\n  let i = 0,\n    j = 0;\n  const n = input.length;\n  while (j < n) {\n    let k = 1;\n    switch (input[j]) {\n      case softHyphen:\n      case \"-\": // hyphen\n        ++j;\n        yield [i, j, false];\n        i = j;\n        break;\n      case \" \":\n        yield [i, j, false];\n        while (input[++j] === \" \"); // skip multiple spaces\n        i = j;\n        break;\n      case \"\\r\":\n        if (input[j + 1] === \"\\n\") ++k; // falls through\n      case \"\\n\":\n        yield [i, j, true];\n        j += k;\n        i = j;\n        break;\n      default:\n        ++j;\n        break;\n    }\n  }\n  yield [i, j, true];\n}\n\n// Computed as round(measureText(text).width * 10) at 10px system-ui. For\n// characters that are not represented in this map, we’d ideally want to use a\n// weighted average of what we expect to see. But since we don’t really know\n// what that is, using “e” seems reasonable.\nconst defaultWidthMap = {\n  a: 56,\n  b: 63,\n  c: 57,\n  d: 63,\n  e: 58,\n  f: 37,\n  g: 62,\n  h: 60,\n  i: 26,\n  j: 26,\n  k: 55,\n  l: 26,\n  m: 88,\n  n: 60,\n  o: 60,\n  p: 62,\n  q: 62,\n  r: 39,\n  s: 54,\n  t: 38,\n  u: 60,\n  v: 55,\n  w: 79,\n  x: 54,\n  y: 55,\n  z: 55,\n  A: 69,\n  B: 67,\n  C: 73,\n  D: 74,\n  E: 61,\n  F: 58,\n  G: 76,\n  H: 75,\n  I: 28,\n  J: 55,\n  K: 67,\n  L: 58,\n  M: 89,\n  N: 75,\n  O: 78,\n  P: 65,\n  Q: 78,\n  R: 67,\n  S: 65,\n  T: 65,\n  U: 75,\n  V: 69,\n  W: 98,\n  X: 69,\n  Y: 67,\n  Z: 67,\n  0: 64,\n  1: 48,\n  2: 62,\n  3: 64,\n  4: 66,\n  5: 63,\n  6: 65,\n  7: 58,\n  8: 65,\n  9: 65,\n  \" \": 29,\n  \"!\": 32,\n  '\"': 49,\n  \"'\": 31,\n  \"(\": 39,\n  \")\": 39,\n  \",\": 31,\n  \"-\": 48,\n  \".\": 31,\n  \"/\": 32,\n  \":\": 31,\n  \";\": 31,\n  \"?\": 52,\n  \"‘\": 31,\n  \"’\": 31,\n  \"“\": 47,\n  \"”\": 47,\n  \"…\": 82\n};\n\n// This is a rudimentary (and U.S.-centric) algorithm for measuring the width of\n// a string based on a technique of Gregor Aisch; it assumes that individual\n// characters are laid out independently and does not implement the Unicode\n// grapheme cluster breaking algorithm. It does understand code points, though,\n// and so treats things like emoji as having the width of a lowercase e (and\n// should be equivalent to using for-of to iterate over code points, while also\n// being fast). TODO Optimize this by noting that we often re-measure characters\n// that were previously measured?\n// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n// https://exploringjs.com/impatient-js/ch_strings.html#atoms-of-text\nexport function defaultWidth(text, start = 0, end = text.length) {\n  let sum = 0;\n  for (let i = start; i < end; i = readCharacter(text, i)) {\n    sum += defaultWidthMap[text[i]] ?? (isPictographic(text, i) ? 120 : defaultWidthMap.e);\n  }\n  return sum;\n}\n\n// Even for monospaced text, we can’t assume that the number of UTF-16 code\n// points (i.e., the length of a string) corresponds to the number of visible\n// characters; we still have to count graphemes. And note that pictographic\n// characters such as emojis are typically not monospaced!\nexport function monospaceWidth(text, start = 0, end = text.length) {\n  let sum = 0;\n  for (let i = start; i < end; i = readCharacter(text, i)) {\n    sum += isPictographic(text, i) ? 126 : 63;\n  }\n  return sum;\n}\n\nexport function splitter({monospace, lineWidth, textOverflow}) {\n  if (textOverflow != null || lineWidth == Infinity) return (text) => text.split(/\\r\\n?|\\n/g);\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  return (text) => lineWrap(text, maxWidth, widthof);\n}\n\nexport function clipper({monospace, lineWidth, textOverflow}) {\n  if (textOverflow == null || lineWidth == Infinity) return (text) => text;\n  const widthof = monospace ? monospaceWidth : defaultWidth;\n  const maxWidth = lineWidth * 100;\n  switch (textOverflow) {\n    case \"clip-start\":\n      return (text) => clipStart(text, maxWidth, widthof, \"\");\n    case \"clip-end\":\n      return (text) => clipEnd(text, maxWidth, widthof, \"\");\n    case \"ellipsis-start\":\n      return (text) => clipStart(text, maxWidth, widthof, ellipsis);\n    case \"ellipsis-middle\":\n      return (text) => clipMiddle(text, maxWidth, widthof, ellipsis);\n    case \"ellipsis-end\":\n      return (text) => clipEnd(text, maxWidth, widthof, ellipsis);\n  }\n}\n\nexport const ellipsis = \"…\";\n\n// Cuts the given text to the given width, using the specified widthof function;\n// the returned [index, error] guarantees text.slice(0, index) fits within the\n// specified width with the given error. If the text fits naturally within the\n// given width, returns [-1, 0]. If the text needs cutting, the given inset\n// specifies how much space (in the same units as width and widthof) to reserve\n// for a possible ellipsis character.\nexport function cut(text, width, widthof, inset) {\n  const I = []; // indexes of read character boundaries\n  let w = 0; // current line width\n  for (let i = 0, j = 0, n = text.length; i < n; i = j) {\n    j = readCharacter(text, i); // read the next character\n    const l = widthof(text, i, j); // current character width\n    if (w + l > width) {\n      w += inset;\n      while (w > width && i > 0) (j = i), (i = I.pop()), (w -= widthof(text, i, j)); // remove excess\n      return [i, width - w];\n    }\n    w += l;\n    I.push(i);\n  }\n  return [-1, 0];\n}\n\nexport function clipEnd(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const e = widthof(ellipsis);\n  const [i] = cut(text, width, widthof, e);\n  return i < 0 ? text : text.slice(0, i).trimEnd() + ellipsis;\n}\n\nexport function clipMiddle(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const w = widthof(text);\n  if (w <= width) return text;\n  const e = widthof(ellipsis) / 2;\n  const [i, ei] = cut(text, width / 2, widthof, e);\n  const [j] = cut(text, w - width / 2 - ei + e, widthof, -e); // TODO read spaces?\n  return j < 0 ? ellipsis : text.slice(0, i).trimEnd() + ellipsis + text.slice(readCharacter(text, j)).trimStart();\n}\n\nexport function clipStart(text, width, widthof, ellipsis) {\n  text = text.trim(); // ignore leading and trailing whitespace\n  const w = widthof(text);\n  if (w <= width) return text;\n  const e = widthof(ellipsis);\n  const [j] = cut(text, w - width + e, widthof, -e); // TODO read spaces?\n  return j < 0 ? ellipsis : ellipsis + text.slice(readCharacter(text, j)).trimStart();\n}\n\nconst reCombiner = /[\\p{Combining_Mark}\\p{Emoji_Modifier}]+/uy;\nconst rePictographic = /\\p{Extended_Pictographic}/uy;\n\n// Reads a single “character” element from the given text starting at the given\n// index, returning the index after the read character. Ideally, this implements\n// the Unicode text segmentation algorithm and understands grapheme cluster\n// boundaries, etc., but in practice this is only smart enough to detect UTF-16\n// surrogate pairs, combining marks, and zero-width joiner (zwj) sequences such\n// as emoji skin color modifiers. https://unicode.org/reports/tr29/\nexport function readCharacter(text, i) {\n  i += isSurrogatePair(text, i) ? 2 : 1;\n  if (isCombiner(text, i)) i = reCombiner.lastIndex;\n  if (isZeroWidthJoiner(text, i)) return readCharacter(text, i + 1);\n  return i;\n}\n\n// We avoid more expensive regex tests involving Unicode property classes by\n// first checking for the common case of 7-bit ASCII characters.\nfunction isAscii(text, i) {\n  return text.charCodeAt(i) < 0x80;\n}\n\nfunction isSurrogatePair(text, i) {\n  const hi = text.charCodeAt(i);\n  if (hi >= 0xd800 && hi < 0xdc00) {\n    const lo = text.charCodeAt(i + 1);\n    return lo >= 0xdc00 && lo < 0xe000;\n  }\n  return false;\n}\n\nfunction isZeroWidthJoiner(text, i) {\n  return text.charCodeAt(i) === 0x200d;\n}\n\nfunction isCombiner(text, i) {\n  return isAscii(text, i) ? false : ((reCombiner.lastIndex = i), reCombiner.test(text));\n}\n\nfunction isPictographic(text, i) {\n  return isAscii(text, i) ? false : ((rePictographic.lastIndex = i), rePictographic.test(text));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}