{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { map, number, valueof } from \"../options.js\";\nimport { applyPosition } from \"../projection.js\";\nimport { sqrt3 } from \"../symbol.js\";\nimport { initializer } from \"./basic.js\";\nimport { hasOutput, maybeGroup, maybeGroupOutputs, maybeSubgroup } from \"./group.js\";\n\n// We don’t want the hexagons to align with the edges of the plot frame, as that\n// would cause extreme x-values (the upper bound of the default x-scale domain)\n// to be rounded up into a floating bin to the right of the plot. Therefore,\n// rather than centering the origin hexagon around ⟨0,0⟩ in screen coordinates,\n// we offset slightly to ⟨0.5,0⟩. The hexgrid mark uses the same origin.\nexport const ox = 0.5,\n  oy = 0;\nexport function hexbin(outputs = {\n  fill: \"count\"\n}, {\n  binWidth,\n  ...options\n} = {}) {\n  const {\n    z\n  } = options;\n\n  // TODO filter e.g. to show empty hexbins?\n  binWidth = binWidth === undefined ? 20 : number(binWidth);\n  outputs = maybeGroupOutputs(outputs, options);\n\n  // A fill output means a fill channel; declaring the channel here instead of\n  // waiting for the initializer allows the mark constructor to determine that\n  // the stroke should default to none (assuming a mark that defaults to fill\n  // and no stroke, such as dot). Note that it’s safe to mutate options here\n  // because we just created it with the rest operator above.\n  if (hasOutput(outputs, \"fill\")) options.channels = {\n    ...options.channels,\n    fill: {\n      value: []\n    }\n  };\n\n  // Populate default values for the r and symbol options, as appropriate.\n  if (options.symbol === undefined) options.symbol = \"hexagon\";\n  if (options.r === undefined && !hasOutput(outputs, \"r\")) options.r = binWidth / 2;\n  return initializer(options, (data, facets, channels, scales, _, context) => {\n    let {\n      x: X,\n      y: Y,\n      z: Z,\n      fill: F,\n      stroke: S,\n      symbol: Q\n    } = channels;\n    if (X === undefined) throw new Error(\"missing channel: x\");\n    if (Y === undefined) throw new Error(\"missing channel: y\");\n\n    // Get the (either scaled or projected) xy channels.\n    ({\n      x: X,\n      y: Y\n    } = applyPosition(channels, scales, context));\n\n    // Extract the values for channels that are eligible for grouping; not all\n    // marks define a z channel, so compute one if it not already computed. If z\n    // was explicitly set to null, ensure that we don’t subdivide bins.\n    Z = Z ? Z.value : valueof(data, z);\n    F = F?.value;\n    S = S?.value;\n    Q = Q?.value;\n\n    // Group on the first of z, fill, stroke, and symbol. Implicitly reduce\n    // these channels using the first corresponding value for each bin.\n    const G = maybeSubgroup(outputs, {\n      z: Z,\n      fill: F,\n      stroke: S,\n      symbol: Q\n    });\n    const GZ = Z && [];\n    const GF = F && [];\n    const GS = S && [];\n    const GQ = Q && [];\n\n    // Construct the hexbins and populate the output channels.\n    const binFacets = [];\n    const BX = [];\n    const BY = [];\n    let i = -1;\n    for (const o of outputs) o.initialize(data);\n    for (const facet of facets) {\n      const binFacet = [];\n      for (const o of outputs) o.scope(\"facet\", facet);\n      for (const [f, I] of maybeGroup(facet, G)) {\n        for (const {\n          index: b,\n          extent\n        } of hbin(data, I, X, Y, binWidth)) {\n          binFacet.push(++i);\n          BX.push(extent.x);\n          BY.push(extent.y);\n          if (Z) GZ.push(G === Z ? f : Z[b[0]]);\n          if (F) GF.push(G === F ? f : F[b[0]]);\n          if (S) GS.push(G === S ? f : S[b[0]]);\n          if (Q) GQ.push(G === Q ? f : Q[b[0]]);\n          for (const o of outputs) o.reduce(b, extent);\n        }\n      }\n      binFacets.push(binFacet);\n    }\n\n    // Construct the output channels, and populate the radius scale hint.\n    const sx = channels.x.scale;\n    const sy = channels.y.scale;\n    const binChannels = {\n      x: {\n        value: BX,\n        source: scales[sx] ? {\n          value: map(BX, scales[sx].invert),\n          scale: sx\n        } : null\n      },\n      y: {\n        value: BY,\n        source: scales[sy] ? {\n          value: map(BY, scales[sy].invert),\n          scale: sy\n        } : null\n      },\n      ...(Z && {\n        z: {\n          value: GZ\n        }\n      }),\n      ...(F && {\n        fill: {\n          value: GF,\n          scale: \"auto\"\n        }\n      }),\n      ...(S && {\n        stroke: {\n          value: GS,\n          scale: \"auto\"\n        }\n      }),\n      ...(Q && {\n        symbol: {\n          value: GQ,\n          scale: \"auto\"\n        }\n      }),\n      ...Object.fromEntries(outputs.map(({\n        name,\n        output\n      }) => [name, {\n        scale: \"auto\",\n        label: output.label,\n        radius: name === \"r\" ? binWidth / 2 : undefined,\n        value: output.transform()\n      }]))\n    };\n    return {\n      data,\n      facets: binFacets,\n      channels: binChannels\n    };\n  });\n}\nfunction hbin(data, I, X, Y, dx) {\n  const dy = dx * (1.5 / sqrt3);\n  const bins = new Map();\n  for (const i of I) {\n    let px = X[i],\n      py = Y[i];\n    if (isNaN(px) || isNaN(py)) continue;\n    let pj = Math.round(py = (py - oy) / dy),\n      pi = Math.round(px = (px - ox) / dx - (pj & 1) / 2),\n      py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n      let px1 = px - pi,\n        pi2 = pi + (px < pi ? -1 : 1) / 2,\n        pj2 = pj + (py < pj ? -1 : 1),\n        px2 = px - pi2,\n        py2 = py - pj2;\n      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;\n    }\n    const key = `${pi},${pj}`;\n    let bin = bins.get(key);\n    if (bin === undefined) {\n      bin = {\n        index: [],\n        extent: {\n          data,\n          x: (pi + (pj & 1) / 2) * dx + ox,\n          y: pj * dy + oy\n        }\n      };\n      bins.set(key, bin);\n    }\n    bin.index.push(i);\n  }\n  return bins.values();\n}","map":{"version":3,"names":["map","number","valueof","applyPosition","sqrt3","initializer","hasOutput","maybeGroup","maybeGroupOutputs","maybeSubgroup","ox","oy","hexbin","outputs","fill","binWidth","options","z","undefined","channels","value","symbol","r","data","facets","scales","_","context","x","X","y","Y","Z","F","stroke","S","Q","Error","G","GZ","GF","GS","GQ","binFacets","BX","BY","i","o","initialize","facet","binFacet","scope","f","I","index","b","extent","hbin","push","reduce","sx","scale","sy","binChannels","source","invert","Object","fromEntries","name","output","label","radius","transform","dx","dy","bins","Map","px","py","isNaN","pj","Math","round","pi","py1","abs","px1","pi2","pj2","px2","py2","key","bin","get","set","values"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/hexbin.js"],"sourcesContent":["import {map, number, valueof} from \"../options.js\";\nimport {applyPosition} from \"../projection.js\";\nimport {sqrt3} from \"../symbol.js\";\nimport {initializer} from \"./basic.js\";\nimport {hasOutput, maybeGroup, maybeGroupOutputs, maybeSubgroup} from \"./group.js\";\n\n// We don’t want the hexagons to align with the edges of the plot frame, as that\n// would cause extreme x-values (the upper bound of the default x-scale domain)\n// to be rounded up into a floating bin to the right of the plot. Therefore,\n// rather than centering the origin hexagon around ⟨0,0⟩ in screen coordinates,\n// we offset slightly to ⟨0.5,0⟩. The hexgrid mark uses the same origin.\nexport const ox = 0.5,\n  oy = 0;\n\nexport function hexbin(outputs = {fill: \"count\"}, {binWidth, ...options} = {}) {\n  const {z} = options;\n\n  // TODO filter e.g. to show empty hexbins?\n  binWidth = binWidth === undefined ? 20 : number(binWidth);\n  outputs = maybeGroupOutputs(outputs, options);\n\n  // A fill output means a fill channel; declaring the channel here instead of\n  // waiting for the initializer allows the mark constructor to determine that\n  // the stroke should default to none (assuming a mark that defaults to fill\n  // and no stroke, such as dot). Note that it’s safe to mutate options here\n  // because we just created it with the rest operator above.\n  if (hasOutput(outputs, \"fill\")) options.channels = {...options.channels, fill: {value: []}};\n\n  // Populate default values for the r and symbol options, as appropriate.\n  if (options.symbol === undefined) options.symbol = \"hexagon\";\n  if (options.r === undefined && !hasOutput(outputs, \"r\")) options.r = binWidth / 2;\n\n  return initializer(options, (data, facets, channels, scales, _, context) => {\n    let {x: X, y: Y, z: Z, fill: F, stroke: S, symbol: Q} = channels;\n    if (X === undefined) throw new Error(\"missing channel: x\");\n    if (Y === undefined) throw new Error(\"missing channel: y\");\n\n    // Get the (either scaled or projected) xy channels.\n    ({x: X, y: Y} = applyPosition(channels, scales, context));\n\n    // Extract the values for channels that are eligible for grouping; not all\n    // marks define a z channel, so compute one if it not already computed. If z\n    // was explicitly set to null, ensure that we don’t subdivide bins.\n    Z = Z ? Z.value : valueof(data, z);\n    F = F?.value;\n    S = S?.value;\n    Q = Q?.value;\n\n    // Group on the first of z, fill, stroke, and symbol. Implicitly reduce\n    // these channels using the first corresponding value for each bin.\n    const G = maybeSubgroup(outputs, {z: Z, fill: F, stroke: S, symbol: Q});\n    const GZ = Z && [];\n    const GF = F && [];\n    const GS = S && [];\n    const GQ = Q && [];\n\n    // Construct the hexbins and populate the output channels.\n    const binFacets = [];\n    const BX = [];\n    const BY = [];\n    let i = -1;\n    for (const o of outputs) o.initialize(data);\n    for (const facet of facets) {\n      const binFacet = [];\n      for (const o of outputs) o.scope(\"facet\", facet);\n      for (const [f, I] of maybeGroup(facet, G)) {\n        for (const {index: b, extent} of hbin(data, I, X, Y, binWidth)) {\n          binFacet.push(++i);\n          BX.push(extent.x);\n          BY.push(extent.y);\n          if (Z) GZ.push(G === Z ? f : Z[b[0]]);\n          if (F) GF.push(G === F ? f : F[b[0]]);\n          if (S) GS.push(G === S ? f : S[b[0]]);\n          if (Q) GQ.push(G === Q ? f : Q[b[0]]);\n          for (const o of outputs) o.reduce(b, extent);\n        }\n      }\n      binFacets.push(binFacet);\n    }\n\n    // Construct the output channels, and populate the radius scale hint.\n    const sx = channels.x.scale;\n    const sy = channels.y.scale;\n    const binChannels = {\n      x: {value: BX, source: scales[sx] ? {value: map(BX, scales[sx].invert), scale: sx} : null},\n      y: {value: BY, source: scales[sy] ? {value: map(BY, scales[sy].invert), scale: sy} : null},\n      ...(Z && {z: {value: GZ}}),\n      ...(F && {fill: {value: GF, scale: \"auto\"}}),\n      ...(S && {stroke: {value: GS, scale: \"auto\"}}),\n      ...(Q && {symbol: {value: GQ, scale: \"auto\"}}),\n      ...Object.fromEntries(\n        outputs.map(({name, output}) => [\n          name,\n          {\n            scale: \"auto\",\n            label: output.label,\n            radius: name === \"r\" ? binWidth / 2 : undefined,\n            value: output.transform()\n          }\n        ])\n      )\n    };\n\n    return {data, facets: binFacets, channels: binChannels};\n  });\n}\n\nfunction hbin(data, I, X, Y, dx) {\n  const dy = dx * (1.5 / sqrt3);\n  const bins = new Map();\n  for (const i of I) {\n    let px = X[i],\n      py = Y[i];\n    if (isNaN(px) || isNaN(py)) continue;\n    let pj = Math.round((py = (py - oy) / dy)),\n      pi = Math.round((px = (px - ox) / dx - (pj & 1) / 2)),\n      py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n      let px1 = px - pi,\n        pi2 = pi + (px < pi ? -1 : 1) / 2,\n        pj2 = pj + (py < pj ? -1 : 1),\n        px2 = px - pi2,\n        py2 = py - pj2;\n      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) (pi = pi2 + (pj & 1 ? 1 : -1) / 2), (pj = pj2);\n    }\n    const key = `${pi},${pj}`;\n    let bin = bins.get(key);\n    if (bin === undefined) {\n      bin = {index: [], extent: {data, x: (pi + (pj & 1) / 2) * dx + ox, y: pj * dy + oy}};\n      bins.set(key, bin);\n    }\n    bin.index.push(i);\n  }\n  return bins.values();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}