{"ast":null,"code":"import { create } from \"../context.js\";\nimport { Mark } from \"../mark.js\";\nimport { constant, hasXY, identity, indexOf, number } from \"../options.js\";\nimport { isCollapsed } from \"../scales.js\";\nimport { applyAttr, applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform } from \"../style.js\";\nimport { impliedString } from \"../style.js\";\nimport { maybeIdentityX, maybeIdentityY } from \"../transforms/identity.js\";\nimport { maybeTrivialIntervalX, maybeTrivialIntervalY } from \"../transforms/interval.js\";\nimport { maybeStackX, maybeStackY } from \"../transforms/stack.js\";\nconst defaults = {\n  ariaLabel: \"rect\"\n};\nexport class Rect extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1,\n      y1,\n      x2,\n      y2\n    } = options;\n    super(data, {\n      x1: {\n        value: x1,\n        scale: \"x\",\n        type: x1 != null && x2 == null ? \"band\" : undefined,\n        optional: true\n      },\n      y1: {\n        value: y1,\n        scale: \"y\",\n        type: y1 != null && y2 == null ? \"band\" : undefined,\n        optional: true\n      },\n      x2: {\n        value: x2,\n        scale: \"x\",\n        optional: true\n      },\n      y2: {\n        value: y2,\n        scale: \"y\",\n        optional: true\n      }\n    }, options, defaults);\n    rectInsets(this, options);\n    rectRadii(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x,\n      y\n    } = scales;\n    let {\n      x1: X1,\n      y1: Y1,\n      x2: X2,\n      y2: Y2\n    } = channels;\n    const {\n      marginTop,\n      marginRight,\n      marginBottom,\n      marginLeft,\n      width,\n      height\n    } = dimensions;\n    const {\n      projection\n    } = context;\n    const {\n      insetTop,\n      insetRight,\n      insetBottom,\n      insetLeft\n    } = this;\n    const {\n      rx,\n      ry,\n      rx1y1,\n      rx1y2,\n      rx2y1,\n      rx2y2\n    } = this;\n    if ((X1 || X2) && !projection && isCollapsed(x)) X1 = X2 = null; // ignore if collapsed\n    if ((Y1 || Y2) && !projection && isCollapsed(y)) Y1 = Y2 = null; // ignore if collapsed\n    const bx = x?.bandwidth ? x.bandwidth() : 0;\n    const by = y?.bandwidth ? y.bandwidth() : 0;\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, 0, 0).call(g => g.selectAll().data(index).enter().call(rx1y1 || rx1y2 || rx2y1 || rx2y2 ? g => g.append(\"path\").call(applyDirectStyles, this).call(applyRoundedRect, X1 && X2 ? i => X1[i] + (X2[i] < X1[i] ? -insetRight : insetLeft) : X1 ? i => X1[i] + insetLeft : marginLeft + insetLeft, Y1 && Y2 ? i => Y1[i] + (Y2[i] < Y1[i] ? -insetBottom : insetTop) : Y1 ? i => Y1[i] + insetTop : marginTop + insetTop, X1 && X2 ? i => X2[i] - (X2[i] < X1[i] ? -insetLeft : insetRight) : X1 ? i => X1[i] + bx - insetRight : width - marginRight - insetRight, Y1 && Y2 ? i => Y2[i] - (Y2[i] < Y1[i] ? -insetTop : insetBottom) : Y1 ? i => Y1[i] + by - insetBottom : height - marginBottom - insetBottom, this).call(applyChannelStyles, this, channels) : g => g.append(\"rect\").call(applyDirectStyles, this).attr(\"x\", X1 ? X2 ? i => Math.min(X1[i], X2[i]) + insetLeft : i => X1[i] + insetLeft : marginLeft + insetLeft).attr(\"y\", Y1 ? Y2 ? i => Math.min(Y1[i], Y2[i]) + insetTop : i => Y1[i] + insetTop : marginTop + insetTop).attr(\"width\", X1 ? X2 ? i => Math.max(0, Math.abs(X2[i] - X1[i]) + bx - insetLeft - insetRight) : bx - insetLeft - insetRight : width - marginRight - marginLeft - insetRight - insetLeft).attr(\"height\", Y1 ? Y2 ? i => Math.max(0, Math.abs(Y1[i] - Y2[i]) + by - insetTop - insetBottom) : by - insetTop - insetBottom : height - marginTop - marginBottom - insetTop - insetBottom).call(applyAttr, \"rx\", rx).call(applyAttr, \"ry\", ry).call(applyChannelStyles, this, channels))).node();\n  }\n}\nexport function rectInsets(mark, {\n  inset = 0,\n  insetTop = inset,\n  insetRight = inset,\n  insetBottom = inset,\n  insetLeft = inset\n} = {}) {\n  mark.insetTop = number(insetTop);\n  mark.insetRight = number(insetRight);\n  mark.insetBottom = number(insetBottom);\n  mark.insetLeft = number(insetLeft);\n}\nexport function rectRadii(mark, {\n  r,\n  rx,\n  // for elliptic corners\n  ry,\n  // for elliptic corners\n  rx1 = r,\n  ry1 = r,\n  rx2 = r,\n  ry2 = r,\n  rx1y1 = rx1 !== undefined ? +rx1 : ry1 !== undefined ? +ry1 : 0,\n  rx1y2 = rx1 !== undefined ? +rx1 : ry2 !== undefined ? +ry2 : 0,\n  rx2y1 = rx2 !== undefined ? +rx2 : ry1 !== undefined ? +ry1 : 0,\n  rx2y2 = rx2 !== undefined ? +rx2 : ry2 !== undefined ? +ry2 : 0\n} = {}) {\n  if (rx1y1 || rx1y2 || rx2y1 || rx2y2) {\n    mark.rx1y1 = rx1y1;\n    mark.rx1y2 = rx1y2;\n    mark.rx2y1 = rx2y1;\n    mark.rx2y2 = rx2y2;\n  } else {\n    mark.rx = impliedString(rx, \"auto\"); // number or percentage\n    mark.ry = impliedString(ry, \"auto\");\n  }\n}\nexport function applyRoundedRect(selection, X1, Y1, X2, Y2, mark) {\n  const {\n    rx1y1: r11,\n    rx1y2: r12,\n    rx2y1: r21,\n    rx2y2: r22\n  } = mark;\n  if (typeof X1 !== \"function\") X1 = constant(X1);\n  if (typeof Y1 !== \"function\") Y1 = constant(Y1);\n  if (typeof X2 !== \"function\") X2 = constant(X2);\n  if (typeof Y2 !== \"function\") Y2 = constant(Y2);\n  const rx = Math.max(Math.abs(r11 + r21), Math.abs(r12 + r22));\n  const ry = Math.max(Math.abs(r11 + r12), Math.abs(r21 + r22));\n  selection.attr(\"d\", i => {\n    const x1 = X1(i);\n    const y1 = Y1(i);\n    const x2 = X2(i);\n    const y2 = Y2(i);\n    const ix = x1 > x2;\n    const iy = y1 > y2;\n    const l = ix ? x2 : x1;\n    const r = ix ? x1 : x2;\n    const t = iy ? y2 : y1;\n    const b = iy ? y1 : y2;\n    const k = Math.min(1, (r - l) / rx, (b - t) / ry);\n    const tl = k * (ix ? iy ? r22 : r21 : iy ? r12 : r11);\n    const tr = k * (ix ? iy ? r12 : r11 : iy ? r22 : r21);\n    const br = k * (ix ? iy ? r11 : r12 : iy ? r21 : r22);\n    const bl = k * (ix ? iy ? r21 : r22 : iy ? r11 : r12);\n    return `M${l},${t + biasY(tl, bl)}A${tl},${tl} 0 0 ${tl < 0 ? 0 : 1} ${l + biasX(tl, bl)},${t}` + `H${r - biasX(tr, br)}A${tr},${tr} 0 0 ${tr < 0 ? 0 : 1} ${r},${t + biasY(tr, br)}` + `V${b - biasY(br, tr)}A${br},${br} 0 0 ${br < 0 ? 0 : 1} ${r - biasX(br, tr)},${b}` + `H${l + biasX(bl, tl)}A${bl},${bl} 0 0 ${bl < 0 ? 0 : 1} ${l},${b - biasY(bl, tl)}` + `Z`;\n  });\n}\n\n/**\n * If the opposing corner has a negative radius r2, if this corner has a\n * negative radius r1, this corner’s “wing” will extend horizontally rather than\n * vertically.\n */\nfunction biasX(r1, r2) {\n  return r2 < 0 ? r1 : Math.abs(r1);\n}\n\n/**\n * If the opposing corner has a negative radius r2, if this corner has a\n * negative radius r1, this corner’s “wing” will extend horizontally rather than\n * vertically.\n */\nfunction biasY(r1, r2) {\n  return r2 < 0 ? Math.abs(r1) : r1;\n}\nexport function rect(data, options) {\n  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));\n}\nexport function rectX(data, options = {}) {\n  if (!hasXY(options)) options = {\n    ...options,\n    y: indexOf,\n    x2: identity,\n    interval: 1\n  };\n  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));\n}\nexport function rectY(data, options = {}) {\n  if (!hasXY(options)) options = {\n    ...options,\n    x: indexOf,\n    y2: identity,\n    interval: 1\n  };\n  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));\n}","map":{"version":3,"names":["create","Mark","constant","hasXY","identity","indexOf","number","isCollapsed","applyAttr","applyChannelStyles","applyDirectStyles","applyIndirectStyles","applyTransform","impliedString","maybeIdentityX","maybeIdentityY","maybeTrivialIntervalX","maybeTrivialIntervalY","maybeStackX","maybeStackY","defaults","ariaLabel","Rect","constructor","data","options","x1","y1","x2","y2","value","scale","type","undefined","optional","rectInsets","rectRadii","render","index","scales","channels","dimensions","context","x","y","X1","Y1","X2","Y2","marginTop","marginRight","marginBottom","marginLeft","width","height","projection","insetTop","insetRight","insetBottom","insetLeft","rx","ry","rx1y1","rx1y2","rx2y1","rx2y2","bx","bandwidth","by","call","g","selectAll","enter","append","applyRoundedRect","i","attr","Math","min","max","abs","node","mark","inset","r","rx1","ry1","rx2","ry2","selection","r11","r12","r21","r22","ix","iy","l","t","b","k","tl","tr","br","bl","biasY","biasX","r1","r2","rect","rectX","interval","rectY"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/rect.js"],"sourcesContent":["import {create} from \"../context.js\";\nimport {Mark} from \"../mark.js\";\nimport {constant, hasXY, identity, indexOf, number} from \"../options.js\";\nimport {isCollapsed} from \"../scales.js\";\nimport {applyAttr, applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform} from \"../style.js\";\nimport {impliedString} from \"../style.js\";\nimport {maybeIdentityX, maybeIdentityY} from \"../transforms/identity.js\";\nimport {maybeTrivialIntervalX, maybeTrivialIntervalY} from \"../transforms/interval.js\";\nimport {maybeStackX, maybeStackY} from \"../transforms/stack.js\";\n\nconst defaults = {\n  ariaLabel: \"rect\"\n};\n\nexport class Rect extends Mark {\n  constructor(data, options = {}) {\n    const {x1, y1, x2, y2} = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\", type: x1 != null && x2 == null ? \"band\" : undefined, optional: true},\n        y1: {value: y1, scale: \"y\", type: y1 != null && y2 == null ? \"band\" : undefined, optional: true},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true}\n      },\n      options,\n      defaults\n    );\n    rectInsets(this, options);\n    rectRadii(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    let {x1: X1, y1: Y1, x2: X2, y2: Y2} = channels;\n    const {marginTop, marginRight, marginBottom, marginLeft, width, height} = dimensions;\n    const {projection} = context;\n    const {insetTop, insetRight, insetBottom, insetLeft} = this;\n    const {rx, ry, rx1y1, rx1y2, rx2y1, rx2y2} = this;\n    if ((X1 || X2) && !projection && isCollapsed(x)) X1 = X2 = null; // ignore if collapsed\n    if ((Y1 || Y2) && !projection && isCollapsed(y)) Y1 = Y2 = null; // ignore if collapsed\n    const bx = x?.bandwidth ? x.bandwidth() : 0;\n    const by = y?.bandwidth ? y.bandwidth() : 0;\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {}, 0, 0)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .call(\n            rx1y1 || rx1y2 || rx2y1 || rx2y2\n              ? (g) =>\n                  g\n                    .append(\"path\")\n                    .call(applyDirectStyles, this)\n                    .call(\n                      applyRoundedRect,\n                      X1 && X2\n                        ? (i) => X1[i] + (X2[i] < X1[i] ? -insetRight : insetLeft)\n                        : X1\n                        ? (i) => X1[i] + insetLeft\n                        : marginLeft + insetLeft,\n                      Y1 && Y2\n                        ? (i) => Y1[i] + (Y2[i] < Y1[i] ? -insetBottom : insetTop)\n                        : Y1\n                        ? (i) => Y1[i] + insetTop\n                        : marginTop + insetTop,\n                      X1 && X2\n                        ? (i) => X2[i] - (X2[i] < X1[i] ? -insetLeft : insetRight)\n                        : X1\n                        ? (i) => X1[i] + bx - insetRight\n                        : width - marginRight - insetRight,\n                      Y1 && Y2\n                        ? (i) => Y2[i] - (Y2[i] < Y1[i] ? -insetTop : insetBottom)\n                        : Y1\n                        ? (i) => Y1[i] + by - insetBottom\n                        : height - marginBottom - insetBottom,\n                      this\n                    )\n                    .call(applyChannelStyles, this, channels)\n              : (g) =>\n                  g\n                    .append(\"rect\")\n                    .call(applyDirectStyles, this)\n                    .attr(\n                      \"x\",\n                      X1\n                        ? X2\n                          ? (i) => Math.min(X1[i], X2[i]) + insetLeft\n                          : (i) => X1[i] + insetLeft\n                        : marginLeft + insetLeft\n                    )\n                    .attr(\n                      \"y\",\n                      Y1\n                        ? Y2\n                          ? (i) => Math.min(Y1[i], Y2[i]) + insetTop\n                          : (i) => Y1[i] + insetTop\n                        : marginTop + insetTop\n                    )\n                    .attr(\n                      \"width\",\n                      X1\n                        ? X2\n                          ? (i) => Math.max(0, Math.abs(X2[i] - X1[i]) + bx - insetLeft - insetRight)\n                          : bx - insetLeft - insetRight\n                        : width - marginRight - marginLeft - insetRight - insetLeft\n                    )\n                    .attr(\n                      \"height\",\n                      Y1\n                        ? Y2\n                          ? (i) => Math.max(0, Math.abs(Y1[i] - Y2[i]) + by - insetTop - insetBottom)\n                          : by - insetTop - insetBottom\n                        : height - marginTop - marginBottom - insetTop - insetBottom\n                    )\n                    .call(applyAttr, \"rx\", rx)\n                    .call(applyAttr, \"ry\", ry)\n                    .call(applyChannelStyles, this, channels)\n          )\n      )\n      .node();\n  }\n}\n\nexport function rectInsets(\n  mark,\n  {inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset} = {}\n) {\n  mark.insetTop = number(insetTop);\n  mark.insetRight = number(insetRight);\n  mark.insetBottom = number(insetBottom);\n  mark.insetLeft = number(insetLeft);\n}\n\nexport function rectRadii(\n  mark,\n  {\n    r,\n    rx, // for elliptic corners\n    ry, // for elliptic corners\n    rx1 = r,\n    ry1 = r,\n    rx2 = r,\n    ry2 = r,\n    rx1y1 = rx1 !== undefined ? +rx1 : ry1 !== undefined ? +ry1 : 0,\n    rx1y2 = rx1 !== undefined ? +rx1 : ry2 !== undefined ? +ry2 : 0,\n    rx2y1 = rx2 !== undefined ? +rx2 : ry1 !== undefined ? +ry1 : 0,\n    rx2y2 = rx2 !== undefined ? +rx2 : ry2 !== undefined ? +ry2 : 0\n  } = {}\n) {\n  if (rx1y1 || rx1y2 || rx2y1 || rx2y2) {\n    mark.rx1y1 = rx1y1;\n    mark.rx1y2 = rx1y2;\n    mark.rx2y1 = rx2y1;\n    mark.rx2y2 = rx2y2;\n  } else {\n    mark.rx = impliedString(rx, \"auto\"); // number or percentage\n    mark.ry = impliedString(ry, \"auto\");\n  }\n}\n\nexport function applyRoundedRect(selection, X1, Y1, X2, Y2, mark) {\n  const {rx1y1: r11, rx1y2: r12, rx2y1: r21, rx2y2: r22} = mark;\n  if (typeof X1 !== \"function\") X1 = constant(X1);\n  if (typeof Y1 !== \"function\") Y1 = constant(Y1);\n  if (typeof X2 !== \"function\") X2 = constant(X2);\n  if (typeof Y2 !== \"function\") Y2 = constant(Y2);\n  const rx = Math.max(Math.abs(r11 + r21), Math.abs(r12 + r22));\n  const ry = Math.max(Math.abs(r11 + r12), Math.abs(r21 + r22));\n  selection.attr(\"d\", (i) => {\n    const x1 = X1(i);\n    const y1 = Y1(i);\n    const x2 = X2(i);\n    const y2 = Y2(i);\n    const ix = x1 > x2;\n    const iy = y1 > y2;\n    const l = ix ? x2 : x1;\n    const r = ix ? x1 : x2;\n    const t = iy ? y2 : y1;\n    const b = iy ? y1 : y2;\n    const k = Math.min(1, (r - l) / rx, (b - t) / ry);\n    const tl = k * (ix ? (iy ? r22 : r21) : iy ? r12 : r11);\n    const tr = k * (ix ? (iy ? r12 : r11) : iy ? r22 : r21);\n    const br = k * (ix ? (iy ? r11 : r12) : iy ? r21 : r22);\n    const bl = k * (ix ? (iy ? r21 : r22) : iy ? r11 : r12);\n    return (\n      `M${l},${t + biasY(tl, bl)}A${tl},${tl} 0 0 ${tl < 0 ? 0 : 1} ${l + biasX(tl, bl)},${t}` +\n      `H${r - biasX(tr, br)}A${tr},${tr} 0 0 ${tr < 0 ? 0 : 1} ${r},${t + biasY(tr, br)}` +\n      `V${b - biasY(br, tr)}A${br},${br} 0 0 ${br < 0 ? 0 : 1} ${r - biasX(br, tr)},${b}` +\n      `H${l + biasX(bl, tl)}A${bl},${bl} 0 0 ${bl < 0 ? 0 : 1} ${l},${b - biasY(bl, tl)}` +\n      `Z`\n    );\n  });\n}\n\n/**\n * If the opposing corner has a negative radius r2, if this corner has a\n * negative radius r1, this corner’s “wing” will extend horizontally rather than\n * vertically.\n */\nfunction biasX(r1, r2) {\n  return r2 < 0 ? r1 : Math.abs(r1);\n}\n\n/**\n * If the opposing corner has a negative radius r2, if this corner has a\n * negative radius r1, this corner’s “wing” will extend horizontally rather than\n * vertically.\n */\nfunction biasY(r1, r2) {\n  return r2 < 0 ? Math.abs(r1) : r1;\n}\n\nexport function rect(data, options) {\n  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));\n}\n\nexport function rectX(data, options = {}) {\n  if (!hasXY(options)) options = {...options, y: indexOf, x2: identity, interval: 1};\n  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));\n}\n\nexport function rectY(data, options = {}) {\n  if (!hasXY(options)) options = {...options, x: indexOf, y2: identity, interval: 1};\n  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}