{"ast":null,"code":"import { randomLcg } from \"d3\";\nimport { ascendingDefined, descendingDefined } from \"../defined.js\";\nimport { isArray, isDomainSort, isOptions } from \"../options.js\";\nimport { dataify, maybeValue, valueof } from \"../options.js\";\nexport function basic({\n  filter: f1,\n  sort: s1,\n  reverse: r1,\n  transform: t1,\n  initializer: i1,\n  ...options\n} = {}, transform) {\n  // If both t1 and t2 are defined, returns a composite transform that first\n  // applies t1 and then applies t2.\n  if (t1 === undefined) {\n    // explicit transform overrides filter, sort, and reverse\n    if (f1 != null) t1 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1)) t1 = composeTransform(t1, sortTransform(s1));\n    if (r1) t1 = composeTransform(t1, reverseTransform);\n  }\n  if (transform != null && i1 != null) throw new Error(\"transforms cannot be applied after initializers\");\n  return {\n    ...options,\n    ...((s1 === null || isDomainSort(s1)) && {\n      sort: s1\n    }),\n    transform: composeTransform(t1, transform)\n  };\n}\nexport function initializer({\n  filter: f1,\n  sort: s1,\n  reverse: r1,\n  initializer: i1,\n  ...options\n} = {}, initializer) {\n  // If both i1 and i2 are defined, returns a composite initializer that first\n  // applies i1 and then applies i2.\n  if (i1 === undefined) {\n    // explicit initializer overrides filter, sort, and reverse\n    if (f1 != null) i1 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1)) i1 = composeInitializer(i1, sortTransform(s1));\n    if (r1) i1 = composeInitializer(i1, reverseTransform);\n  }\n  return {\n    ...options,\n    ...((s1 === null || isDomainSort(s1)) && {\n      sort: s1\n    }),\n    initializer: composeInitializer(i1, initializer)\n  };\n}\nfunction composeTransform(t1, t2) {\n  if (t1 == null) return t2 === null ? undefined : t2;\n  if (t2 == null) return t1 === null ? undefined : t1;\n  return function (data, facets, plotOptions) {\n    ({\n      data,\n      facets\n    } = t1.call(this, data, facets, plotOptions));\n    return t2.call(this, dataify(data), facets, plotOptions);\n  };\n}\nfunction composeInitializer(i1, i2) {\n  if (i1 == null) return i2 === null ? undefined : i2;\n  if (i2 == null) return i1 === null ? undefined : i1;\n  return function (data, facets, channels, ...args) {\n    let c1, d1, f1, c2, d2, f2;\n    ({\n      data: d1 = data,\n      facets: f1 = facets,\n      channels: c1\n    } = i1.call(this, data, facets, channels, ...args));\n    ({\n      data: d2 = d1,\n      facets: f2 = f1,\n      channels: c2\n    } = i2.call(this, d1, f1, {\n      ...channels,\n      ...c1\n    }, ...args));\n    return {\n      data: d2,\n      facets: f2,\n      channels: {\n        ...c1,\n        ...c2\n      }\n    };\n  };\n}\nfunction apply(options, t) {\n  return (options.initializer != null ? initializer : basic)(options, t);\n}\nexport function filter(test, options) {\n  return apply(options, filterTransform(test));\n}\nfunction filterTransform(value) {\n  return (data, facets) => {\n    const V = valueof(data, value);\n    return {\n      data,\n      facets: facets.map(I => I.filter(i => V[i]))\n    };\n  };\n}\nexport function reverse({\n  sort,\n  ...options\n} = {}) {\n  return {\n    ...apply(options, reverseTransform),\n    sort: isDomainSort(sort) ? sort : null\n  };\n}\nfunction reverseTransform(data, facets) {\n  return {\n    data,\n    facets: facets.map(I => I.slice().reverse())\n  };\n}\nexport function shuffle({\n  seed,\n  sort,\n  ...options\n} = {}) {\n  return {\n    ...apply(options, sortValue(seed == null ? Math.random : randomLcg(seed))),\n    sort: isDomainSort(sort) ? sort : null\n  };\n}\nexport function sort(order, {\n  sort,\n  ...options\n} = {}) {\n  return {\n    ...(isOptions(order) && order.channel !== undefined ? initializer : apply)(options, sortTransform(order)),\n    sort: isDomainSort(sort) ? sort : null\n  };\n}\nfunction sortTransform(value) {\n  return (typeof value === \"function\" && value.length !== 1 ? sortData : sortValue)(value);\n}\nfunction sortData(compare) {\n  return (data, facets) => {\n    const compareData = isArray(data) ? (i, j) => compare(data[i], data[j]) : (i, j) => compare(data.get(i), data.get(j));\n    return {\n      data,\n      facets: facets.map(I => I.slice().sort(compareData))\n    };\n  };\n}\nfunction sortValue(value) {\n  let channel, order;\n  ({\n    channel,\n    value,\n    order\n  } = {\n    ...maybeValue(value)\n  });\n  const negate = channel?.startsWith(\"-\");\n  if (negate) channel = channel.slice(1);\n  if (order === undefined) order = negate ? descendingDefined : ascendingDefined;\n  if (typeof order !== \"function\") {\n    switch (`${order}`.toLowerCase()) {\n      case \"ascending\":\n        order = ascendingDefined;\n        break;\n      case \"descending\":\n        order = descendingDefined;\n        break;\n      default:\n        throw new Error(`invalid order: ${order}`);\n    }\n  }\n  return (data, facets, channels) => {\n    let V;\n    if (channel === undefined) {\n      V = valueof(data, value);\n    } else {\n      if (channels === undefined) throw new Error(\"channel sort requires an initializer\");\n      V = channels[channel];\n      if (!V) return {}; // ignore missing channel\n      V = V.value;\n    }\n    const compareValue = (i, j) => order(V[i], V[j]);\n    return {\n      data,\n      facets: facets.map(I => I.slice().sort(compareValue))\n    };\n  };\n}","map":{"version":3,"names":["randomLcg","ascendingDefined","descendingDefined","isArray","isDomainSort","isOptions","dataify","maybeValue","valueof","basic","filter","f1","sort","s1","reverse","r1","transform","t1","initializer","i1","options","undefined","filterTransform","composeTransform","sortTransform","reverseTransform","Error","composeInitializer","t2","data","facets","plotOptions","call","i2","channels","args","c1","d1","c2","d2","f2","apply","t","test","value","V","map","I","i","slice","shuffle","seed","sortValue","Math","random","order","channel","length","sortData","compare","compareData","j","get","negate","startsWith","toLowerCase","compareValue"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/basic.js"],"sourcesContent":["import {randomLcg} from \"d3\";\nimport {ascendingDefined, descendingDefined} from \"../defined.js\";\nimport {isArray, isDomainSort, isOptions} from \"../options.js\";\nimport {dataify, maybeValue, valueof} from \"../options.js\";\n\nexport function basic({filter: f1, sort: s1, reverse: r1, transform: t1, initializer: i1, ...options} = {}, transform) {\n  // If both t1 and t2 are defined, returns a composite transform that first\n  // applies t1 and then applies t2.\n  if (t1 === undefined) {\n    // explicit transform overrides filter, sort, and reverse\n    if (f1 != null) t1 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1)) t1 = composeTransform(t1, sortTransform(s1));\n    if (r1) t1 = composeTransform(t1, reverseTransform);\n  }\n  if (transform != null && i1 != null) throw new Error(\"transforms cannot be applied after initializers\");\n  return {\n    ...options,\n    ...((s1 === null || isDomainSort(s1)) && {sort: s1}),\n    transform: composeTransform(t1, transform)\n  };\n}\n\nexport function initializer({filter: f1, sort: s1, reverse: r1, initializer: i1, ...options} = {}, initializer) {\n  // If both i1 and i2 are defined, returns a composite initializer that first\n  // applies i1 and then applies i2.\n  if (i1 === undefined) {\n    // explicit initializer overrides filter, sort, and reverse\n    if (f1 != null) i1 = filterTransform(f1);\n    if (s1 != null && !isDomainSort(s1)) i1 = composeInitializer(i1, sortTransform(s1));\n    if (r1) i1 = composeInitializer(i1, reverseTransform);\n  }\n  return {\n    ...options,\n    ...((s1 === null || isDomainSort(s1)) && {sort: s1}),\n    initializer: composeInitializer(i1, initializer)\n  };\n}\n\nfunction composeTransform(t1, t2) {\n  if (t1 == null) return t2 === null ? undefined : t2;\n  if (t2 == null) return t1 === null ? undefined : t1;\n  return function (data, facets, plotOptions) {\n    ({data, facets} = t1.call(this, data, facets, plotOptions));\n    return t2.call(this, dataify(data), facets, plotOptions);\n  };\n}\n\nfunction composeInitializer(i1, i2) {\n  if (i1 == null) return i2 === null ? undefined : i2;\n  if (i2 == null) return i1 === null ? undefined : i1;\n  return function (data, facets, channels, ...args) {\n    let c1, d1, f1, c2, d2, f2;\n    ({data: d1 = data, facets: f1 = facets, channels: c1} = i1.call(this, data, facets, channels, ...args));\n    ({data: d2 = d1, facets: f2 = f1, channels: c2} = i2.call(this, d1, f1, {...channels, ...c1}, ...args));\n    return {data: d2, facets: f2, channels: {...c1, ...c2}};\n  };\n}\n\nfunction apply(options, t) {\n  return (options.initializer != null ? initializer : basic)(options, t);\n}\n\nexport function filter(test, options) {\n  return apply(options, filterTransform(test));\n}\n\nfunction filterTransform(value) {\n  return (data, facets) => {\n    const V = valueof(data, value);\n    return {data, facets: facets.map((I) => I.filter((i) => V[i]))};\n  };\n}\n\nexport function reverse({sort, ...options} = {}) {\n  return {\n    ...apply(options, reverseTransform),\n    sort: isDomainSort(sort) ? sort : null\n  };\n}\n\nfunction reverseTransform(data, facets) {\n  return {data, facets: facets.map((I) => I.slice().reverse())};\n}\n\nexport function shuffle({seed, sort, ...options} = {}) {\n  return {\n    ...apply(options, sortValue(seed == null ? Math.random : randomLcg(seed))),\n    sort: isDomainSort(sort) ? sort : null\n  };\n}\n\nexport function sort(order, {sort, ...options} = {}) {\n  return {\n    ...(isOptions(order) && order.channel !== undefined ? initializer : apply)(options, sortTransform(order)),\n    sort: isDomainSort(sort) ? sort : null\n  };\n}\n\nfunction sortTransform(value) {\n  return (typeof value === \"function\" && value.length !== 1 ? sortData : sortValue)(value);\n}\n\nfunction sortData(compare) {\n  return (data, facets) => {\n    const compareData = isArray(data)\n      ? (i, j) => compare(data[i], data[j])\n      : (i, j) => compare(data.get(i), data.get(j));\n    return {data, facets: facets.map((I) => I.slice().sort(compareData))};\n  };\n}\n\nfunction sortValue(value) {\n  let channel, order;\n  ({channel, value, order} = {...maybeValue(value)});\n  const negate = channel?.startsWith(\"-\");\n  if (negate) channel = channel.slice(1);\n  if (order === undefined) order = negate ? descendingDefined : ascendingDefined;\n  if (typeof order !== \"function\") {\n    switch (`${order}`.toLowerCase()) {\n      case \"ascending\":\n        order = ascendingDefined;\n        break;\n      case \"descending\":\n        order = descendingDefined;\n        break;\n      default:\n        throw new Error(`invalid order: ${order}`);\n    }\n  }\n  return (data, facets, channels) => {\n    let V;\n    if (channel === undefined) {\n      V = valueof(data, value);\n    } else {\n      if (channels === undefined) throw new Error(\"channel sort requires an initializer\");\n      V = channels[channel];\n      if (!V) return {}; // ignore missing channel\n      V = V.value;\n    }\n    const compareValue = (i, j) => order(V[i], V[j]);\n    return {data, facets: facets.map((I) => I.slice().sort(compareValue))};\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}