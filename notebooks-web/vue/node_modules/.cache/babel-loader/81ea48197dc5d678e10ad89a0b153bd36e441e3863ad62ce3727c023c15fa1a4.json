{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { bisect, extent, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, tickIncrement, ticks, utcTickInterval } from \"d3\";\nimport { withTip } from \"../mark.js\";\nimport { coerceDate, coerceNumbers, identity, isInterval, isIterable, isTemporal, isTimeInterval, labelof, map, maybeApplyInterval, maybeColorChannel, maybeColumn, maybeRangeInterval, maybeTuple, maybeValue, mid, valueof } from \"../options.js\";\nimport { utcInterval } from \"../time.js\";\nimport { basic } from \"./basic.js\";\nimport { hasOutput, maybeEvaluator, maybeGroup, maybeOutput, maybeOutputs, maybeReduce, maybeSort, maybeSubgroup, reduceCount, reduceFirst, reduceIdentity, reduceZ } from \"./group.js\";\nimport { maybeInsetX, maybeInsetY } from \"./inset.js\";\n\n// Group on {z, fill, stroke}, then optionally on y, then bin x.\nexport function binX(outputs = {\n  y: \"count\"\n}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {\n    x,\n    y\n  } = options;\n  return binn(maybeBinValue(x, options, identity), null, null, y, outputs, maybeInsetX(options));\n}\n\n// Group on {z, fill, stroke}, then optionally on x, then bin y.\nexport function binY(outputs = {\n  x: \"count\"\n}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {\n    x,\n    y\n  } = options;\n  return binn(null, maybeBinValue(y, options, identity), x, null, outputs, maybeInsetY(options));\n}\n\n// Group on {z, fill, stroke}, then bin on x and y.\nexport function bin(outputs = {\n  fill: \"count\"\n}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {\n    x,\n    y\n  } = maybeBinValueTuple(options);\n  return binn(x, y, null, null, outputs, maybeInsetX(maybeInsetY(options)));\n}\nfunction maybeDenseInterval(bin, k, options = {}) {\n  if (options?.interval == null) return options;\n  const {\n    reduce = reduceFirst\n  } = options;\n  const outputs = {\n    filter: null\n  };\n  if (options[k] != null) outputs[k] = reduce;\n  if (options[`${k}1`] != null) outputs[`${k}1`] = reduce;\n  if (options[`${k}2`] != null) outputs[`${k}2`] = reduce;\n  return bin(outputs, options);\n}\nexport function maybeDenseIntervalX(options = {}) {\n  return maybeDenseInterval(binX, \"y\", withTip(options, \"x\"));\n}\nexport function maybeDenseIntervalY(options = {}) {\n  return maybeDenseInterval(binY, \"x\", withTip(options, \"y\"));\n}\nfunction binn(bx,\n// optionally bin on x (exclusive with gx)\nby,\n// optionally bin on y (exclusive with gy)\ngx,\n// optionally group on x (exclusive with bx and gy)\ngy,\n// optionally group on y (exclusive with by and gx)\n{\n  data: reduceData = reduceIdentity,\n  // TODO avoid materializing when unused?\n  filter = reduceCount,\n  // return only non-empty bins by default\n  sort,\n  reverse,\n  ...outputs // output channel definitions\n} = {}, inputs = {} // input channels and options\n) {\n  bx = maybeBin(bx);\n  by = maybeBin(by);\n\n  // Compute the outputs.\n  outputs = maybeBinOutputs(outputs, inputs);\n  reduceData = maybeBinReduce(reduceData, identity);\n  sort = sort == null ? undefined : maybeBinOutput(\"sort\", sort, inputs);\n  filter = filter == null ? undefined : maybeBinEvaluator(\"filter\", filter, inputs);\n\n  // Donâ€™t group on a channel if an output requires it as an input!\n  if (gx != null && hasOutput(outputs, \"x\", \"x1\", \"x2\")) gx = null;\n  if (gy != null && hasOutput(outputs, \"y\", \"y1\", \"y2\")) gy = null;\n\n  // Produce x1, x2, y1, and y2 output channels as appropriate (when binning).\n  const [BX1, setBX1] = maybeColumn(bx);\n  const [BX2, setBX2] = maybeColumn(bx);\n  const [BY1, setBY1] = maybeColumn(by);\n  const [BY2, setBY2] = maybeColumn(by);\n\n  // Produce x or y output channels as appropriate (when grouping).\n  const [k, gk] = gx != null ? [gx, \"x\"] : gy != null ? [gy, \"y\"] : [];\n  const [GK, setGK] = maybeColumn(k);\n\n  // Greedily materialize the z, fill, and stroke channels (if channels and not\n  // constants) so that we can reference them for subdividing groups without\n  // computing them more than once. We also want to consume options that should\n  // only apply to this transform rather than passing them through to the next.\n  const {\n    x,\n    y,\n    z,\n    fill,\n    stroke,\n    x1,\n    x2,\n    // consumed if x is an output\n    y1,\n    y2,\n    // consumed if y is an output\n    domain,\n    cumulative,\n    thresholds,\n    interval,\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...(\"z\" in inputs && {\n      z: GZ || z\n    }),\n    ...(\"fill\" in inputs && {\n      fill: GF || fill\n    }),\n    ...(\"stroke\" in inputs && {\n      stroke: GS || stroke\n    }),\n    ...basic(options, (data, facets, plotOptions) => {\n      const K = maybeApplyInterval(valueof(data, k), plotOptions?.[gk]);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, {\n        z: Z,\n        fill: F,\n        stroke: S\n      });\n      const groupFacets = [];\n      const groupData = [];\n      const GK = K && setGK([]);\n      const GZ = Z && setGZ([]);\n      const GF = F && setGF([]);\n      const GS = S && setGS([]);\n      const BX1 = bx && setBX1([]);\n      const BX2 = bx && setBX2([]);\n      const BY1 = by && setBY1([]);\n      const BY2 = by && setBY2([]);\n      const bin = bing(bx, by, data);\n      let i = 0;\n      for (const o of outputs) o.initialize(data);\n      if (sort) sort.initialize(data);\n      if (filter) filter.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs) o.scope(\"facet\", facet);\n        if (sort) sort.scope(\"facet\", facet);\n        if (filter) filter.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [k, g] of maybeGroup(I, K)) {\n            for (const [b, extent] of bin(g)) {\n              if (G) extent.z = f;\n              if (filter && !filter.reduce(b, extent)) continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduceIndex(b, data, extent));\n              if (K) GK.push(k);\n              if (Z) GZ.push(G === Z ? f : Z[(b.length > 0 ? b : g)[0]]);\n              if (F) GF.push(G === F ? f : F[(b.length > 0 ? b : g)[0]]);\n              if (S) GS.push(G === S ? f : S[(b.length > 0 ? b : g)[0]]);\n              if (BX1) BX1.push(extent.x1), BX2.push(extent.x2);\n              if (BY1) BY1.push(extent.y1), BY2.push(extent.y2);\n              for (const o of outputs) o.reduce(b, extent);\n              if (sort) sort.reduce(b, extent);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort, reverse);\n      return {\n        data: groupData,\n        facets: groupFacets\n      };\n    }),\n    ...(!hasOutput(outputs, \"x\") && (BX1 ? {\n      x1: BX1,\n      x2: BX2,\n      x: mid(BX1, BX2)\n    } : {\n      x,\n      x1,\n      x2\n    })),\n    ...(!hasOutput(outputs, \"y\") && (BY1 ? {\n      y1: BY1,\n      y2: BY2,\n      y: mid(BY1, BY2)\n    } : {\n      y,\n      y1,\n      y2\n    })),\n    ...(GK && {\n      [gk]: GK\n    }),\n    ...Object.fromEntries(outputs.map(({\n      name,\n      output\n    }) => [name, output]))\n  };\n}\n\n// Allow bin options to be specified as part of outputs; merge them into options.\nfunction mergeOptions({\n  cumulative,\n  domain,\n  thresholds,\n  interval,\n  ...outputs\n}, options) {\n  return [outputs, {\n    cumulative,\n    domain,\n    thresholds,\n    interval,\n    ...options\n  }];\n}\nfunction maybeBinValue(value, {\n  cumulative,\n  domain,\n  thresholds,\n  interval\n}, defaultValue) {\n  value = {\n    ...maybeValue(value)\n  };\n  if (value.domain === undefined) value.domain = domain;\n  if (value.cumulative === undefined) value.cumulative = cumulative;\n  if (value.thresholds === undefined) value.thresholds = thresholds;\n  if (value.interval === undefined) value.interval = interval;\n  if (value.value === undefined) value.value = defaultValue;\n  value.thresholds = maybeThresholds(value.thresholds, value.interval);\n  return value;\n}\nfunction maybeBinValueTuple(options) {\n  let {\n    x,\n    y\n  } = options;\n  x = maybeBinValue(x, options);\n  y = maybeBinValue(y, options);\n  [x.value, y.value] = maybeTuple(x.value, y.value);\n  return {\n    x,\n    y\n  };\n}\nfunction maybeBin(options) {\n  if (options == null) return;\n  const {\n    value,\n    cumulative,\n    domain = extent,\n    thresholds\n  } = options;\n  const bin = data => {\n    let V = valueof(data, value);\n    let T; // bin thresholds\n    if (isTemporal(V) || isTimeThresholds(thresholds)) {\n      V = map(V, coerceDate, Float64Array); // like coerceDates, but faster\n      let [min, max] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min, max) : thresholds;\n      if (typeof t === \"number\") t = utcTickInterval(min, max, t);\n      if (isInterval(t)) {\n        if (domain === extent) {\n          min = t.floor(min);\n          max = t.offset(t.floor(max));\n        }\n        t = t.range(min, t.offset(max));\n      }\n      T = t;\n    } else {\n      V = coerceNumbers(V);\n      let [min, max] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min, max) : thresholds;\n      if (typeof t === \"number\") {\n        // This differs from d3.ticks with regard to exclusive bounds: we want a\n        // first threshold less than or equal to the minimum, and a last\n        // threshold (strictly) greater than the maximum.\n        if (domain === extent) {\n          let step = tickIncrement(min, max, t);\n          if (isFinite(step)) {\n            if (step > 0) {\n              let r0 = Math.round(min / step);\n              let r1 = Math.round(max / step);\n              if (!(r0 * step <= min)) --r0;\n              if (!(r1 * step > max)) ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i) t[i] = (r0 + i) * step;\n            } else if (step < 0) {\n              step = -step;\n              let r0 = Math.round(min * step);\n              let r1 = Math.round(max * step);\n              if (!(r0 / step <= min)) --r0;\n              if (!(r1 / step > max)) ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i) t[i] = (r0 + i) / step;\n            } else {\n              t = [min];\n            }\n          } else {\n            t = [min];\n          }\n        } else {\n          t = ticks(min, max, t);\n        }\n      } else if (isInterval(t)) {\n        if (domain === extent) {\n          min = t.floor(min);\n          max = t.offset(t.floor(max));\n        }\n        t = t.range(min, t.offset(max));\n      }\n      T = t;\n    }\n    const E = [];\n    if (T.length === 1) E.push([T[0], T[0]]); // collapsed domain\n    else for (let i = 1; i < T.length; ++i) E.push([T[i - 1], T[i]]);\n    E.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E, T, V);\n    return E;\n  };\n  bin.label = labelof(value);\n  return bin;\n}\nexport function maybeThresholds(thresholds, interval, defaultThresholds = thresholdAuto) {\n  if (thresholds === undefined) {\n    return interval === undefined ? defaultThresholds : maybeRangeInterval(interval);\n  }\n  if (typeof thresholds === \"string\") {\n    switch (thresholds.toLowerCase()) {\n      case \"freedman-diaconis\":\n        return thresholdFreedmanDiaconis;\n      case \"scott\":\n        return thresholdScott;\n      case \"sturges\":\n        return thresholdSturges;\n      case \"auto\":\n        return thresholdAuto;\n    }\n    return utcInterval(thresholds);\n  }\n  return thresholds; // pass array, count, or function to bin.thresholds\n}\n\nfunction maybeBinOutputs(outputs, inputs) {\n  return maybeOutputs(outputs, inputs, maybeBinOutput);\n}\nfunction maybeBinOutput(name, reduce, inputs) {\n  return maybeOutput(name, reduce, inputs, maybeBinEvaluator);\n}\nfunction maybeBinEvaluator(name, reduce, inputs) {\n  return maybeEvaluator(name, reduce, inputs, maybeBinReduce);\n}\nfunction maybeBinReduce(reduce, value) {\n  return maybeReduce(reduce, value, maybeBinReduceFallback);\n}\nfunction maybeBinReduceFallback(reduce) {\n  switch (`${reduce}`.toLowerCase()) {\n    case \"x\":\n      return reduceX;\n    case \"x1\":\n      return reduceX1;\n    case \"x2\":\n      return reduceX2;\n    case \"y\":\n      return reduceY;\n    case \"y1\":\n      return reduceY1;\n    case \"y2\":\n      return reduceY2;\n    case \"z\":\n      return reduceZ;\n  }\n  throw new Error(`invalid bin reduce: ${reduce}`);\n}\nfunction thresholdAuto(values, min, max) {\n  return Math.min(200, thresholdScott(values, min, max));\n}\nfunction isTimeThresholds(t) {\n  return isTimeInterval(t) || isIterable(t) && isTemporal(t);\n}\nfunction bing(bx, by, data) {\n  const EX = bx?.(data);\n  const EY = by?.(data);\n  return EX && EY ? function* (I) {\n    const X = EX.bin(I); // first bin on x\n    for (const [ix, [x1, x2]] of EX.entries()) {\n      const Y = EY.bin(X[ix]); // then bin on y\n      for (const [iy, [y1, y2]] of EY.entries()) {\n        yield [Y[iy], {\n          data,\n          x1,\n          y1,\n          x2,\n          y2\n        }];\n      }\n    }\n  } : EX ? function* (I) {\n    const X = EX.bin(I);\n    for (const [i, [x1, x2]] of EX.entries()) {\n      yield [X[i], {\n        data,\n        x1,\n        x2\n      }];\n    }\n  } : function* (I) {\n    const Y = EY.bin(I);\n    for (const [i, [y1, y2]] of EY.entries()) {\n      yield [Y[i], {\n        data,\n        y1,\n        y2\n      }];\n    }\n  };\n}\n\n// non-cumulative distribution\nfunction bin1(E, T, V) {\n  T = coerceNumbers(T); // for faster bisection\n  return I => {\n    const B = E.map(() => []);\n    for (const i of I) B[bisect(T, V[i]) - 1]?.push(i); // TODO quantization?\n    return B;\n  };\n}\n\n// cumulative distribution\nfunction bin1cp(E, T, V) {\n  const bin = bin1(E, T, V);\n  return I => {\n    const B = bin(I);\n    for (let i = 1, n = B.length; i < n; ++i) {\n      const C = B[i - 1];\n      const b = B[i];\n      for (const j of C) b.push(j);\n    }\n    return B;\n  };\n}\n\n// complementary cumulative distribution\nfunction bin1cn(E, T, V) {\n  const bin = bin1(E, T, V);\n  return I => {\n    const B = bin(I);\n    for (let i = B.length - 2; i >= 0; --i) {\n      const C = B[i + 1];\n      const b = B[i];\n      for (const j of C) b.push(j);\n    }\n    return B;\n  };\n}\nfunction mid1(x1, x2) {\n  const m = (+x1 + +x2) / 2;\n  return x1 instanceof Date ? new Date(m) : m;\n}\nconst reduceX = {\n  reduceIndex(I, X, {\n    x1,\n    x2\n  }) {\n    return mid1(x1, x2);\n  }\n};\nconst reduceY = {\n  reduceIndex(I, X, {\n    y1,\n    y2\n  }) {\n    return mid1(y1, y2);\n  }\n};\nconst reduceX1 = {\n  reduceIndex(I, X, {\n    x1\n  }) {\n    return x1;\n  }\n};\nconst reduceX2 = {\n  reduceIndex(I, X, {\n    x2\n  }) {\n    return x2;\n  }\n};\nconst reduceY1 = {\n  reduceIndex(I, X, {\n    y1\n  }) {\n    return y1;\n  }\n};\nconst reduceY2 = {\n  reduceIndex(I, X, {\n    y2\n  }) {\n    return y2;\n  }\n};","map":{"version":3,"names":["bisect","extent","thresholdFreedmanDiaconis","thresholdScott","thresholdSturges","tickIncrement","ticks","utcTickInterval","withTip","coerceDate","coerceNumbers","identity","isInterval","isIterable","isTemporal","isTimeInterval","labelof","map","maybeApplyInterval","maybeColorChannel","maybeColumn","maybeRangeInterval","maybeTuple","maybeValue","mid","valueof","utcInterval","basic","hasOutput","maybeEvaluator","maybeGroup","maybeOutput","maybeOutputs","maybeReduce","maybeSort","maybeSubgroup","reduceCount","reduceFirst","reduceIdentity","reduceZ","maybeInsetX","maybeInsetY","binX","outputs","y","options","mergeOptions","x","binn","maybeBinValue","binY","bin","fill","maybeBinValueTuple","maybeDenseInterval","k","interval","reduce","filter","maybeDenseIntervalX","maybeDenseIntervalY","bx","by","gx","gy","data","reduceData","sort","reverse","inputs","maybeBin","maybeBinOutputs","maybeBinReduce","undefined","maybeBinOutput","maybeBinEvaluator","BX1","setBX1","BX2","setBX2","BY1","setBY1","BY2","setBY2","gk","GK","setGK","z","stroke","x1","x2","y1","y2","domain","cumulative","thresholds","GZ","setGZ","vfill","vstroke","GF","setGF","GS","setGS","facets","plotOptions","K","Z","F","S","G","groupFacets","groupData","bing","i","o","initialize","facet","groupFacet","scope","f","I","g","b","push","reduceIndex","length","Object","fromEntries","name","output","value","defaultValue","maybeThresholds","V","T","isTimeThresholds","Float64Array","min","max","t","floor","offset","range","step","isFinite","r0","Math","round","r1","n","E","bin1cn","bin1cp","bin1","label","defaultThresholds","thresholdAuto","toLowerCase","maybeBinReduceFallback","reduceX","reduceX1","reduceX2","reduceY","reduceY1","reduceY2","Error","values","EX","EY","X","ix","entries","Y","iy","B","C","j","mid1","m","Date"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/bin.js"],"sourcesContent":["import {\n  bisect,\n  extent,\n  thresholdFreedmanDiaconis,\n  thresholdScott,\n  thresholdSturges,\n  tickIncrement,\n  ticks,\n  utcTickInterval\n} from \"d3\";\nimport {withTip} from \"../mark.js\";\nimport {\n  coerceDate,\n  coerceNumbers,\n  identity,\n  isInterval,\n  isIterable,\n  isTemporal,\n  isTimeInterval,\n  labelof,\n  map,\n  maybeApplyInterval,\n  maybeColorChannel,\n  maybeColumn,\n  maybeRangeInterval,\n  maybeTuple,\n  maybeValue,\n  mid,\n  valueof\n} from \"../options.js\";\nimport {utcInterval} from \"../time.js\";\nimport {basic} from \"./basic.js\";\nimport {\n  hasOutput,\n  maybeEvaluator,\n  maybeGroup,\n  maybeOutput,\n  maybeOutputs,\n  maybeReduce,\n  maybeSort,\n  maybeSubgroup,\n  reduceCount,\n  reduceFirst,\n  reduceIdentity,\n  reduceZ\n} from \"./group.js\";\nimport {maybeInsetX, maybeInsetY} from \"./inset.js\";\n\n// Group on {z, fill, stroke}, then optionally on y, then bin x.\nexport function binX(outputs = {y: \"count\"}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {x, y} = options;\n  return binn(maybeBinValue(x, options, identity), null, null, y, outputs, maybeInsetX(options));\n}\n\n// Group on {z, fill, stroke}, then optionally on x, then bin y.\nexport function binY(outputs = {x: \"count\"}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {x, y} = options;\n  return binn(null, maybeBinValue(y, options, identity), x, null, outputs, maybeInsetY(options));\n}\n\n// Group on {z, fill, stroke}, then bin on x and y.\nexport function bin(outputs = {fill: \"count\"}, options = {}) {\n  [outputs, options] = mergeOptions(outputs, options);\n  const {x, y} = maybeBinValueTuple(options);\n  return binn(x, y, null, null, outputs, maybeInsetX(maybeInsetY(options)));\n}\n\nfunction maybeDenseInterval(bin, k, options = {}) {\n  if (options?.interval == null) return options;\n  const {reduce = reduceFirst} = options;\n  const outputs = {filter: null};\n  if (options[k] != null) outputs[k] = reduce;\n  if (options[`${k}1`] != null) outputs[`${k}1`] = reduce;\n  if (options[`${k}2`] != null) outputs[`${k}2`] = reduce;\n  return bin(outputs, options);\n}\n\nexport function maybeDenseIntervalX(options = {}) {\n  return maybeDenseInterval(binX, \"y\", withTip(options, \"x\"));\n}\n\nexport function maybeDenseIntervalY(options = {}) {\n  return maybeDenseInterval(binY, \"x\", withTip(options, \"y\"));\n}\n\nfunction binn(\n  bx, // optionally bin on x (exclusive with gx)\n  by, // optionally bin on y (exclusive with gy)\n  gx, // optionally group on x (exclusive with bx and gy)\n  gy, // optionally group on y (exclusive with by and gx)\n  {\n    data: reduceData = reduceIdentity, // TODO avoid materializing when unused?\n    filter = reduceCount, // return only non-empty bins by default\n    sort,\n    reverse,\n    ...outputs // output channel definitions\n  } = {},\n  inputs = {} // input channels and options\n) {\n  bx = maybeBin(bx);\n  by = maybeBin(by);\n\n  // Compute the outputs.\n  outputs = maybeBinOutputs(outputs, inputs);\n  reduceData = maybeBinReduce(reduceData, identity);\n  sort = sort == null ? undefined : maybeBinOutput(\"sort\", sort, inputs);\n  filter = filter == null ? undefined : maybeBinEvaluator(\"filter\", filter, inputs);\n\n  // Donâ€™t group on a channel if an output requires it as an input!\n  if (gx != null && hasOutput(outputs, \"x\", \"x1\", \"x2\")) gx = null;\n  if (gy != null && hasOutput(outputs, \"y\", \"y1\", \"y2\")) gy = null;\n\n  // Produce x1, x2, y1, and y2 output channels as appropriate (when binning).\n  const [BX1, setBX1] = maybeColumn(bx);\n  const [BX2, setBX2] = maybeColumn(bx);\n  const [BY1, setBY1] = maybeColumn(by);\n  const [BY2, setBY2] = maybeColumn(by);\n\n  // Produce x or y output channels as appropriate (when grouping).\n  const [k, gk] = gx != null ? [gx, \"x\"] : gy != null ? [gy, \"y\"] : [];\n  const [GK, setGK] = maybeColumn(k);\n\n  // Greedily materialize the z, fill, and stroke channels (if channels and not\n  // constants) so that we can reference them for subdividing groups without\n  // computing them more than once. We also want to consume options that should\n  // only apply to this transform rather than passing them through to the next.\n  const {\n    x,\n    y,\n    z,\n    fill,\n    stroke,\n    x1,\n    x2, // consumed if x is an output\n    y1,\n    y2, // consumed if y is an output\n    domain,\n    cumulative,\n    thresholds,\n    interval,\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n\n  return {\n    ...(\"z\" in inputs && {z: GZ || z}),\n    ...(\"fill\" in inputs && {fill: GF || fill}),\n    ...(\"stroke\" in inputs && {stroke: GS || stroke}),\n    ...basic(options, (data, facets, plotOptions) => {\n      const K = maybeApplyInterval(valueof(data, k), plotOptions?.[gk]);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, {z: Z, fill: F, stroke: S});\n      const groupFacets = [];\n      const groupData = [];\n      const GK = K && setGK([]);\n      const GZ = Z && setGZ([]);\n      const GF = F && setGF([]);\n      const GS = S && setGS([]);\n      const BX1 = bx && setBX1([]);\n      const BX2 = bx && setBX2([]);\n      const BY1 = by && setBY1([]);\n      const BY2 = by && setBY2([]);\n      const bin = bing(bx, by, data);\n      let i = 0;\n      for (const o of outputs) o.initialize(data);\n      if (sort) sort.initialize(data);\n      if (filter) filter.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs) o.scope(\"facet\", facet);\n        if (sort) sort.scope(\"facet\", facet);\n        if (filter) filter.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [k, g] of maybeGroup(I, K)) {\n            for (const [b, extent] of bin(g)) {\n              if (G) extent.z = f;\n              if (filter && !filter.reduce(b, extent)) continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduceIndex(b, data, extent));\n              if (K) GK.push(k);\n              if (Z) GZ.push(G === Z ? f : Z[(b.length > 0 ? b : g)[0]]);\n              if (F) GF.push(G === F ? f : F[(b.length > 0 ? b : g)[0]]);\n              if (S) GS.push(G === S ? f : S[(b.length > 0 ? b : g)[0]]);\n              if (BX1) BX1.push(extent.x1), BX2.push(extent.x2);\n              if (BY1) BY1.push(extent.y1), BY2.push(extent.y2);\n              for (const o of outputs) o.reduce(b, extent);\n              if (sort) sort.reduce(b, extent);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort, reverse);\n      return {data: groupData, facets: groupFacets};\n    }),\n    ...(!hasOutput(outputs, \"x\") && (BX1 ? {x1: BX1, x2: BX2, x: mid(BX1, BX2)} : {x, x1, x2})),\n    ...(!hasOutput(outputs, \"y\") && (BY1 ? {y1: BY1, y2: BY2, y: mid(BY1, BY2)} : {y, y1, y2})),\n    ...(GK && {[gk]: GK}),\n    ...Object.fromEntries(outputs.map(({name, output}) => [name, output]))\n  };\n}\n\n// Allow bin options to be specified as part of outputs; merge them into options.\nfunction mergeOptions({cumulative, domain, thresholds, interval, ...outputs}, options) {\n  return [outputs, {cumulative, domain, thresholds, interval, ...options}];\n}\n\nfunction maybeBinValue(value, {cumulative, domain, thresholds, interval}, defaultValue) {\n  value = {...maybeValue(value)};\n  if (value.domain === undefined) value.domain = domain;\n  if (value.cumulative === undefined) value.cumulative = cumulative;\n  if (value.thresholds === undefined) value.thresholds = thresholds;\n  if (value.interval === undefined) value.interval = interval;\n  if (value.value === undefined) value.value = defaultValue;\n  value.thresholds = maybeThresholds(value.thresholds, value.interval);\n  return value;\n}\n\nfunction maybeBinValueTuple(options) {\n  let {x, y} = options;\n  x = maybeBinValue(x, options);\n  y = maybeBinValue(y, options);\n  [x.value, y.value] = maybeTuple(x.value, y.value);\n  return {x, y};\n}\n\nfunction maybeBin(options) {\n  if (options == null) return;\n  const {value, cumulative, domain = extent, thresholds} = options;\n  const bin = (data) => {\n    let V = valueof(data, value);\n    let T; // bin thresholds\n    if (isTemporal(V) || isTimeThresholds(thresholds)) {\n      V = map(V, coerceDate, Float64Array); // like coerceDates, but faster\n      let [min, max] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min, max) : thresholds;\n      if (typeof t === \"number\") t = utcTickInterval(min, max, t);\n      if (isInterval(t)) {\n        if (domain === extent) {\n          min = t.floor(min);\n          max = t.offset(t.floor(max));\n        }\n        t = t.range(min, t.offset(max));\n      }\n      T = t;\n    } else {\n      V = coerceNumbers(V);\n      let [min, max] = typeof domain === \"function\" ? domain(V) : domain;\n      let t = typeof thresholds === \"function\" && !isInterval(thresholds) ? thresholds(V, min, max) : thresholds;\n      if (typeof t === \"number\") {\n        // This differs from d3.ticks with regard to exclusive bounds: we want a\n        // first threshold less than or equal to the minimum, and a last\n        // threshold (strictly) greater than the maximum.\n        if (domain === extent) {\n          let step = tickIncrement(min, max, t);\n          if (isFinite(step)) {\n            if (step > 0) {\n              let r0 = Math.round(min / step);\n              let r1 = Math.round(max / step);\n              if (!(r0 * step <= min)) --r0;\n              if (!(r1 * step > max)) ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i) t[i] = (r0 + i) * step;\n            } else if (step < 0) {\n              step = -step;\n              let r0 = Math.round(min * step);\n              let r1 = Math.round(max * step);\n              if (!(r0 / step <= min)) --r0;\n              if (!(r1 / step > max)) ++r1;\n              let n = r1 - r0 + 1;\n              t = new Float64Array(n);\n              for (let i = 0; i < n; ++i) t[i] = (r0 + i) / step;\n            } else {\n              t = [min];\n            }\n          } else {\n            t = [min];\n          }\n        } else {\n          t = ticks(min, max, t);\n        }\n      } else if (isInterval(t)) {\n        if (domain === extent) {\n          min = t.floor(min);\n          max = t.offset(t.floor(max));\n        }\n        t = t.range(min, t.offset(max));\n      }\n      T = t;\n    }\n    const E = [];\n    if (T.length === 1) E.push([T[0], T[0]]); // collapsed domain\n    else for (let i = 1; i < T.length; ++i) E.push([T[i - 1], T[i]]);\n    E.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E, T, V);\n    return E;\n  };\n  bin.label = labelof(value);\n  return bin;\n}\n\nexport function maybeThresholds(thresholds, interval, defaultThresholds = thresholdAuto) {\n  if (thresholds === undefined) {\n    return interval === undefined ? defaultThresholds : maybeRangeInterval(interval);\n  }\n  if (typeof thresholds === \"string\") {\n    switch (thresholds.toLowerCase()) {\n      case \"freedman-diaconis\":\n        return thresholdFreedmanDiaconis;\n      case \"scott\":\n        return thresholdScott;\n      case \"sturges\":\n        return thresholdSturges;\n      case \"auto\":\n        return thresholdAuto;\n    }\n    return utcInterval(thresholds);\n  }\n  return thresholds; // pass array, count, or function to bin.thresholds\n}\n\nfunction maybeBinOutputs(outputs, inputs) {\n  return maybeOutputs(outputs, inputs, maybeBinOutput);\n}\n\nfunction maybeBinOutput(name, reduce, inputs) {\n  return maybeOutput(name, reduce, inputs, maybeBinEvaluator);\n}\n\nfunction maybeBinEvaluator(name, reduce, inputs) {\n  return maybeEvaluator(name, reduce, inputs, maybeBinReduce);\n}\n\nfunction maybeBinReduce(reduce, value) {\n  return maybeReduce(reduce, value, maybeBinReduceFallback);\n}\n\nfunction maybeBinReduceFallback(reduce) {\n  switch (`${reduce}`.toLowerCase()) {\n    case \"x\":\n      return reduceX;\n    case \"x1\":\n      return reduceX1;\n    case \"x2\":\n      return reduceX2;\n    case \"y\":\n      return reduceY;\n    case \"y1\":\n      return reduceY1;\n    case \"y2\":\n      return reduceY2;\n    case \"z\":\n      return reduceZ;\n  }\n  throw new Error(`invalid bin reduce: ${reduce}`);\n}\n\nfunction thresholdAuto(values, min, max) {\n  return Math.min(200, thresholdScott(values, min, max));\n}\n\nfunction isTimeThresholds(t) {\n  return isTimeInterval(t) || (isIterable(t) && isTemporal(t));\n}\n\nfunction bing(bx, by, data) {\n  const EX = bx?.(data);\n  const EY = by?.(data);\n  return EX && EY\n    ? function* (I) {\n        const X = EX.bin(I); // first bin on x\n        for (const [ix, [x1, x2]] of EX.entries()) {\n          const Y = EY.bin(X[ix]); // then bin on y\n          for (const [iy, [y1, y2]] of EY.entries()) {\n            yield [Y[iy], {data, x1, y1, x2, y2}];\n          }\n        }\n      }\n    : EX\n    ? function* (I) {\n        const X = EX.bin(I);\n        for (const [i, [x1, x2]] of EX.entries()) {\n          yield [X[i], {data, x1, x2}];\n        }\n      }\n    : function* (I) {\n        const Y = EY.bin(I);\n        for (const [i, [y1, y2]] of EY.entries()) {\n          yield [Y[i], {data, y1, y2}];\n        }\n      };\n}\n\n// non-cumulative distribution\nfunction bin1(E, T, V) {\n  T = coerceNumbers(T); // for faster bisection\n  return (I) => {\n    const B = E.map(() => []);\n    for (const i of I) B[bisect(T, V[i]) - 1]?.push(i); // TODO quantization?\n    return B;\n  };\n}\n\n// cumulative distribution\nfunction bin1cp(E, T, V) {\n  const bin = bin1(E, T, V);\n  return (I) => {\n    const B = bin(I);\n    for (let i = 1, n = B.length; i < n; ++i) {\n      const C = B[i - 1];\n      const b = B[i];\n      for (const j of C) b.push(j);\n    }\n    return B;\n  };\n}\n\n// complementary cumulative distribution\nfunction bin1cn(E, T, V) {\n  const bin = bin1(E, T, V);\n  return (I) => {\n    const B = bin(I);\n    for (let i = B.length - 2; i >= 0; --i) {\n      const C = B[i + 1];\n      const b = B[i];\n      for (const j of C) b.push(j);\n    }\n    return B;\n  };\n}\n\nfunction mid1(x1, x2) {\n  const m = (+x1 + +x2) / 2;\n  return x1 instanceof Date ? new Date(m) : m;\n}\n\nconst reduceX = {\n  reduceIndex(I, X, {x1, x2}) {\n    return mid1(x1, x2);\n  }\n};\n\nconst reduceY = {\n  reduceIndex(I, X, {y1, y2}) {\n    return mid1(y1, y2);\n  }\n};\n\nconst reduceX1 = {\n  reduceIndex(I, X, {x1}) {\n    return x1;\n  }\n};\n\nconst reduceX2 = {\n  reduceIndex(I, X, {x2}) {\n    return x2;\n  }\n};\n\nconst reduceY1 = {\n  reduceIndex(I, X, {y1}) {\n    return y1;\n  }\n};\n\nconst reduceY2 = {\n  reduceIndex(I, X, {y2}) {\n    return y2;\n  }\n};\n"],"mappings":";;;;AAAA,SACEA,MAAM,EACNC,MAAM,EACNC,yBAAyB,EACzBC,cAAc,EACdC,gBAAgB,EAChBC,aAAa,EACbC,KAAK,EACLC,eAAe,QACV,IAAI;AACX,SAAQC,OAAO,QAAO,YAAY;AAClC,SACEC,UAAU,EACVC,aAAa,EACbC,QAAQ,EACRC,UAAU,EACVC,UAAU,EACVC,UAAU,EACVC,cAAc,EACdC,OAAO,EACPC,GAAG,EACHC,kBAAkB,EAClBC,iBAAiB,EACjBC,WAAW,EACXC,kBAAkB,EAClBC,UAAU,EACVC,UAAU,EACVC,GAAG,EACHC,OAAO,QACF,eAAe;AACtB,SAAQC,WAAW,QAAO,YAAY;AACtC,SAAQC,KAAK,QAAO,YAAY;AAChC,SACEC,SAAS,EACTC,cAAc,EACdC,UAAU,EACVC,WAAW,EACXC,YAAY,EACZC,WAAW,EACXC,SAAS,EACTC,aAAa,EACbC,WAAW,EACXC,WAAW,EACXC,cAAc,EACdC,OAAO,QACF,YAAY;AACnB,SAAQC,WAAW,EAAEC,WAAW,QAAO,YAAY;;AAEnD;AACA,OAAO,SAASC,IAAIA,CAACC,OAAO,GAAG;EAACC,CAAC,EAAE;AAAO,CAAC,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACzD,CAACF,OAAO,EAAEE,OAAO,CAAC,GAAGC,YAAY,CAACH,OAAO,EAAEE,OAAO,CAAC;EACnD,MAAM;IAACE,CAAC;IAAEH;EAAC,CAAC,GAAGC,OAAO;EACtB,OAAOG,IAAI,CAACC,aAAa,CAACF,CAAC,EAAEF,OAAO,EAAElC,QAAQ,CAAC,EAAE,IAAI,EAAE,IAAI,EAAEiC,CAAC,EAAED,OAAO,EAAEH,WAAW,CAACK,OAAO,CAAC,CAAC;AAChG;;AAEA;AACA,OAAO,SAASK,IAAIA,CAACP,OAAO,GAAG;EAACI,CAAC,EAAE;AAAO,CAAC,EAAEF,OAAO,GAAG,CAAC,CAAC,EAAE;EACzD,CAACF,OAAO,EAAEE,OAAO,CAAC,GAAGC,YAAY,CAACH,OAAO,EAAEE,OAAO,CAAC;EACnD,MAAM;IAACE,CAAC;IAAEH;EAAC,CAAC,GAAGC,OAAO;EACtB,OAAOG,IAAI,CAAC,IAAI,EAAEC,aAAa,CAACL,CAAC,EAAEC,OAAO,EAAElC,QAAQ,CAAC,EAAEoC,CAAC,EAAE,IAAI,EAAEJ,OAAO,EAAEF,WAAW,CAACI,OAAO,CAAC,CAAC;AAChG;;AAEA;AACA,OAAO,SAASM,GAAGA,CAACR,OAAO,GAAG;EAACS,IAAI,EAAE;AAAO,CAAC,EAAEP,OAAO,GAAG,CAAC,CAAC,EAAE;EAC3D,CAACF,OAAO,EAAEE,OAAO,CAAC,GAAGC,YAAY,CAACH,OAAO,EAAEE,OAAO,CAAC;EACnD,MAAM;IAACE,CAAC;IAAEH;EAAC,CAAC,GAAGS,kBAAkB,CAACR,OAAO,CAAC;EAC1C,OAAOG,IAAI,CAACD,CAAC,EAAEH,CAAC,EAAE,IAAI,EAAE,IAAI,EAAED,OAAO,EAAEH,WAAW,CAACC,WAAW,CAACI,OAAO,CAAC,CAAC,CAAC;AAC3E;AAEA,SAASS,kBAAkBA,CAACH,GAAG,EAAEI,CAAC,EAAEV,OAAO,GAAG,CAAC,CAAC,EAAE;EAChD,IAAIA,OAAO,EAAEW,QAAQ,IAAI,IAAI,EAAE,OAAOX,OAAO;EAC7C,MAAM;IAACY,MAAM,GAAGpB;EAAW,CAAC,GAAGQ,OAAO;EACtC,MAAMF,OAAO,GAAG;IAACe,MAAM,EAAE;EAAI,CAAC;EAC9B,IAAIb,OAAO,CAACU,CAAC,CAAC,IAAI,IAAI,EAAEZ,OAAO,CAACY,CAAC,CAAC,GAAGE,MAAM;EAC3C,IAAIZ,OAAO,CAAE,GAAEU,CAAE,GAAE,CAAC,IAAI,IAAI,EAAEZ,OAAO,CAAE,GAAEY,CAAE,GAAE,CAAC,GAAGE,MAAM;EACvD,IAAIZ,OAAO,CAAE,GAAEU,CAAE,GAAE,CAAC,IAAI,IAAI,EAAEZ,OAAO,CAAE,GAAEY,CAAE,GAAE,CAAC,GAAGE,MAAM;EACvD,OAAON,GAAG,CAACR,OAAO,EAAEE,OAAO,CAAC;AAC9B;AAEA,OAAO,SAASc,mBAAmBA,CAACd,OAAO,GAAG,CAAC,CAAC,EAAE;EAChD,OAAOS,kBAAkB,CAACZ,IAAI,EAAE,GAAG,EAAElC,OAAO,CAACqC,OAAO,EAAE,GAAG,CAAC,CAAC;AAC7D;AAEA,OAAO,SAASe,mBAAmBA,CAACf,OAAO,GAAG,CAAC,CAAC,EAAE;EAChD,OAAOS,kBAAkB,CAACJ,IAAI,EAAE,GAAG,EAAE1C,OAAO,CAACqC,OAAO,EAAE,GAAG,CAAC,CAAC;AAC7D;AAEA,SAASG,IAAIA,CACXa,EAAE;AAAE;AACJC,EAAE;AAAE;AACJC,EAAE;AAAE;AACJC,EAAE;AAAE;AACJ;EACEC,IAAI,EAAEC,UAAU,GAAG5B,cAAc;EAAE;EACnCoB,MAAM,GAAGtB,WAAW;EAAE;EACtB+B,IAAI;EACJC,OAAO;EACP,GAAGzB,OAAO,CAAC;AACb,CAAC,GAAG,CAAC,CAAC,EACN0B,MAAM,GAAG,CAAC,CAAC,CAAC;AAAA,EACZ;EACAR,EAAE,GAAGS,QAAQ,CAACT,EAAE,CAAC;EACjBC,EAAE,GAAGQ,QAAQ,CAACR,EAAE,CAAC;;EAEjB;EACAnB,OAAO,GAAG4B,eAAe,CAAC5B,OAAO,EAAE0B,MAAM,CAAC;EAC1CH,UAAU,GAAGM,cAAc,CAACN,UAAU,EAAEvD,QAAQ,CAAC;EACjDwD,IAAI,GAAGA,IAAI,IAAI,IAAI,GAAGM,SAAS,GAAGC,cAAc,CAAC,MAAM,EAAEP,IAAI,EAAEE,MAAM,CAAC;EACtEX,MAAM,GAAGA,MAAM,IAAI,IAAI,GAAGe,SAAS,GAAGE,iBAAiB,CAAC,QAAQ,EAAEjB,MAAM,EAAEW,MAAM,CAAC;;EAEjF;EACA,IAAIN,EAAE,IAAI,IAAI,IAAInC,SAAS,CAACe,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,EAAEoB,EAAE,GAAG,IAAI;EAChE,IAAIC,EAAE,IAAI,IAAI,IAAIpC,SAAS,CAACe,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,EAAEqB,EAAE,GAAG,IAAI;;EAEhE;EACA,MAAM,CAACY,GAAG,EAAEC,MAAM,CAAC,GAAGzD,WAAW,CAACyC,EAAE,CAAC;EACrC,MAAM,CAACiB,GAAG,EAAEC,MAAM,CAAC,GAAG3D,WAAW,CAACyC,EAAE,CAAC;EACrC,MAAM,CAACmB,GAAG,EAAEC,MAAM,CAAC,GAAG7D,WAAW,CAAC0C,EAAE,CAAC;EACrC,MAAM,CAACoB,GAAG,EAAEC,MAAM,CAAC,GAAG/D,WAAW,CAAC0C,EAAE,CAAC;;EAErC;EACA,MAAM,CAACP,CAAC,EAAE6B,EAAE,CAAC,GAAGrB,EAAE,IAAI,IAAI,GAAG,CAACA,EAAE,EAAE,GAAG,CAAC,GAAGC,EAAE,IAAI,IAAI,GAAG,CAACA,EAAE,EAAE,GAAG,CAAC,GAAG,EAAE;EACpE,MAAM,CAACqB,EAAE,EAAEC,KAAK,CAAC,GAAGlE,WAAW,CAACmC,CAAC,CAAC;;EAElC;EACA;EACA;EACA;EACA,MAAM;IACJR,CAAC;IACDH,CAAC;IACD2C,CAAC;IACDnC,IAAI;IACJoC,MAAM;IACNC,EAAE;IACFC,EAAE;IAAE;IACJC,EAAE;IACFC,EAAE;IAAE;IACJC,MAAM;IACNC,UAAU;IACVC,UAAU;IACVvC,QAAQ;IACR,GAAGX;EACL,CAAC,GAAGwB,MAAM;EACV,MAAM,CAAC2B,EAAE,EAAEC,KAAK,CAAC,GAAG7E,WAAW,CAACmE,CAAC,CAAC;EAClC,MAAM,CAACW,KAAK,CAAC,GAAG/E,iBAAiB,CAACiC,IAAI,CAAC;EACvC,MAAM,CAAC+C,OAAO,CAAC,GAAGhF,iBAAiB,CAACqE,MAAM,CAAC;EAC3C,MAAM,CAACY,EAAE,EAAEC,KAAK,CAAC,GAAGjF,WAAW,CAAC8E,KAAK,CAAC;EACtC,MAAM,CAACI,EAAE,EAAEC,KAAK,CAAC,GAAGnF,WAAW,CAAC+E,OAAO,CAAC;EAExC,OAAO;IACL,IAAI,GAAG,IAAI9B,MAAM,IAAI;MAACkB,CAAC,EAAES,EAAE,IAAIT;IAAC,CAAC,CAAC;IAClC,IAAI,MAAM,IAAIlB,MAAM,IAAI;MAACjB,IAAI,EAAEgD,EAAE,IAAIhD;IAAI,CAAC,CAAC;IAC3C,IAAI,QAAQ,IAAIiB,MAAM,IAAI;MAACmB,MAAM,EAAEc,EAAE,IAAId;IAAM,CAAC,CAAC;IACjD,GAAG7D,KAAK,CAACkB,OAAO,EAAE,CAACoB,IAAI,EAAEuC,MAAM,EAAEC,WAAW,KAAK;MAC/C,MAAMC,CAAC,GAAGxF,kBAAkB,CAACO,OAAO,CAACwC,IAAI,EAAEV,CAAC,CAAC,EAAEkD,WAAW,GAAGrB,EAAE,CAAC,CAAC;MACjE,MAAMuB,CAAC,GAAGlF,OAAO,CAACwC,IAAI,EAAEsB,CAAC,CAAC;MAC1B,MAAMqB,CAAC,GAAGnF,OAAO,CAACwC,IAAI,EAAEiC,KAAK,CAAC;MAC9B,MAAMW,CAAC,GAAGpF,OAAO,CAACwC,IAAI,EAAEkC,OAAO,CAAC;MAChC,MAAMW,CAAC,GAAG3E,aAAa,CAACQ,OAAO,EAAE;QAAC4C,CAAC,EAAEoB,CAAC;QAAEvD,IAAI,EAAEwD,CAAC;QAAEpB,MAAM,EAAEqB;MAAC,CAAC,CAAC;MAC5D,MAAME,WAAW,GAAG,EAAE;MACtB,MAAMC,SAAS,GAAG,EAAE;MACpB,MAAM3B,EAAE,GAAGqB,CAAC,IAAIpB,KAAK,CAAC,EAAE,CAAC;MACzB,MAAMU,EAAE,GAAGW,CAAC,IAAIV,KAAK,CAAC,EAAE,CAAC;MACzB,MAAMG,EAAE,GAAGQ,CAAC,IAAIP,KAAK,CAAC,EAAE,CAAC;MACzB,MAAMC,EAAE,GAAGO,CAAC,IAAIN,KAAK,CAAC,EAAE,CAAC;MACzB,MAAM3B,GAAG,GAAGf,EAAE,IAAIgB,MAAM,CAAC,EAAE,CAAC;MAC5B,MAAMC,GAAG,GAAGjB,EAAE,IAAIkB,MAAM,CAAC,EAAE,CAAC;MAC5B,MAAMC,GAAG,GAAGlB,EAAE,IAAImB,MAAM,CAAC,EAAE,CAAC;MAC5B,MAAMC,GAAG,GAAGpB,EAAE,IAAIqB,MAAM,CAAC,EAAE,CAAC;MAC5B,MAAMhC,GAAG,GAAG8D,IAAI,CAACpD,EAAE,EAAEC,EAAE,EAAEG,IAAI,CAAC;MAC9B,IAAIiD,CAAC,GAAG,CAAC;MACT,KAAK,MAAMC,CAAC,IAAIxE,OAAO,EAAEwE,CAAC,CAACC,UAAU,CAACnD,IAAI,CAAC;MAC3C,IAAIE,IAAI,EAAEA,IAAI,CAACiD,UAAU,CAACnD,IAAI,CAAC;MAC/B,IAAIP,MAAM,EAAEA,MAAM,CAAC0D,UAAU,CAACnD,IAAI,CAAC;MACnC,KAAK,MAAMoD,KAAK,IAAIb,MAAM,EAAE;QAC1B,MAAMc,UAAU,GAAG,EAAE;QACrB,KAAK,MAAMH,CAAC,IAAIxE,OAAO,EAAEwE,CAAC,CAACI,KAAK,CAAC,OAAO,EAAEF,KAAK,CAAC;QAChD,IAAIlD,IAAI,EAAEA,IAAI,CAACoD,KAAK,CAAC,OAAO,EAAEF,KAAK,CAAC;QACpC,IAAI3D,MAAM,EAAEA,MAAM,CAAC6D,KAAK,CAAC,OAAO,EAAEF,KAAK,CAAC;QACxC,KAAK,MAAM,CAACG,CAAC,EAAEC,CAAC,CAAC,IAAI3F,UAAU,CAACuF,KAAK,EAAEP,CAAC,CAAC,EAAE;UACzC,KAAK,MAAM,CAACvD,CAAC,EAAEmE,CAAC,CAAC,IAAI5F,UAAU,CAAC2F,CAAC,EAAEf,CAAC,CAAC,EAAE;YACrC,KAAK,MAAM,CAACiB,CAAC,EAAE1H,MAAM,CAAC,IAAIkD,GAAG,CAACuE,CAAC,CAAC,EAAE;cAChC,IAAIZ,CAAC,EAAE7G,MAAM,CAACsF,CAAC,GAAGiC,CAAC;cACnB,IAAI9D,MAAM,IAAI,CAACA,MAAM,CAACD,MAAM,CAACkE,CAAC,EAAE1H,MAAM,CAAC,EAAE;cACzCqH,UAAU,CAACM,IAAI,CAACV,CAAC,EAAE,CAAC;cACpBF,SAAS,CAACY,IAAI,CAAC1D,UAAU,CAAC2D,WAAW,CAACF,CAAC,EAAE1D,IAAI,EAAEhE,MAAM,CAAC,CAAC;cACvD,IAAIyG,CAAC,EAAErB,EAAE,CAACuC,IAAI,CAACrE,CAAC,CAAC;cACjB,IAAIoD,CAAC,EAAEX,EAAE,CAAC4B,IAAI,CAACd,CAAC,KAAKH,CAAC,GAAGa,CAAC,GAAGb,CAAC,CAAC,CAACgB,CAAC,CAACG,MAAM,GAAG,CAAC,GAAGH,CAAC,GAAGD,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;cAC1D,IAAId,CAAC,EAAER,EAAE,CAACwB,IAAI,CAACd,CAAC,KAAKF,CAAC,GAAGY,CAAC,GAAGZ,CAAC,CAAC,CAACe,CAAC,CAACG,MAAM,GAAG,CAAC,GAAGH,CAAC,GAAGD,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;cAC1D,IAAIb,CAAC,EAAEP,EAAE,CAACsB,IAAI,CAACd,CAAC,KAAKD,CAAC,GAAGW,CAAC,GAAGX,CAAC,CAAC,CAACc,CAAC,CAACG,MAAM,GAAG,CAAC,GAAGH,CAAC,GAAGD,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;cAC1D,IAAI9C,GAAG,EAAEA,GAAG,CAACgD,IAAI,CAAC3H,MAAM,CAACwF,EAAE,CAAC,EAAEX,GAAG,CAAC8C,IAAI,CAAC3H,MAAM,CAACyF,EAAE,CAAC;cACjD,IAAIV,GAAG,EAAEA,GAAG,CAAC4C,IAAI,CAAC3H,MAAM,CAAC0F,EAAE,CAAC,EAAET,GAAG,CAAC0C,IAAI,CAAC3H,MAAM,CAAC2F,EAAE,CAAC;cACjD,KAAK,MAAMuB,CAAC,IAAIxE,OAAO,EAAEwE,CAAC,CAAC1D,MAAM,CAACkE,CAAC,EAAE1H,MAAM,CAAC;cAC5C,IAAIkE,IAAI,EAAEA,IAAI,CAACV,MAAM,CAACkE,CAAC,EAAE1H,MAAM,CAAC;YAClC;UACF;QACF;QACA8G,WAAW,CAACa,IAAI,CAACN,UAAU,CAAC;MAC9B;MACApF,SAAS,CAAC6E,WAAW,EAAE5C,IAAI,EAAEC,OAAO,CAAC;MACrC,OAAO;QAACH,IAAI,EAAE+C,SAAS;QAAER,MAAM,EAAEO;MAAW,CAAC;IAC/C,CAAC,CAAC;IACF,IAAI,CAACnF,SAAS,CAACe,OAAO,EAAE,GAAG,CAAC,KAAKiC,GAAG,GAAG;MAACa,EAAE,EAAEb,GAAG;MAAEc,EAAE,EAAEZ,GAAG;MAAE/B,CAAC,EAAEvB,GAAG,CAACoD,GAAG,EAAEE,GAAG;IAAC,CAAC,GAAG;MAAC/B,CAAC;MAAE0C,EAAE;MAAEC;IAAE,CAAC,CAAC,CAAC;IAC3F,IAAI,CAAC9D,SAAS,CAACe,OAAO,EAAE,GAAG,CAAC,KAAKqC,GAAG,GAAG;MAACW,EAAE,EAAEX,GAAG;MAAEY,EAAE,EAAEV,GAAG;MAAEtC,CAAC,EAAEpB,GAAG,CAACwD,GAAG,EAAEE,GAAG;IAAC,CAAC,GAAG;MAACtC,CAAC;MAAE+C,EAAE;MAAEC;IAAE,CAAC,CAAC,CAAC;IAC3F,IAAIP,EAAE,IAAI;MAAC,CAACD,EAAE,GAAGC;IAAE,CAAC,CAAC;IACrB,GAAG0C,MAAM,CAACC,WAAW,CAACrF,OAAO,CAAC1B,GAAG,CAAC,CAAC;MAACgH,IAAI;MAAEC;IAAM,CAAC,KAAK,CAACD,IAAI,EAAEC,MAAM,CAAC,CAAC;EACvE,CAAC;AACH;;AAEA;AACA,SAASpF,YAAYA,CAAC;EAACgD,UAAU;EAAED,MAAM;EAAEE,UAAU;EAAEvC,QAAQ;EAAE,GAAGb;AAAO,CAAC,EAAEE,OAAO,EAAE;EACrF,OAAO,CAACF,OAAO,EAAE;IAACmD,UAAU;IAAED,MAAM;IAAEE,UAAU;IAAEvC,QAAQ;IAAE,GAAGX;EAAO,CAAC,CAAC;AAC1E;AAEA,SAASI,aAAaA,CAACkF,KAAK,EAAE;EAACrC,UAAU;EAAED,MAAM;EAAEE,UAAU;EAAEvC;AAAQ,CAAC,EAAE4E,YAAY,EAAE;EACtFD,KAAK,GAAG;IAAC,GAAG5G,UAAU,CAAC4G,KAAK;EAAC,CAAC;EAC9B,IAAIA,KAAK,CAACtC,MAAM,KAAKpB,SAAS,EAAE0D,KAAK,CAACtC,MAAM,GAAGA,MAAM;EACrD,IAAIsC,KAAK,CAACrC,UAAU,KAAKrB,SAAS,EAAE0D,KAAK,CAACrC,UAAU,GAAGA,UAAU;EACjE,IAAIqC,KAAK,CAACpC,UAAU,KAAKtB,SAAS,EAAE0D,KAAK,CAACpC,UAAU,GAAGA,UAAU;EACjE,IAAIoC,KAAK,CAAC3E,QAAQ,KAAKiB,SAAS,EAAE0D,KAAK,CAAC3E,QAAQ,GAAGA,QAAQ;EAC3D,IAAI2E,KAAK,CAACA,KAAK,KAAK1D,SAAS,EAAE0D,KAAK,CAACA,KAAK,GAAGC,YAAY;EACzDD,KAAK,CAACpC,UAAU,GAAGsC,eAAe,CAACF,KAAK,CAACpC,UAAU,EAAEoC,KAAK,CAAC3E,QAAQ,CAAC;EACpE,OAAO2E,KAAK;AACd;AAEA,SAAS9E,kBAAkBA,CAACR,OAAO,EAAE;EACnC,IAAI;IAACE,CAAC;IAAEH;EAAC,CAAC,GAAGC,OAAO;EACpBE,CAAC,GAAGE,aAAa,CAACF,CAAC,EAAEF,OAAO,CAAC;EAC7BD,CAAC,GAAGK,aAAa,CAACL,CAAC,EAAEC,OAAO,CAAC;EAC7B,CAACE,CAAC,CAACoF,KAAK,EAAEvF,CAAC,CAACuF,KAAK,CAAC,GAAG7G,UAAU,CAACyB,CAAC,CAACoF,KAAK,EAAEvF,CAAC,CAACuF,KAAK,CAAC;EACjD,OAAO;IAACpF,CAAC;IAAEH;EAAC,CAAC;AACf;AAEA,SAAS0B,QAAQA,CAACzB,OAAO,EAAE;EACzB,IAAIA,OAAO,IAAI,IAAI,EAAE;EACrB,MAAM;IAACsF,KAAK;IAAErC,UAAU;IAAED,MAAM,GAAG5F,MAAM;IAAE8F;EAAU,CAAC,GAAGlD,OAAO;EAChE,MAAMM,GAAG,GAAIc,IAAI,IAAK;IACpB,IAAIqE,CAAC,GAAG7G,OAAO,CAACwC,IAAI,EAAEkE,KAAK,CAAC;IAC5B,IAAII,CAAC,CAAC,CAAC;IACP,IAAIzH,UAAU,CAACwH,CAAC,CAAC,IAAIE,gBAAgB,CAACzC,UAAU,CAAC,EAAE;MACjDuC,CAAC,GAAGrH,GAAG,CAACqH,CAAC,EAAE7H,UAAU,EAAEgI,YAAY,CAAC,CAAC,CAAC;MACtC,IAAI,CAACC,GAAG,EAAEC,GAAG,CAAC,GAAG,OAAO9C,MAAM,KAAK,UAAU,GAAGA,MAAM,CAACyC,CAAC,CAAC,GAAGzC,MAAM;MAClE,IAAI+C,CAAC,GAAG,OAAO7C,UAAU,KAAK,UAAU,IAAI,CAACnF,UAAU,CAACmF,UAAU,CAAC,GAAGA,UAAU,CAACuC,CAAC,EAAEI,GAAG,EAAEC,GAAG,CAAC,GAAG5C,UAAU;MAC1G,IAAI,OAAO6C,CAAC,KAAK,QAAQ,EAAEA,CAAC,GAAGrI,eAAe,CAACmI,GAAG,EAAEC,GAAG,EAAEC,CAAC,CAAC;MAC3D,IAAIhI,UAAU,CAACgI,CAAC,CAAC,EAAE;QACjB,IAAI/C,MAAM,KAAK5F,MAAM,EAAE;UACrByI,GAAG,GAAGE,CAAC,CAACC,KAAK,CAACH,GAAG,CAAC;UAClBC,GAAG,GAAGC,CAAC,CAACE,MAAM,CAACF,CAAC,CAACC,KAAK,CAACF,GAAG,CAAC,CAAC;QAC9B;QACAC,CAAC,GAAGA,CAAC,CAACG,KAAK,CAACL,GAAG,EAAEE,CAAC,CAACE,MAAM,CAACH,GAAG,CAAC,CAAC;MACjC;MACAJ,CAAC,GAAGK,CAAC;IACP,CAAC,MAAM;MACLN,CAAC,GAAG5H,aAAa,CAAC4H,CAAC,CAAC;MACpB,IAAI,CAACI,GAAG,EAAEC,GAAG,CAAC,GAAG,OAAO9C,MAAM,KAAK,UAAU,GAAGA,MAAM,CAACyC,CAAC,CAAC,GAAGzC,MAAM;MAClE,IAAI+C,CAAC,GAAG,OAAO7C,UAAU,KAAK,UAAU,IAAI,CAACnF,UAAU,CAACmF,UAAU,CAAC,GAAGA,UAAU,CAACuC,CAAC,EAAEI,GAAG,EAAEC,GAAG,CAAC,GAAG5C,UAAU;MAC1G,IAAI,OAAO6C,CAAC,KAAK,QAAQ,EAAE;QACzB;QACA;QACA;QACA,IAAI/C,MAAM,KAAK5F,MAAM,EAAE;UACrB,IAAI+I,IAAI,GAAG3I,aAAa,CAACqI,GAAG,EAAEC,GAAG,EAAEC,CAAC,CAAC;UACrC,IAAIK,QAAQ,CAACD,IAAI,CAAC,EAAE;YAClB,IAAIA,IAAI,GAAG,CAAC,EAAE;cACZ,IAAIE,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACV,GAAG,GAAGM,IAAI,CAAC;cAC/B,IAAIK,EAAE,GAAGF,IAAI,CAACC,KAAK,CAACT,GAAG,GAAGK,IAAI,CAAC;cAC/B,IAAI,EAAEE,EAAE,GAAGF,IAAI,IAAIN,GAAG,CAAC,EAAE,EAAEQ,EAAE;cAC7B,IAAI,EAAEG,EAAE,GAAGL,IAAI,GAAGL,GAAG,CAAC,EAAE,EAAEU,EAAE;cAC5B,IAAIC,CAAC,GAAGD,EAAE,GAAGH,EAAE,GAAG,CAAC;cACnBN,CAAC,GAAG,IAAIH,YAAY,CAACa,CAAC,CAAC;cACvB,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,CAAC,EAAE,EAAEpC,CAAC,EAAE0B,CAAC,CAAC1B,CAAC,CAAC,GAAG,CAACgC,EAAE,GAAGhC,CAAC,IAAI8B,IAAI;YACpD,CAAC,MAAM,IAAIA,IAAI,GAAG,CAAC,EAAE;cACnBA,IAAI,GAAG,CAACA,IAAI;cACZ,IAAIE,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACV,GAAG,GAAGM,IAAI,CAAC;cAC/B,IAAIK,EAAE,GAAGF,IAAI,CAACC,KAAK,CAACT,GAAG,GAAGK,IAAI,CAAC;cAC/B,IAAI,EAAEE,EAAE,GAAGF,IAAI,IAAIN,GAAG,CAAC,EAAE,EAAEQ,EAAE;cAC7B,IAAI,EAAEG,EAAE,GAAGL,IAAI,GAAGL,GAAG,CAAC,EAAE,EAAEU,EAAE;cAC5B,IAAIC,CAAC,GAAGD,EAAE,GAAGH,EAAE,GAAG,CAAC;cACnBN,CAAC,GAAG,IAAIH,YAAY,CAACa,CAAC,CAAC;cACvB,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,CAAC,EAAE,EAAEpC,CAAC,EAAE0B,CAAC,CAAC1B,CAAC,CAAC,GAAG,CAACgC,EAAE,GAAGhC,CAAC,IAAI8B,IAAI;YACpD,CAAC,MAAM;cACLJ,CAAC,GAAG,CAACF,GAAG,CAAC;YACX;UACF,CAAC,MAAM;YACLE,CAAC,GAAG,CAACF,GAAG,CAAC;UACX;QACF,CAAC,MAAM;UACLE,CAAC,GAAGtI,KAAK,CAACoI,GAAG,EAAEC,GAAG,EAAEC,CAAC,CAAC;QACxB;MACF,CAAC,MAAM,IAAIhI,UAAU,CAACgI,CAAC,CAAC,EAAE;QACxB,IAAI/C,MAAM,KAAK5F,MAAM,EAAE;UACrByI,GAAG,GAAGE,CAAC,CAACC,KAAK,CAACH,GAAG,CAAC;UAClBC,GAAG,GAAGC,CAAC,CAACE,MAAM,CAACF,CAAC,CAACC,KAAK,CAACF,GAAG,CAAC,CAAC;QAC9B;QACAC,CAAC,GAAGA,CAAC,CAACG,KAAK,CAACL,GAAG,EAAEE,CAAC,CAACE,MAAM,CAACH,GAAG,CAAC,CAAC;MACjC;MACAJ,CAAC,GAAGK,CAAC;IACP;IACA,MAAMW,CAAC,GAAG,EAAE;IACZ,IAAIhB,CAAC,CAACT,MAAM,KAAK,CAAC,EAAEyB,CAAC,CAAC3B,IAAI,CAAC,CAACW,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAAA,KACrC,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,CAAC,CAACT,MAAM,EAAE,EAAEZ,CAAC,EAAEqC,CAAC,CAAC3B,IAAI,CAAC,CAACW,CAAC,CAACrB,CAAC,GAAG,CAAC,CAAC,EAAEqB,CAAC,CAACrB,CAAC,CAAC,CAAC,CAAC;IAChEqC,CAAC,CAACpG,GAAG,GAAG,CAAC2C,UAAU,GAAG,CAAC,GAAG0D,MAAM,GAAG1D,UAAU,GAAG,CAAC,GAAG2D,MAAM,GAAGC,IAAI,EAAEH,CAAC,EAAEhB,CAAC,EAAED,CAAC,CAAC;IAC3E,OAAOiB,CAAC;EACV,CAAC;EACDpG,GAAG,CAACwG,KAAK,GAAG3I,OAAO,CAACmH,KAAK,CAAC;EAC1B,OAAOhF,GAAG;AACZ;AAEA,OAAO,SAASkF,eAAeA,CAACtC,UAAU,EAAEvC,QAAQ,EAAEoG,iBAAiB,GAAGC,aAAa,EAAE;EACvF,IAAI9D,UAAU,KAAKtB,SAAS,EAAE;IAC5B,OAAOjB,QAAQ,KAAKiB,SAAS,GAAGmF,iBAAiB,GAAGvI,kBAAkB,CAACmC,QAAQ,CAAC;EAClF;EACA,IAAI,OAAOuC,UAAU,KAAK,QAAQ,EAAE;IAClC,QAAQA,UAAU,CAAC+D,WAAW,CAAC,CAAC;MAC9B,KAAK,mBAAmB;QACtB,OAAO5J,yBAAyB;MAClC,KAAK,OAAO;QACV,OAAOC,cAAc;MACvB,KAAK,SAAS;QACZ,OAAOC,gBAAgB;MACzB,KAAK,MAAM;QACT,OAAOyJ,aAAa;IACxB;IACA,OAAOnI,WAAW,CAACqE,UAAU,CAAC;EAChC;EACA,OAAOA,UAAU,CAAC,CAAC;AACrB;;AAEA,SAASxB,eAAeA,CAAC5B,OAAO,EAAE0B,MAAM,EAAE;EACxC,OAAOrC,YAAY,CAACW,OAAO,EAAE0B,MAAM,EAAEK,cAAc,CAAC;AACtD;AAEA,SAASA,cAAcA,CAACuD,IAAI,EAAExE,MAAM,EAAEY,MAAM,EAAE;EAC5C,OAAOtC,WAAW,CAACkG,IAAI,EAAExE,MAAM,EAAEY,MAAM,EAAEM,iBAAiB,CAAC;AAC7D;AAEA,SAASA,iBAAiBA,CAACsD,IAAI,EAAExE,MAAM,EAAEY,MAAM,EAAE;EAC/C,OAAOxC,cAAc,CAACoG,IAAI,EAAExE,MAAM,EAAEY,MAAM,EAAEG,cAAc,CAAC;AAC7D;AAEA,SAASA,cAAcA,CAACf,MAAM,EAAE0E,KAAK,EAAE;EACrC,OAAOlG,WAAW,CAACwB,MAAM,EAAE0E,KAAK,EAAE4B,sBAAsB,CAAC;AAC3D;AAEA,SAASA,sBAAsBA,CAACtG,MAAM,EAAE;EACtC,QAAS,GAAEA,MAAO,EAAC,CAACqG,WAAW,CAAC,CAAC;IAC/B,KAAK,GAAG;MACN,OAAOE,OAAO;IAChB,KAAK,IAAI;MACP,OAAOC,QAAQ;IACjB,KAAK,IAAI;MACP,OAAOC,QAAQ;IACjB,KAAK,GAAG;MACN,OAAOC,OAAO;IAChB,KAAK,IAAI;MACP,OAAOC,QAAQ;IACjB,KAAK,IAAI;MACP,OAAOC,QAAQ;IACjB,KAAK,GAAG;MACN,OAAO9H,OAAO;EAClB;EACA,MAAM,IAAI+H,KAAK,CAAE,uBAAsB7G,MAAO,EAAC,CAAC;AAClD;AAEA,SAASoG,aAAaA,CAACU,MAAM,EAAE7B,GAAG,EAAEC,GAAG,EAAE;EACvC,OAAOQ,IAAI,CAACT,GAAG,CAAC,GAAG,EAAEvI,cAAc,CAACoK,MAAM,EAAE7B,GAAG,EAAEC,GAAG,CAAC,CAAC;AACxD;AAEA,SAASH,gBAAgBA,CAACI,CAAC,EAAE;EAC3B,OAAO7H,cAAc,CAAC6H,CAAC,CAAC,IAAK/H,UAAU,CAAC+H,CAAC,CAAC,IAAI9H,UAAU,CAAC8H,CAAC,CAAE;AAC9D;AAEA,SAAS3B,IAAIA,CAACpD,EAAE,EAAEC,EAAE,EAAEG,IAAI,EAAE;EAC1B,MAAMuG,EAAE,GAAG3G,EAAE,GAAGI,IAAI,CAAC;EACrB,MAAMwG,EAAE,GAAG3G,EAAE,GAAGG,IAAI,CAAC;EACrB,OAAOuG,EAAE,IAAIC,EAAE,GACX,WAAWhD,CAAC,EAAE;IACZ,MAAMiD,CAAC,GAAGF,EAAE,CAACrH,GAAG,CAACsE,CAAC,CAAC,CAAC,CAAC;IACrB,KAAK,MAAM,CAACkD,EAAE,EAAE,CAAClF,EAAE,EAAEC,EAAE,CAAC,CAAC,IAAI8E,EAAE,CAACI,OAAO,CAAC,CAAC,EAAE;MACzC,MAAMC,CAAC,GAAGJ,EAAE,CAACtH,GAAG,CAACuH,CAAC,CAACC,EAAE,CAAC,CAAC,CAAC,CAAC;MACzB,KAAK,MAAM,CAACG,EAAE,EAAE,CAACnF,EAAE,EAAEC,EAAE,CAAC,CAAC,IAAI6E,EAAE,CAACG,OAAO,CAAC,CAAC,EAAE;QACzC,MAAM,CAACC,CAAC,CAACC,EAAE,CAAC,EAAE;UAAC7G,IAAI;UAAEwB,EAAE;UAAEE,EAAE;UAAED,EAAE;UAAEE;QAAE,CAAC,CAAC;MACvC;IACF;EACF,CAAC,GACD4E,EAAE,GACF,WAAW/C,CAAC,EAAE;IACZ,MAAMiD,CAAC,GAAGF,EAAE,CAACrH,GAAG,CAACsE,CAAC,CAAC;IACnB,KAAK,MAAM,CAACP,CAAC,EAAE,CAACzB,EAAE,EAAEC,EAAE,CAAC,CAAC,IAAI8E,EAAE,CAACI,OAAO,CAAC,CAAC,EAAE;MACxC,MAAM,CAACF,CAAC,CAACxD,CAAC,CAAC,EAAE;QAACjD,IAAI;QAAEwB,EAAE;QAAEC;MAAE,CAAC,CAAC;IAC9B;EACF,CAAC,GACD,WAAW+B,CAAC,EAAE;IACZ,MAAMoD,CAAC,GAAGJ,EAAE,CAACtH,GAAG,CAACsE,CAAC,CAAC;IACnB,KAAK,MAAM,CAACP,CAAC,EAAE,CAACvB,EAAE,EAAEC,EAAE,CAAC,CAAC,IAAI6E,EAAE,CAACG,OAAO,CAAC,CAAC,EAAE;MACxC,MAAM,CAACC,CAAC,CAAC3D,CAAC,CAAC,EAAE;QAACjD,IAAI;QAAE0B,EAAE;QAAEC;MAAE,CAAC,CAAC;IAC9B;EACF,CAAC;AACP;;AAEA;AACA,SAAS8D,IAAIA,CAACH,CAAC,EAAEhB,CAAC,EAAED,CAAC,EAAE;EACrBC,CAAC,GAAG7H,aAAa,CAAC6H,CAAC,CAAC,CAAC,CAAC;EACtB,OAAQd,CAAC,IAAK;IACZ,MAAMsD,CAAC,GAAGxB,CAAC,CAACtI,GAAG,CAAC,MAAM,EAAE,CAAC;IACzB,KAAK,MAAMiG,CAAC,IAAIO,CAAC,EAAEsD,CAAC,CAAC/K,MAAM,CAACuI,CAAC,EAAED,CAAC,CAACpB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAEU,IAAI,CAACV,CAAC,CAAC,CAAC,CAAC;IACpD,OAAO6D,CAAC;EACV,CAAC;AACH;;AAEA;AACA,SAAStB,MAAMA,CAACF,CAAC,EAAEhB,CAAC,EAAED,CAAC,EAAE;EACvB,MAAMnF,GAAG,GAAGuG,IAAI,CAACH,CAAC,EAAEhB,CAAC,EAAED,CAAC,CAAC;EACzB,OAAQb,CAAC,IAAK;IACZ,MAAMsD,CAAC,GAAG5H,GAAG,CAACsE,CAAC,CAAC;IAChB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEoC,CAAC,GAAGyB,CAAC,CAACjD,MAAM,EAAEZ,CAAC,GAAGoC,CAAC,EAAE,EAAEpC,CAAC,EAAE;MACxC,MAAM8D,CAAC,GAAGD,CAAC,CAAC7D,CAAC,GAAG,CAAC,CAAC;MAClB,MAAMS,CAAC,GAAGoD,CAAC,CAAC7D,CAAC,CAAC;MACd,KAAK,MAAM+D,CAAC,IAAID,CAAC,EAAErD,CAAC,CAACC,IAAI,CAACqD,CAAC,CAAC;IAC9B;IACA,OAAOF,CAAC;EACV,CAAC;AACH;;AAEA;AACA,SAASvB,MAAMA,CAACD,CAAC,EAAEhB,CAAC,EAAED,CAAC,EAAE;EACvB,MAAMnF,GAAG,GAAGuG,IAAI,CAACH,CAAC,EAAEhB,CAAC,EAAED,CAAC,CAAC;EACzB,OAAQb,CAAC,IAAK;IACZ,MAAMsD,CAAC,GAAG5H,GAAG,CAACsE,CAAC,CAAC;IAChB,KAAK,IAAIP,CAAC,GAAG6D,CAAC,CAACjD,MAAM,GAAG,CAAC,EAAEZ,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MACtC,MAAM8D,CAAC,GAAGD,CAAC,CAAC7D,CAAC,GAAG,CAAC,CAAC;MAClB,MAAMS,CAAC,GAAGoD,CAAC,CAAC7D,CAAC,CAAC;MACd,KAAK,MAAM+D,CAAC,IAAID,CAAC,EAAErD,CAAC,CAACC,IAAI,CAACqD,CAAC,CAAC;IAC9B;IACA,OAAOF,CAAC;EACV,CAAC;AACH;AAEA,SAASG,IAAIA,CAACzF,EAAE,EAAEC,EAAE,EAAE;EACpB,MAAMyF,CAAC,GAAG,CAAC,CAAC1F,EAAE,GAAG,CAACC,EAAE,IAAI,CAAC;EACzB,OAAOD,EAAE,YAAY2F,IAAI,GAAG,IAAIA,IAAI,CAACD,CAAC,CAAC,GAAGA,CAAC;AAC7C;AAEA,MAAMnB,OAAO,GAAG;EACdnC,WAAWA,CAACJ,CAAC,EAAEiD,CAAC,EAAE;IAACjF,EAAE;IAAEC;EAAE,CAAC,EAAE;IAC1B,OAAOwF,IAAI,CAACzF,EAAE,EAAEC,EAAE,CAAC;EACrB;AACF,CAAC;AAED,MAAMyE,OAAO,GAAG;EACdtC,WAAWA,CAACJ,CAAC,EAAEiD,CAAC,EAAE;IAAC/E,EAAE;IAAEC;EAAE,CAAC,EAAE;IAC1B,OAAOsF,IAAI,CAACvF,EAAE,EAAEC,EAAE,CAAC;EACrB;AACF,CAAC;AAED,MAAMqE,QAAQ,GAAG;EACfpC,WAAWA,CAACJ,CAAC,EAAEiD,CAAC,EAAE;IAACjF;EAAE,CAAC,EAAE;IACtB,OAAOA,EAAE;EACX;AACF,CAAC;AAED,MAAMyE,QAAQ,GAAG;EACfrC,WAAWA,CAACJ,CAAC,EAAEiD,CAAC,EAAE;IAAChF;EAAE,CAAC,EAAE;IACtB,OAAOA,EAAE;EACX;AACF,CAAC;AAED,MAAM0E,QAAQ,GAAG;EACfvC,WAAWA,CAACJ,CAAC,EAAEiD,CAAC,EAAE;IAAC/E;EAAE,CAAC,EAAE;IACtB,OAAOA,EAAE;EACX;AACF,CAAC;AAED,MAAM0E,QAAQ,GAAG;EACfxC,WAAWA,CAACJ,CAAC,EAAEiD,CAAC,EAAE;IAAC9E;EAAE,CAAC,EAAE;IACtB,OAAOA,EAAE;EACX;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}