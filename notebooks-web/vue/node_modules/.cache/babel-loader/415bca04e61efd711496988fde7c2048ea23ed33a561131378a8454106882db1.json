{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { greatest, group, least } from \"d3\";\nimport { maybeZ, valueof } from \"../options.js\";\nimport { basic } from \"./basic.js\";\nexport function select(selector, options = {}) {\n  // If specified selector is a string or function, it’s a selector without an\n  // input channel such as first or last.\n  if (typeof selector === \"string\") {\n    switch (selector.toLowerCase()) {\n      case \"first\":\n        return selectFirst(options);\n      case \"last\":\n        return selectLast(options);\n    }\n  }\n  if (typeof selector === \"function\") {\n    return selectChannel(null, selector, options);\n  }\n  // Otherwise the selector is an option {name: value} where name is a channel\n  // name and value is a selector definition that additionally takes the given\n  // channel values as input. The selector object must have exactly one key.\n  let key, value;\n  for (key in selector) {\n    if (value !== undefined) throw new Error(\"ambiguous selector; multiple inputs\");\n    value = maybeSelector(selector[key]);\n  }\n  if (value === undefined) throw new Error(`invalid selector: ${selector}`);\n  return selectChannel(key, value, options);\n}\nfunction maybeSelector(selector) {\n  if (typeof selector === \"function\") return selector;\n  switch (`${selector}`.toLowerCase()) {\n    case \"min\":\n      return selectorMin;\n    case \"max\":\n      return selectorMax;\n  }\n  throw new Error(`unknown selector: ${selector}`);\n}\nexport function selectFirst(options) {\n  return selectChannel(null, selectorFirst, options);\n}\nexport function selectLast(options) {\n  return selectChannel(null, selectorLast, options);\n}\nexport function selectMinX(options) {\n  return selectChannel(\"x\", selectorMin, options);\n}\nexport function selectMinY(options) {\n  return selectChannel(\"y\", selectorMin, options);\n}\nexport function selectMaxX(options) {\n  return selectChannel(\"x\", selectorMax, options);\n}\nexport function selectMaxY(options) {\n  return selectChannel(\"y\", selectorMax, options);\n}\nfunction* selectorFirst(I) {\n  yield I[0];\n}\nfunction* selectorLast(I) {\n  yield I[I.length - 1];\n}\nfunction* selectorMin(I, X) {\n  yield least(I, i => X[i]);\n}\nfunction* selectorMax(I, X) {\n  yield greatest(I, i => X[i]);\n}\nfunction selectChannel(v, selector, options) {\n  if (v != null) {\n    if (options[v] == null) throw new Error(`missing channel: ${v}`);\n    v = options[v];\n  }\n  const z = maybeZ(options);\n  return basic(options, (data, facets) => {\n    const Z = valueof(data, z);\n    const V = valueof(data, v);\n    const selectFacets = [];\n    for (const facet of facets) {\n      const selectFacet = [];\n      for (const I of Z ? group(facet, i => Z[i]).values() : [facet]) {\n        for (const i of selector(I, V)) {\n          selectFacet.push(i);\n        }\n      }\n      selectFacets.push(selectFacet);\n    }\n    return {\n      data,\n      facets: selectFacets\n    };\n  });\n}","map":{"version":3,"names":["greatest","group","least","maybeZ","valueof","basic","select","selector","options","toLowerCase","selectFirst","selectLast","selectChannel","key","value","undefined","Error","maybeSelector","selectorMin","selectorMax","selectorFirst","selectorLast","selectMinX","selectMinY","selectMaxX","selectMaxY","I","length","X","i","v","z","data","facets","Z","V","selectFacets","facet","selectFacet","values","push"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/select.js"],"sourcesContent":["import {greatest, group, least} from \"d3\";\nimport {maybeZ, valueof} from \"../options.js\";\nimport {basic} from \"./basic.js\";\n\nexport function select(selector, options = {}) {\n  // If specified selector is a string or function, it’s a selector without an\n  // input channel such as first or last.\n  if (typeof selector === \"string\") {\n    switch (selector.toLowerCase()) {\n      case \"first\":\n        return selectFirst(options);\n      case \"last\":\n        return selectLast(options);\n    }\n  }\n  if (typeof selector === \"function\") {\n    return selectChannel(null, selector, options);\n  }\n  // Otherwise the selector is an option {name: value} where name is a channel\n  // name and value is a selector definition that additionally takes the given\n  // channel values as input. The selector object must have exactly one key.\n  let key, value;\n  for (key in selector) {\n    if (value !== undefined) throw new Error(\"ambiguous selector; multiple inputs\");\n    value = maybeSelector(selector[key]);\n  }\n  if (value === undefined) throw new Error(`invalid selector: ${selector}`);\n  return selectChannel(key, value, options);\n}\n\nfunction maybeSelector(selector) {\n  if (typeof selector === \"function\") return selector;\n  switch (`${selector}`.toLowerCase()) {\n    case \"min\":\n      return selectorMin;\n    case \"max\":\n      return selectorMax;\n  }\n  throw new Error(`unknown selector: ${selector}`);\n}\n\nexport function selectFirst(options) {\n  return selectChannel(null, selectorFirst, options);\n}\n\nexport function selectLast(options) {\n  return selectChannel(null, selectorLast, options);\n}\n\nexport function selectMinX(options) {\n  return selectChannel(\"x\", selectorMin, options);\n}\n\nexport function selectMinY(options) {\n  return selectChannel(\"y\", selectorMin, options);\n}\n\nexport function selectMaxX(options) {\n  return selectChannel(\"x\", selectorMax, options);\n}\n\nexport function selectMaxY(options) {\n  return selectChannel(\"y\", selectorMax, options);\n}\n\nfunction* selectorFirst(I) {\n  yield I[0];\n}\n\nfunction* selectorLast(I) {\n  yield I[I.length - 1];\n}\n\nfunction* selectorMin(I, X) {\n  yield least(I, (i) => X[i]);\n}\n\nfunction* selectorMax(I, X) {\n  yield greatest(I, (i) => X[i]);\n}\n\nfunction selectChannel(v, selector, options) {\n  if (v != null) {\n    if (options[v] == null) throw new Error(`missing channel: ${v}`);\n    v = options[v];\n  }\n  const z = maybeZ(options);\n  return basic(options, (data, facets) => {\n    const Z = valueof(data, z);\n    const V = valueof(data, v);\n    const selectFacets = [];\n    for (const facet of facets) {\n      const selectFacet = [];\n      for (const I of Z ? group(facet, (i) => Z[i]).values() : [facet]) {\n        for (const i of selector(I, V)) {\n          selectFacet.push(i);\n        }\n      }\n      selectFacets.push(selectFacet);\n    }\n    return {data, facets: selectFacets};\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}