{"ast":null,"code":"import { create } from \"../context.js\";\nimport { Mark } from \"../mark.js\";\nimport { number, singleton } from \"../options.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform, offset } from \"../style.js\";\nimport { sqrt4_3 } from \"../symbol.js\";\nimport { ox, oy } from \"../transforms/hexbin.js\";\nconst defaults = {\n  ariaLabel: \"hexgrid\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeOpacity: 0.1\n};\nexport function hexgrid(options) {\n  return new Hexgrid(options);\n}\nexport class Hexgrid extends Mark {\n  constructor({\n    binWidth = 20,\n    clip = true,\n    ...options\n  } = {}) {\n    super(singleton, undefined, {\n      clip,\n      ...options\n    }, defaults);\n    this.binWidth = number(binWidth);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      binWidth\n    } = this;\n    const {\n      marginTop,\n      marginRight,\n      marginBottom,\n      marginLeft,\n      width,\n      height\n    } = dimensions;\n    const x0 = marginLeft - ox,\n      x1 = width - marginRight - ox,\n      y0 = marginTop - oy,\n      y1 = height - marginBottom - oy,\n      rx = binWidth / 2,\n      ry = rx * sqrt4_3,\n      hy = ry / 2,\n      wx = rx * 2,\n      wy = ry * 1.5,\n      i0 = Math.floor(x0 / wx),\n      i1 = Math.ceil(x1 / wx),\n      j0 = Math.floor((y0 + hy) / wy),\n      j1 = Math.ceil((y1 - hy) / wy) + 1,\n      path = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;\n    let d = path;\n    for (let j = j0; j < j1; ++j) {\n      for (let i = i0; i < i1; ++i) {\n        d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path}`;\n      }\n    }\n    return create(\"svg:g\", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call(g => g.append(\"path\").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr(\"d\", d)).node();\n  }\n}\nfunction round(x) {\n  return Math.round(x * 1e3) / 1e3;\n}","map":{"version":3,"names":["create","Mark","number","singleton","applyChannelStyles","applyDirectStyles","applyIndirectStyles","applyTransform","offset","sqrt4_3","ox","oy","defaults","ariaLabel","fill","stroke","strokeOpacity","hexgrid","options","Hexgrid","constructor","binWidth","clip","undefined","render","index","scales","channels","dimensions","context","marginTop","marginRight","marginBottom","marginLeft","width","height","x0","x1","y0","y1","rx","ry","hy","wx","wy","i0","Math","floor","i1","ceil","j0","j1","path","round","d","j","i","datum","call","g","append","attr","node","x"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/hexgrid.js"],"sourcesContent":["import {create} from \"../context.js\";\nimport {Mark} from \"../mark.js\";\nimport {number, singleton} from \"../options.js\";\nimport {applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform, offset} from \"../style.js\";\nimport {sqrt4_3} from \"../symbol.js\";\nimport {ox, oy} from \"../transforms/hexbin.js\";\n\nconst defaults = {\n  ariaLabel: \"hexgrid\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeOpacity: 0.1\n};\n\nexport function hexgrid(options) {\n  return new Hexgrid(options);\n}\n\nexport class Hexgrid extends Mark {\n  constructor({binWidth = 20, clip = true, ...options} = {}) {\n    super(singleton, undefined, {clip, ...options}, defaults);\n    this.binWidth = number(binWidth);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {binWidth} = this;\n    const {marginTop, marginRight, marginBottom, marginLeft, width, height} = dimensions;\n    const x0 = marginLeft - ox,\n      x1 = width - marginRight - ox,\n      y0 = marginTop - oy,\n      y1 = height - marginBottom - oy,\n      rx = binWidth / 2,\n      ry = rx * sqrt4_3,\n      hy = ry / 2,\n      wx = rx * 2,\n      wy = ry * 1.5,\n      i0 = Math.floor(x0 / wx),\n      i1 = Math.ceil(x1 / wx),\n      j0 = Math.floor((y0 + hy) / wy),\n      j1 = Math.ceil((y1 - hy) / wy) + 1,\n      path = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;\n    let d = path;\n    for (let j = j0; j < j1; ++j) {\n      for (let i = i0; i < i1; ++i) {\n        d += `M${round(i * wx + (j & 1) * rx)},${round(j * wy)}${path}`;\n      }\n    }\n    return create(\"svg:g\", context)\n      .datum(0)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {}, offset + ox, offset + oy)\n      .call((g) => g.append(\"path\").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr(\"d\", d))\n      .node();\n  }\n}\n\nfunction round(x) {\n  return Math.round(x * 1e3) / 1e3;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}