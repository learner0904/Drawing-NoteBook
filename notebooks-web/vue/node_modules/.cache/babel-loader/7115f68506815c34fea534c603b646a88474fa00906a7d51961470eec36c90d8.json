{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { InternSet, rollups } from \"d3\";\nimport { ascendingDefined, descendingDefined } from \"./defined.js\";\nimport { first, isColor, isEvery, isIterable, isOpacity, labelof, map, maybeValue, range, valueof } from \"./options.js\";\nimport { registry } from \"./scales/index.js\";\nimport { isSymbol, maybeSymbol } from \"./symbol.js\";\nimport { maybeReduce } from \"./transforms/group.js\";\nexport function createChannel(data, {\n  scale,\n  type,\n  value,\n  filter,\n  hint,\n  label = labelof(value)\n}, name) {\n  if (hint === undefined && typeof value?.transform === \"function\") hint = value.hint;\n  return inferChannelScale(name, {\n    scale,\n    type,\n    value: valueof(data, value),\n    label,\n    filter,\n    hint\n  });\n}\nexport function createChannels(channels, data) {\n  return Object.fromEntries(Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)]));\n}\n\n// TODO Use Float64Array for scales with numeric ranges, e.g. position?\nexport function valueObject(channels, scales) {\n  const values = Object.fromEntries(Object.entries(channels).map(([name, {\n    scale: scaleName,\n    value\n  }]) => {\n    const scale = scaleName == null ? null : scales[scaleName];\n    return [name, scale == null ? value : map(value, scale)];\n  }));\n  values.channels = channels; // expose channel state for advanced usage\n  return values;\n}\n\n// If the channel uses the \"auto\" scale (or equivalently true), infer the scale\n// from the channel name and the provided values. For color and symbol channels,\n// no scale is applied if the values are literal; however for symbols, we must\n// promote symbol names (e.g., \"plus\") to symbol implementations (symbolPlus).\n// Note: mutates channel!\nexport function inferChannelScale(name, channel) {\n  const {\n    scale,\n    value\n  } = channel;\n  if (scale === true || scale === \"auto\") {\n    switch (name) {\n      case \"fill\":\n      case \"stroke\":\n      case \"color\":\n        channel.scale = scale !== true && isEvery(value, isColor) ? null : \"color\";\n        channel.defaultScale = \"color\";\n        break;\n      case \"fillOpacity\":\n      case \"strokeOpacity\":\n      case \"opacity\":\n        channel.scale = scale !== true && isEvery(value, isOpacity) ? null : \"opacity\";\n        channel.defaultScale = \"opacity\";\n        break;\n      case \"symbol\":\n        if (scale !== true && isEvery(value, isSymbol)) {\n          channel.scale = null;\n          channel.value = map(value, maybeSymbol);\n        } else {\n          channel.scale = \"symbol\";\n        }\n        channel.defaultScale = \"symbol\";\n        break;\n      default:\n        channel.scale = registry.has(name) ? name : null;\n        break;\n    }\n  } else if (scale === false) {\n    channel.scale = null;\n  } else if (scale != null && !registry.has(scale)) {\n    throw new Error(`unknown scale: ${scale}`);\n  }\n  return channel;\n}\n\n// Note: mutates channel.domain! This is set to a function so that it is lazily\n// computed; i.e., if the scale’s domain is set explicitly, that takes priority\n// over the sort option, and we don’t need to do additional work.\nexport function channelDomain(data, facets, channels, facetChannels, options) {\n  const {\n    order: defaultOrder,\n    reverse: defaultReverse,\n    reduce: defaultReduce = true,\n    limit: defaultLimit\n  } = options;\n  for (const x in options) {\n    if (!registry.has(x)) continue; // ignore unknown scale keys (including generic options)\n    let {\n      value: y,\n      order = defaultOrder,\n      reverse = defaultReverse,\n      reduce = defaultReduce,\n      limit = defaultLimit\n    } = maybeValue(options[x]); // prettier-ignore\n    const negate = y?.startsWith(\"-\");\n    if (negate) y = y.slice(1);\n    order = order === undefined ? negate !== (y === \"width\" || y === \"height\") ? descendingGroup : ascendingGroup : maybeOrder(order); // prettier-ignore\n    if (reduce == null || reduce === false) continue; // disabled reducer\n    const X = x === \"fx\" || x === \"fy\" ? reindexFacetChannel(facets, facetChannels[x]) : findScaleChannel(channels, x);\n    if (!X) throw new Error(`missing channel for scale: ${x}`);\n    const XV = X.value;\n    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];\n    if (y == null) {\n      X.domain = () => {\n        let domain = Array.from(new InternSet(XV)); // remove any duplicates\n        if (reverse) domain = domain.reverse();\n        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);\n        return domain;\n      };\n    } else {\n      const YV = y === \"data\" ? data : y === \"height\" ? difference(channels, \"y1\", \"y2\") : y === \"width\" ? difference(channels, \"x1\", \"x2\") : values(channels, y, y === \"y\" ? \"y2\" : y === \"x\" ? \"x2\" : undefined);\n      const reducer = maybeReduce(reduce === true ? \"max\" : reduce, YV);\n      X.domain = () => {\n        let domain = rollups(range(XV), I => reducer.reduceIndex(I, YV), i => XV[i]);\n        if (order) domain.sort(order);\n        if (reverse) domain.reverse();\n        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);\n        return domain.map(first);\n      };\n    }\n  }\n}\nfunction findScaleChannel(channels, scale) {\n  for (const name in channels) {\n    const channel = channels[name];\n    if (channel.scale === scale) return channel;\n  }\n}\n\n// Facet channels are not affected by transforms; so, to compute the domain of a\n// facet scale, we must first re-index the facet channel according to the\n// transformed mark index. Note: mutates channel, but that should be safe here?\nfunction reindexFacetChannel(facets, channel) {\n  const originalFacets = facets.original;\n  if (originalFacets === facets) return channel; // not transformed\n  const V1 = channel.value;\n  const V2 = channel.value = []; // mutates channel!\n  for (let i = 0; i < originalFacets.length; ++i) {\n    const vi = V1[originalFacets[i][0]];\n    for (const j of facets[i]) V2[j] = vi;\n  }\n  return channel;\n}\nfunction difference(channels, k1, k2) {\n  const X1 = values(channels, k1);\n  const X2 = values(channels, k2);\n  return map(X2, (x2, i) => Math.abs(x2 - X1[i]), Float64Array);\n}\nfunction values(channels, name, alias) {\n  let channel = channels[name];\n  if (!channel && alias !== undefined) channel = channels[alias];\n  if (channel) return channel.value;\n  throw new Error(`missing channel: ${name}`);\n}\nfunction maybeOrder(order) {\n  if (order == null || typeof order === \"function\") return order;\n  switch (`${order}`.toLowerCase()) {\n    case \"ascending\":\n      return ascendingGroup;\n    case \"descending\":\n      return descendingGroup;\n  }\n  throw new Error(`invalid order: ${order}`);\n}\nfunction ascendingGroup([ak, av], [bk, bv]) {\n  return ascendingDefined(av, bv) || ascendingDefined(ak, bk);\n}\nfunction descendingGroup([ak, av], [bk, bv]) {\n  return descendingDefined(av, bv) || ascendingDefined(ak, bk);\n}\nexport function getSource(channels, key) {\n  let channel = channels[key];\n  if (!channel) return;\n  while (channel.source) channel = channel.source;\n  return channel.source === null ? null : channel;\n}","map":{"version":3,"names":["InternSet","rollups","ascendingDefined","descendingDefined","first","isColor","isEvery","isIterable","isOpacity","labelof","map","maybeValue","range","valueof","registry","isSymbol","maybeSymbol","maybeReduce","createChannel","data","scale","type","value","filter","hint","label","name","undefined","transform","inferChannelScale","createChannels","channels","Object","fromEntries","entries","channel","valueObject","scales","values","scaleName","defaultScale","has","Error","channelDomain","facets","facetChannels","options","order","defaultOrder","reverse","defaultReverse","reduce","defaultReduce","limit","defaultLimit","x","y","negate","startsWith","slice","descendingGroup","ascendingGroup","maybeOrder","X","reindexFacetChannel","findScaleChannel","XV","lo","hi","Infinity","domain","Array","from","YV","difference","reducer","I","reduceIndex","i","sort","originalFacets","original","V1","V2","length","vi","j","k1","k2","X1","X2","x2","Math","abs","Float64Array","alias","toLowerCase","ak","av","bk","bv","getSource","key","source"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/channel.js"],"sourcesContent":["import {InternSet, rollups} from \"d3\";\nimport {ascendingDefined, descendingDefined} from \"./defined.js\";\nimport {first, isColor, isEvery, isIterable, isOpacity, labelof, map, maybeValue, range, valueof} from \"./options.js\";\nimport {registry} from \"./scales/index.js\";\nimport {isSymbol, maybeSymbol} from \"./symbol.js\";\nimport {maybeReduce} from \"./transforms/group.js\";\n\nexport function createChannel(data, {scale, type, value, filter, hint, label = labelof(value)}, name) {\n  if (hint === undefined && typeof value?.transform === \"function\") hint = value.hint;\n  return inferChannelScale(name, {\n    scale,\n    type,\n    value: valueof(data, value),\n    label,\n    filter,\n    hint\n  });\n}\n\nexport function createChannels(channels, data) {\n  return Object.fromEntries(\n    Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])\n  );\n}\n\n// TODO Use Float64Array for scales with numeric ranges, e.g. position?\nexport function valueObject(channels, scales) {\n  const values = Object.fromEntries(\n    Object.entries(channels).map(([name, {scale: scaleName, value}]) => {\n      const scale = scaleName == null ? null : scales[scaleName];\n      return [name, scale == null ? value : map(value, scale)];\n    })\n  );\n  values.channels = channels; // expose channel state for advanced usage\n  return values;\n}\n\n// If the channel uses the \"auto\" scale (or equivalently true), infer the scale\n// from the channel name and the provided values. For color and symbol channels,\n// no scale is applied if the values are literal; however for symbols, we must\n// promote symbol names (e.g., \"plus\") to symbol implementations (symbolPlus).\n// Note: mutates channel!\nexport function inferChannelScale(name, channel) {\n  const {scale, value} = channel;\n  if (scale === true || scale === \"auto\") {\n    switch (name) {\n      case \"fill\":\n      case \"stroke\":\n      case \"color\":\n        channel.scale = scale !== true && isEvery(value, isColor) ? null : \"color\";\n        channel.defaultScale = \"color\";\n        break;\n      case \"fillOpacity\":\n      case \"strokeOpacity\":\n      case \"opacity\":\n        channel.scale = scale !== true && isEvery(value, isOpacity) ? null : \"opacity\";\n        channel.defaultScale = \"opacity\";\n        break;\n      case \"symbol\":\n        if (scale !== true && isEvery(value, isSymbol)) {\n          channel.scale = null;\n          channel.value = map(value, maybeSymbol);\n        } else {\n          channel.scale = \"symbol\";\n        }\n        channel.defaultScale = \"symbol\";\n        break;\n      default:\n        channel.scale = registry.has(name) ? name : null;\n        break;\n    }\n  } else if (scale === false) {\n    channel.scale = null;\n  } else if (scale != null && !registry.has(scale)) {\n    throw new Error(`unknown scale: ${scale}`);\n  }\n  return channel;\n}\n\n// Note: mutates channel.domain! This is set to a function so that it is lazily\n// computed; i.e., if the scale’s domain is set explicitly, that takes priority\n// over the sort option, and we don’t need to do additional work.\nexport function channelDomain(data, facets, channels, facetChannels, options) {\n  const {order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit} = options;\n  for (const x in options) {\n    if (!registry.has(x)) continue; // ignore unknown scale keys (including generic options)\n    let {value: y, order = defaultOrder, reverse = defaultReverse, reduce = defaultReduce, limit = defaultLimit} = maybeValue(options[x]); // prettier-ignore\n    const negate = y?.startsWith(\"-\");\n    if (negate) y = y.slice(1);\n    order = order === undefined ? negate !== (y === \"width\" || y === \"height\") ? descendingGroup : ascendingGroup : maybeOrder(order); // prettier-ignore\n    if (reduce == null || reduce === false) continue; // disabled reducer\n    const X = x === \"fx\" || x === \"fy\" ? reindexFacetChannel(facets, facetChannels[x]) : findScaleChannel(channels, x);\n    if (!X) throw new Error(`missing channel for scale: ${x}`);\n    const XV = X.value;\n    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];\n    if (y == null) {\n      X.domain = () => {\n        let domain = Array.from(new InternSet(XV)); // remove any duplicates\n        if (reverse) domain = domain.reverse();\n        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);\n        return domain;\n      };\n    } else {\n      const YV =\n        y === \"data\"\n          ? data\n          : y === \"height\"\n          ? difference(channels, \"y1\", \"y2\")\n          : y === \"width\"\n          ? difference(channels, \"x1\", \"x2\")\n          : values(channels, y, y === \"y\" ? \"y2\" : y === \"x\" ? \"x2\" : undefined);\n      const reducer = maybeReduce(reduce === true ? \"max\" : reduce, YV);\n      X.domain = () => {\n        let domain = rollups(\n          range(XV),\n          (I) => reducer.reduceIndex(I, YV),\n          (i) => XV[i]\n        );\n        if (order) domain.sort(order);\n        if (reverse) domain.reverse();\n        if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);\n        return domain.map(first);\n      };\n    }\n  }\n}\n\nfunction findScaleChannel(channels, scale) {\n  for (const name in channels) {\n    const channel = channels[name];\n    if (channel.scale === scale) return channel;\n  }\n}\n\n// Facet channels are not affected by transforms; so, to compute the domain of a\n// facet scale, we must first re-index the facet channel according to the\n// transformed mark index. Note: mutates channel, but that should be safe here?\nfunction reindexFacetChannel(facets, channel) {\n  const originalFacets = facets.original;\n  if (originalFacets === facets) return channel; // not transformed\n  const V1 = channel.value;\n  const V2 = (channel.value = []); // mutates channel!\n  for (let i = 0; i < originalFacets.length; ++i) {\n    const vi = V1[originalFacets[i][0]];\n    for (const j of facets[i]) V2[j] = vi;\n  }\n  return channel;\n}\n\nfunction difference(channels, k1, k2) {\n  const X1 = values(channels, k1);\n  const X2 = values(channels, k2);\n  return map(X2, (x2, i) => Math.abs(x2 - X1[i]), Float64Array);\n}\n\nfunction values(channels, name, alias) {\n  let channel = channels[name];\n  if (!channel && alias !== undefined) channel = channels[alias];\n  if (channel) return channel.value;\n  throw new Error(`missing channel: ${name}`);\n}\n\nfunction maybeOrder(order) {\n  if (order == null || typeof order === \"function\") return order;\n  switch (`${order}`.toLowerCase()) {\n    case \"ascending\":\n      return ascendingGroup;\n    case \"descending\":\n      return descendingGroup;\n  }\n  throw new Error(`invalid order: ${order}`);\n}\n\nfunction ascendingGroup([ak, av], [bk, bv]) {\n  return ascendingDefined(av, bv) || ascendingDefined(ak, bk);\n}\n\nfunction descendingGroup([ak, av], [bk, bv]) {\n  return descendingDefined(av, bv) || ascendingDefined(ak, bk);\n}\n\nexport function getSource(channels, key) {\n  let channel = channels[key];\n  if (!channel) return;\n  while (channel.source) channel = channel.source;\n  return channel.source === null ? null : channel;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}