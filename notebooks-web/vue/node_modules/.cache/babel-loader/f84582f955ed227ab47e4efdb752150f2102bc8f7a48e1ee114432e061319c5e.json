{"ast":null,"code":"import { geoGraticule10, geoPath, geoTransform } from \"d3\";\nimport { create } from \"../context.js\";\nimport { negative, positive } from \"../defined.js\";\nimport { Mark } from \"../mark.js\";\nimport { identity, maybeNumberChannel } from \"../options.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform } from \"../style.js\";\nimport { centroid } from \"../transforms/centroid.js\";\nimport { withDefaultSort } from \"./dot.js\";\nconst defaults = {\n  ariaLabel: \"geo\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nexport class Geo extends Mark {\n  constructor(data, options = {}) {\n    const [vr, cr] = maybeNumberChannel(options.r, 3);\n    super(data, {\n      x: {\n        value: options.tip ? options.x : null,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: options.tip ? options.y : null,\n        scale: \"y\",\n        optional: true\n      },\n      r: {\n        value: vr,\n        scale: \"r\",\n        filter: positive,\n        optional: true\n      },\n      geometry: {\n        value: options.geometry,\n        scale: \"projection\"\n      }\n    }, withDefaultSort(options), defaults);\n    this.r = cr;\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      geometry: G,\n      r: R\n    } = channels;\n    const path = geoPath(context.projection ?? scaleProjection(scales));\n    const {\n      r\n    } = this;\n    if (negative(r)) index = [];else if (r !== undefined) path.pointRadius(r);\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(g => {\n      g.selectAll().data(index).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", R ? i => path.pointRadius(R[i])(G[i]) : i => path(G[i])).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n}\n\n// If no projection is specified, default to a projection that passes points\n// through the x and y scales, if any.\nfunction scaleProjection({\n  x: X,\n  y: Y\n}) {\n  if (X || Y) {\n    X ??= x => x;\n    Y ??= y => y;\n    return geoTransform({\n      point(x, y) {\n        this.stream.point(X(x), Y(y));\n      }\n    });\n  }\n}\nexport function geo(data, options = {}) {\n  if (options.tip && options.x === undefined && options.y === undefined) options = centroid(options);else if (options.geometry === undefined) options = {\n    ...options,\n    geometry: identity\n  };\n  return new Geo(data, options);\n}\nexport function sphere({\n  strokeWidth = 1.5,\n  ...options\n} = {}) {\n  return geo({\n    type: \"Sphere\"\n  }, {\n    strokeWidth,\n    ...options\n  });\n}\nexport function graticule({\n  strokeOpacity = 0.1,\n  ...options\n} = {}) {\n  return geo(geoGraticule10(), {\n    strokeOpacity,\n    ...options\n  });\n}","map":{"version":3,"names":["geoGraticule10","geoPath","geoTransform","create","negative","positive","Mark","identity","maybeNumberChannel","applyChannelStyles","applyDirectStyles","applyIndirectStyles","applyTransform","centroid","withDefaultSort","defaults","ariaLabel","fill","stroke","strokeWidth","strokeLinecap","strokeLinejoin","strokeMiterlimit","Geo","constructor","data","options","vr","cr","r","x","value","tip","scale","optional","y","filter","geometry","render","index","scales","channels","dimensions","context","G","R","path","projection","scaleProjection","undefined","pointRadius","call","g","selectAll","enter","append","attr","i","node","X","Y","point","stream","geo","sphere","type","graticule","strokeOpacity"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/geo.js"],"sourcesContent":["import {geoGraticule10, geoPath, geoTransform} from \"d3\";\nimport {create} from \"../context.js\";\nimport {negative, positive} from \"../defined.js\";\nimport {Mark} from \"../mark.js\";\nimport {identity, maybeNumberChannel} from \"../options.js\";\nimport {applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform} from \"../style.js\";\nimport {centroid} from \"../transforms/centroid.js\";\nimport {withDefaultSort} from \"./dot.js\";\n\nconst defaults = {\n  ariaLabel: \"geo\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\n\nexport class Geo extends Mark {\n  constructor(data, options = {}) {\n    const [vr, cr] = maybeNumberChannel(options.r, 3);\n    super(\n      data,\n      {\n        x: {value: options.tip ? options.x : null, scale: \"x\", optional: true},\n        y: {value: options.tip ? options.y : null, scale: \"y\", optional: true},\n        r: {value: vr, scale: \"r\", filter: positive, optional: true},\n        geometry: {value: options.geometry, scale: \"projection\"}\n      },\n      withDefaultSort(options),\n      defaults\n    );\n    this.r = cr;\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {geometry: G, r: R} = channels;\n    const path = geoPath(context.projection ?? scaleProjection(scales));\n    const {r} = this;\n    if (negative(r)) index = [];\n    else if (r !== undefined) path.pointRadius(r);\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, scales)\n      .call((g) => {\n        g.selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .attr(\"d\", R ? (i) => path.pointRadius(R[i])(G[i]) : (i) => path(G[i]))\n          .call(applyChannelStyles, this, channels);\n      })\n      .node();\n  }\n}\n\n// If no projection is specified, default to a projection that passes points\n// through the x and y scales, if any.\nfunction scaleProjection({x: X, y: Y}) {\n  if (X || Y) {\n    X ??= (x) => x;\n    Y ??= (y) => y;\n    return geoTransform({\n      point(x, y) {\n        this.stream.point(X(x), Y(y));\n      }\n    });\n  }\n}\n\nexport function geo(data, options = {}) {\n  if (options.tip && options.x === undefined && options.y === undefined) options = centroid(options);\n  else if (options.geometry === undefined) options = {...options, geometry: identity};\n  return new Geo(data, options);\n}\n\nexport function sphere({strokeWidth = 1.5, ...options} = {}) {\n  return geo({type: \"Sphere\"}, {strokeWidth, ...options});\n}\n\nexport function graticule({strokeOpacity = 0.1, ...options} = {}) {\n  return geo(geoGraticule10(), {strokeOpacity, ...options});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}