{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternSet, group as grouper, rollup, sort } from \"d3\";\nimport { deviation, max, maxIndex, mean, median, min, minIndex, mode, sum, variance } from \"d3\";\nimport { ascendingDefined } from \"../defined.js\";\nimport { maybeApplyInterval, maybeColorChannel, maybeColumn, maybeInput, maybeTuple } from \"../options.js\";\nimport { isArray, isObject, isTemporal } from \"../options.js\";\nimport { column, identity, labelof, percentile, range, second, take, valueof } from \"../options.js\";\nimport { basic } from \"./basic.js\";\n\n// Group on {z, fill, stroke}.\nexport function groupZ(outputs, options) {\n  return groupn(null, null, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on x.\nexport function groupX(outputs = {\n  y: \"count\"\n}, options = {}) {\n  const {\n    x = identity\n  } = options;\n  if (x == null) throw new Error(\"missing channel: x\");\n  return groupn(x, null, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on y.\nexport function groupY(outputs = {\n  x: \"count\"\n}, options = {}) {\n  const {\n    y = identity\n  } = options;\n  if (y == null) throw new Error(\"missing channel: y\");\n  return groupn(null, y, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on x and y.\nexport function group(outputs = {\n  fill: \"count\"\n}, options = {}) {\n  let {\n    x,\n    y\n  } = options;\n  [x, y] = maybeTuple(x, y);\n  if (x == null) throw new Error(\"missing channel: x\");\n  if (y == null) throw new Error(\"missing channel: y\");\n  return groupn(x, y, outputs, options);\n}\nfunction groupn(x,\n// optionally group on x\ny,\n// optionally group on y\n{\n  data: reduceData = reduceIdentity,\n  filter,\n  sort,\n  reverse,\n  ...outputs // output channel definitions\n} = {}, inputs = {} // input channels and options\n) {\n  // Compute the outputs.\n  outputs = maybeGroupOutputs(outputs, inputs);\n  reduceData = maybeGroupReduce(reduceData, identity);\n  sort = sort == null ? undefined : maybeGroupOutput(\"sort\", sort, inputs);\n  filter = filter == null ? undefined : maybeGroupEvaluator(\"filter\", filter, inputs);\n\n  // Produce x and y output channels as appropriate.\n  const [GX, setGX] = maybeColumn(x);\n  const [GY, setGY] = maybeColumn(y);\n\n  // Greedily materialize the z, fill, and stroke channels (if channels and not\n  // constants) so that we can reference them for subdividing groups without\n  // computing them more than once.\n  const {\n    z,\n    fill,\n    stroke,\n    x1,\n    x2,\n    // consumed if x is an output\n    y1,\n    y2,\n    // consumed if y is an output\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n  return {\n    ...(\"z\" in inputs && {\n      z: GZ || z\n    }),\n    ...(\"fill\" in inputs && {\n      fill: GF || fill\n    }),\n    ...(\"stroke\" in inputs && {\n      stroke: GS || stroke\n    }),\n    ...basic(options, (data, facets, plotOptions) => {\n      const X = maybeApplyInterval(valueof(data, x), plotOptions?.x);\n      const Y = maybeApplyInterval(valueof(data, y), plotOptions?.y);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, {\n        z: Z,\n        fill: F,\n        stroke: S\n      });\n      const groupFacets = [];\n      const groupData = [];\n      const GX = X && setGX([]);\n      const GY = Y && setGY([]);\n      const GZ = Z && setGZ([]);\n      const GF = F && setGF([]);\n      const GS = S && setGS([]);\n      let i = 0;\n      for (const o of outputs) o.initialize(data);\n      if (sort) sort.initialize(data);\n      if (filter) filter.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs) o.scope(\"facet\", facet);\n        if (sort) sort.scope(\"facet\", facet);\n        if (filter) filter.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [y, gg] of maybeGroup(I, Y)) {\n            for (const [x, g] of maybeGroup(gg, X)) {\n              const extent = {\n                data\n              };\n              if (X) extent.x = x;\n              if (Y) extent.y = y;\n              if (G) extent.z = f;\n              if (filter && !filter.reduce(g, extent)) continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduceIndex(g, data, extent));\n              if (X) GX.push(x);\n              if (Y) GY.push(y);\n              if (Z) GZ.push(G === Z ? f : Z[g[0]]);\n              if (F) GF.push(G === F ? f : F[g[0]]);\n              if (S) GS.push(G === S ? f : S[g[0]]);\n              for (const o of outputs) o.reduce(g, extent);\n              if (sort) sort.reduce(g, extent);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort, reverse);\n      return {\n        data: groupData,\n        facets: groupFacets\n      };\n    }),\n    ...(!hasOutput(outputs, \"x\") && (GX ? {\n      x: GX\n    } : {\n      x1,\n      x2\n    })),\n    ...(!hasOutput(outputs, \"y\") && (GY ? {\n      y: GY\n    } : {\n      y1,\n      y2\n    })),\n    ...Object.fromEntries(outputs.map(({\n      name,\n      output\n    }) => [name, output]))\n  };\n}\nexport function hasOutput(outputs, ...names) {\n  for (const {\n    name\n  } of outputs) {\n    if (names.includes(name)) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {\n  const entries = Object.entries(outputs);\n  // Propagate standard mark channels by default.\n  if (inputs.title != null && outputs.title === undefined) entries.push([\"title\", reduceTitle]);\n  if (inputs.href != null && outputs.href === undefined) entries.push([\"href\", reduceFirst]);\n  return entries.filter(([, reduce]) => reduce !== undefined).map(([name, reduce]) => reduce === null ? nullOutput(name) : asOutput(name, reduce, inputs));\n}\nexport function maybeOutput(name, reduce, inputs, asEvaluator = maybeEvaluator) {\n  let scale; // optional per-channel scale override\n  if (isObject(reduce) && \"reduce\" in reduce) scale = reduce.scale, reduce = reduce.reduce; // N.B. array.reduce\n  const evaluator = asEvaluator(name, reduce, inputs);\n  const [output, setOutput] = column(evaluator.label);\n  let O;\n  return {\n    name,\n    output: scale === undefined ? output : {\n      value: output,\n      scale\n    },\n    initialize(data) {\n      evaluator.initialize(data);\n      O = setOutput([]);\n    },\n    scope(scope, I) {\n      evaluator.scope(scope, I);\n    },\n    reduce(I, extent) {\n      O.push(evaluator.reduce(I, extent));\n    }\n  };\n}\nfunction nullOutput(name) {\n  return {\n    name,\n    initialize() {},\n    scope() {},\n    reduce() {}\n  };\n}\nexport function maybeEvaluator(name, reduce, inputs, asReduce = maybeReduce) {\n  const input = maybeInput(name, inputs);\n  const reducer = asReduce(reduce, input);\n  let V, context;\n  return {\n    label: labelof(reducer === reduceCount ? null : input, reducer.label),\n    initialize(data) {\n      V = input === undefined ? data : valueof(data, input);\n      if (reducer.scope === \"data\") {\n        context = reducer.reduceIndex(range(data), V);\n      }\n    },\n    scope(scope, I) {\n      if (reducer.scope === scope) {\n        context = reducer.reduceIndex(I, V);\n      }\n    },\n    reduce(I, extent) {\n      return reducer.scope == null ? reducer.reduceIndex(I, V, extent) : reducer.reduceIndex(I, V, context, extent);\n    }\n  };\n}\nexport function maybeGroup(I, X) {\n  return X ? grouper(I, i => X[i]) : [[, I]];\n}\nexport function maybeReduce(reduce, value, fallback = invalidReduce) {\n  if (reduce == null) return fallback(reduce);\n  if (typeof reduce.reduceIndex === \"function\") return reduce;\n  if (typeof reduce.reduce === \"function\" && isObject(reduce)) return reduceReduce(reduce); // N.B. array.reduce\n  if (typeof reduce === \"function\") return reduceFunction(reduce);\n  if (/^p\\d{2}$/i.test(reduce)) return reduceAccessor(percentile(reduce));\n  switch (`${reduce}`.toLowerCase()) {\n    case \"first\":\n      return reduceFirst;\n    case \"last\":\n      return reduceLast;\n    case \"identity\":\n      return reduceIdentity;\n    case \"count\":\n      return reduceCount;\n    case \"distinct\":\n      return reduceDistinct;\n    case \"sum\":\n      return value == null ? reduceCount : reduceSum;\n    case \"proportion\":\n      return reduceProportion(value, \"data\");\n    case \"proportion-facet\":\n      return reduceProportion(value, \"facet\");\n    case \"deviation\":\n      return reduceAccessor(deviation);\n    case \"min\":\n      return reduceAccessor(min);\n    case \"min-index\":\n      return reduceAccessor(minIndex);\n    case \"max\":\n      return reduceAccessor(max);\n    case \"max-index\":\n      return reduceAccessor(maxIndex);\n    case \"mean\":\n      return reduceMaybeTemporalAccessor(mean);\n    case \"median\":\n      return reduceMaybeTemporalAccessor(median);\n    case \"variance\":\n      return reduceAccessor(variance);\n    case \"mode\":\n      return reduceAccessor(mode);\n  }\n  return fallback(reduce);\n}\nfunction invalidReduce(reduce) {\n  throw new Error(`invalid reduce: ${reduce}`);\n}\nexport function maybeGroupOutputs(outputs, inputs) {\n  return maybeOutputs(outputs, inputs, maybeGroupOutput);\n}\nfunction maybeGroupOutput(name, reduce, inputs) {\n  return maybeOutput(name, reduce, inputs, maybeGroupEvaluator);\n}\nfunction maybeGroupEvaluator(name, reduce, inputs) {\n  return maybeEvaluator(name, reduce, inputs, maybeGroupReduce);\n}\nfunction maybeGroupReduce(reduce, value) {\n  return maybeReduce(reduce, value, maybeGroupReduceFallback);\n}\nfunction maybeGroupReduceFallback(reduce) {\n  switch (`${reduce}`.toLowerCase()) {\n    case \"x\":\n      return reduceX;\n    case \"y\":\n      return reduceY;\n    case \"z\":\n      return reduceZ;\n  }\n  throw new Error(`invalid group reduce: ${reduce}`);\n}\nexport function maybeSubgroup(outputs, inputs) {\n  for (const name in inputs) {\n    const value = inputs[name];\n    if (value !== undefined && !outputs.some(o => o.name === name)) {\n      return value;\n    }\n  }\n}\nexport function maybeSort(facets, sort, reverse) {\n  if (sort) {\n    const S = sort.output.transform();\n    const compare = (i, j) => ascendingDefined(S[i], S[j]);\n    facets.forEach(f => f.sort(compare));\n  }\n  if (reverse) {\n    facets.forEach(f => f.reverse());\n  }\n}\nfunction reduceReduce(reduce) {\n  console.warn(\"deprecated reduce interface; implement reduceIndex instead.\");\n  return {\n    ...reduce,\n    reduceIndex: reduce.reduce.bind(reduce)\n  };\n}\nfunction reduceFunction(f) {\n  return {\n    reduceIndex(I, X, extent) {\n      return f(take(X, I), extent);\n    }\n  };\n}\nfunction reduceAccessor(f) {\n  return {\n    reduceIndex(I, X) {\n      return f(I, i => X[i]);\n    }\n  };\n}\nfunction reduceMaybeTemporalAccessor(f) {\n  return {\n    reduceIndex(I, X) {\n      const x = f(I, i => X[i]);\n      return isTemporal(X) ? new Date(x) : x;\n    }\n  };\n}\nexport const reduceIdentity = {\n  reduceIndex(I, X) {\n    return take(X, I);\n  }\n};\nexport const reduceFirst = {\n  reduceIndex(I, X) {\n    return X[I[0]];\n  }\n};\nconst reduceTitle = {\n  reduceIndex(I, X) {\n    const n = 5;\n    const groups = sort(rollup(I, V => V.length, i => X[i]), second);\n    const top = groups.slice(-n).reverse();\n    if (top.length < groups.length) {\n      const bottom = groups.slice(0, 1 - n);\n      top[n - 1] = [`… ${bottom.length.toLocaleString(\"en-US\")} more`, sum(bottom, second)];\n    }\n    return top.map(([key, value]) => `${key} (${value.toLocaleString(\"en-US\")})`).join(\"\\n\");\n  }\n};\nconst reduceLast = {\n  reduceIndex(I, X) {\n    return X[I[I.length - 1]];\n  }\n};\nexport const reduceCount = {\n  label: \"Frequency\",\n  reduceIndex(I) {\n    return I.length;\n  }\n};\nconst reduceDistinct = {\n  label: \"Distinct\",\n  reduceIndex(I, X) {\n    const s = new InternSet();\n    for (const i of I) s.add(X[i]);\n    return s.size;\n  }\n};\nconst reduceSum = reduceAccessor(sum);\nfunction reduceProportion(value, scope) {\n  return value == null ? {\n    scope,\n    label: \"Frequency\",\n    reduceIndex: (I, V, basis = 1) => I.length / basis\n  } : {\n    scope,\n    reduceIndex: (I, V, basis = 1) => sum(I, i => V[i]) / basis\n  };\n}\nconst reduceX = {\n  reduceIndex(I, X, {\n    x\n  }) {\n    return x;\n  }\n};\nconst reduceY = {\n  reduceIndex(I, X, {\n    y\n  }) {\n    return y;\n  }\n};\nexport const reduceZ = {\n  reduceIndex(I, X, {\n    z\n  }) {\n    return z;\n  }\n};\nexport function find(test) {\n  if (typeof test !== \"function\") throw new Error(`invalid test function: ${test}`);\n  return {\n    reduceIndex(I, V, {\n      data\n    }) {\n      return V[I.find(isArray(data) ? i => test(data[i], i, data) : i => test(data.get(i), i, data))];\n    }\n  };\n}","map":{"version":3,"names":["InternSet","group","grouper","rollup","sort","deviation","max","maxIndex","mean","median","min","minIndex","mode","sum","variance","ascendingDefined","maybeApplyInterval","maybeColorChannel","maybeColumn","maybeInput","maybeTuple","isArray","isObject","isTemporal","column","identity","labelof","percentile","range","second","take","valueof","basic","groupZ","outputs","options","groupn","groupX","y","x","Error","groupY","fill","data","reduceData","reduceIdentity","filter","reverse","inputs","maybeGroupOutputs","maybeGroupReduce","undefined","maybeGroupOutput","maybeGroupEvaluator","GX","setGX","GY","setGY","z","stroke","x1","x2","y1","y2","GZ","setGZ","vfill","vstroke","GF","setGF","GS","setGS","facets","plotOptions","X","Y","Z","F","S","G","maybeSubgroup","groupFacets","groupData","i","o","initialize","facet","groupFacet","scope","f","I","maybeGroup","gg","g","extent","reduce","push","reduceIndex","maybeSort","hasOutput","Object","fromEntries","map","name","output","names","includes","maybeOutputs","asOutput","maybeOutput","entries","title","reduceTitle","href","reduceFirst","nullOutput","asEvaluator","maybeEvaluator","scale","evaluator","setOutput","label","O","value","asReduce","maybeReduce","input","reducer","V","context","reduceCount","fallback","invalidReduce","reduceReduce","reduceFunction","test","reduceAccessor","toLowerCase","reduceLast","reduceDistinct","reduceSum","reduceProportion","reduceMaybeTemporalAccessor","maybeGroupReduceFallback","reduceX","reduceY","reduceZ","some","transform","compare","j","forEach","console","warn","bind","Date","n","groups","length","top","slice","bottom","toLocaleString","key","join","s","add","size","basis","find","get"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/group.js"],"sourcesContent":["import {InternSet, group as grouper, rollup, sort} from \"d3\";\nimport {deviation, max, maxIndex, mean, median, min, minIndex, mode, sum, variance} from \"d3\";\nimport {ascendingDefined} from \"../defined.js\";\nimport {maybeApplyInterval, maybeColorChannel, maybeColumn, maybeInput, maybeTuple} from \"../options.js\";\nimport {isArray, isObject, isTemporal} from \"../options.js\";\nimport {column, identity, labelof, percentile, range, second, take, valueof} from \"../options.js\";\nimport {basic} from \"./basic.js\";\n\n// Group on {z, fill, stroke}.\nexport function groupZ(outputs, options) {\n  return groupn(null, null, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on x.\nexport function groupX(outputs = {y: \"count\"}, options = {}) {\n  const {x = identity} = options;\n  if (x == null) throw new Error(\"missing channel: x\");\n  return groupn(x, null, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on y.\nexport function groupY(outputs = {x: \"count\"}, options = {}) {\n  const {y = identity} = options;\n  if (y == null) throw new Error(\"missing channel: y\");\n  return groupn(null, y, outputs, options);\n}\n\n// Group on {z, fill, stroke}, then on x and y.\nexport function group(outputs = {fill: \"count\"}, options = {}) {\n  let {x, y} = options;\n  [x, y] = maybeTuple(x, y);\n  if (x == null) throw new Error(\"missing channel: x\");\n  if (y == null) throw new Error(\"missing channel: y\");\n  return groupn(x, y, outputs, options);\n}\n\nfunction groupn(\n  x, // optionally group on x\n  y, // optionally group on y\n  {\n    data: reduceData = reduceIdentity,\n    filter,\n    sort,\n    reverse,\n    ...outputs // output channel definitions\n  } = {},\n  inputs = {} // input channels and options\n) {\n  // Compute the outputs.\n  outputs = maybeGroupOutputs(outputs, inputs);\n  reduceData = maybeGroupReduce(reduceData, identity);\n  sort = sort == null ? undefined : maybeGroupOutput(\"sort\", sort, inputs);\n  filter = filter == null ? undefined : maybeGroupEvaluator(\"filter\", filter, inputs);\n\n  // Produce x and y output channels as appropriate.\n  const [GX, setGX] = maybeColumn(x);\n  const [GY, setGY] = maybeColumn(y);\n\n  // Greedily materialize the z, fill, and stroke channels (if channels and not\n  // constants) so that we can reference them for subdividing groups without\n  // computing them more than once.\n  const {\n    z,\n    fill,\n    stroke,\n    x1,\n    x2, // consumed if x is an output\n    y1,\n    y2, // consumed if y is an output\n    ...options\n  } = inputs;\n  const [GZ, setGZ] = maybeColumn(z);\n  const [vfill] = maybeColorChannel(fill);\n  const [vstroke] = maybeColorChannel(stroke);\n  const [GF, setGF] = maybeColumn(vfill);\n  const [GS, setGS] = maybeColumn(vstroke);\n\n  return {\n    ...(\"z\" in inputs && {z: GZ || z}),\n    ...(\"fill\" in inputs && {fill: GF || fill}),\n    ...(\"stroke\" in inputs && {stroke: GS || stroke}),\n    ...basic(options, (data, facets, plotOptions) => {\n      const X = maybeApplyInterval(valueof(data, x), plotOptions?.x);\n      const Y = maybeApplyInterval(valueof(data, y), plotOptions?.y);\n      const Z = valueof(data, z);\n      const F = valueof(data, vfill);\n      const S = valueof(data, vstroke);\n      const G = maybeSubgroup(outputs, {z: Z, fill: F, stroke: S});\n      const groupFacets = [];\n      const groupData = [];\n      const GX = X && setGX([]);\n      const GY = Y && setGY([]);\n      const GZ = Z && setGZ([]);\n      const GF = F && setGF([]);\n      const GS = S && setGS([]);\n      let i = 0;\n      for (const o of outputs) o.initialize(data);\n      if (sort) sort.initialize(data);\n      if (filter) filter.initialize(data);\n      for (const facet of facets) {\n        const groupFacet = [];\n        for (const o of outputs) o.scope(\"facet\", facet);\n        if (sort) sort.scope(\"facet\", facet);\n        if (filter) filter.scope(\"facet\", facet);\n        for (const [f, I] of maybeGroup(facet, G)) {\n          for (const [y, gg] of maybeGroup(I, Y)) {\n            for (const [x, g] of maybeGroup(gg, X)) {\n              const extent = {data};\n              if (X) extent.x = x;\n              if (Y) extent.y = y;\n              if (G) extent.z = f;\n              if (filter && !filter.reduce(g, extent)) continue;\n              groupFacet.push(i++);\n              groupData.push(reduceData.reduceIndex(g, data, extent));\n              if (X) GX.push(x);\n              if (Y) GY.push(y);\n              if (Z) GZ.push(G === Z ? f : Z[g[0]]);\n              if (F) GF.push(G === F ? f : F[g[0]]);\n              if (S) GS.push(G === S ? f : S[g[0]]);\n              for (const o of outputs) o.reduce(g, extent);\n              if (sort) sort.reduce(g, extent);\n            }\n          }\n        }\n        groupFacets.push(groupFacet);\n      }\n      maybeSort(groupFacets, sort, reverse);\n      return {data: groupData, facets: groupFacets};\n    }),\n    ...(!hasOutput(outputs, \"x\") && (GX ? {x: GX} : {x1, x2})),\n    ...(!hasOutput(outputs, \"y\") && (GY ? {y: GY} : {y1, y2})),\n    ...Object.fromEntries(outputs.map(({name, output}) => [name, output]))\n  };\n}\n\nexport function hasOutput(outputs, ...names) {\n  for (const {name} of outputs) {\n    if (names.includes(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {\n  const entries = Object.entries(outputs);\n  // Propagate standard mark channels by default.\n  if (inputs.title != null && outputs.title === undefined) entries.push([\"title\", reduceTitle]);\n  if (inputs.href != null && outputs.href === undefined) entries.push([\"href\", reduceFirst]);\n  return entries\n    .filter(([, reduce]) => reduce !== undefined)\n    .map(([name, reduce]) => (reduce === null ? nullOutput(name) : asOutput(name, reduce, inputs)));\n}\n\nexport function maybeOutput(name, reduce, inputs, asEvaluator = maybeEvaluator) {\n  let scale; // optional per-channel scale override\n  if (isObject(reduce) && \"reduce\" in reduce) (scale = reduce.scale), (reduce = reduce.reduce); // N.B. array.reduce\n  const evaluator = asEvaluator(name, reduce, inputs);\n  const [output, setOutput] = column(evaluator.label);\n  let O;\n  return {\n    name,\n    output: scale === undefined ? output : {value: output, scale},\n    initialize(data) {\n      evaluator.initialize(data);\n      O = setOutput([]);\n    },\n    scope(scope, I) {\n      evaluator.scope(scope, I);\n    },\n    reduce(I, extent) {\n      O.push(evaluator.reduce(I, extent));\n    }\n  };\n}\n\nfunction nullOutput(name) {\n  return {name, initialize() {}, scope() {}, reduce() {}};\n}\n\nexport function maybeEvaluator(name, reduce, inputs, asReduce = maybeReduce) {\n  const input = maybeInput(name, inputs);\n  const reducer = asReduce(reduce, input);\n  let V, context;\n  return {\n    label: labelof(reducer === reduceCount ? null : input, reducer.label),\n    initialize(data) {\n      V = input === undefined ? data : valueof(data, input);\n      if (reducer.scope === \"data\") {\n        context = reducer.reduceIndex(range(data), V);\n      }\n    },\n    scope(scope, I) {\n      if (reducer.scope === scope) {\n        context = reducer.reduceIndex(I, V);\n      }\n    },\n    reduce(I, extent) {\n      return reducer.scope == null ? reducer.reduceIndex(I, V, extent) : reducer.reduceIndex(I, V, context, extent);\n    }\n  };\n}\n\nexport function maybeGroup(I, X) {\n  return X ? grouper(I, (i) => X[i]) : [[, I]];\n}\n\nexport function maybeReduce(reduce, value, fallback = invalidReduce) {\n  if (reduce == null) return fallback(reduce);\n  if (typeof reduce.reduceIndex === \"function\") return reduce;\n  if (typeof reduce.reduce === \"function\" && isObject(reduce)) return reduceReduce(reduce); // N.B. array.reduce\n  if (typeof reduce === \"function\") return reduceFunction(reduce);\n  if (/^p\\d{2}$/i.test(reduce)) return reduceAccessor(percentile(reduce));\n  switch (`${reduce}`.toLowerCase()) {\n    case \"first\":\n      return reduceFirst;\n    case \"last\":\n      return reduceLast;\n    case \"identity\":\n      return reduceIdentity;\n    case \"count\":\n      return reduceCount;\n    case \"distinct\":\n      return reduceDistinct;\n    case \"sum\":\n      return value == null ? reduceCount : reduceSum;\n    case \"proportion\":\n      return reduceProportion(value, \"data\");\n    case \"proportion-facet\":\n      return reduceProportion(value, \"facet\");\n    case \"deviation\":\n      return reduceAccessor(deviation);\n    case \"min\":\n      return reduceAccessor(min);\n    case \"min-index\":\n      return reduceAccessor(minIndex);\n    case \"max\":\n      return reduceAccessor(max);\n    case \"max-index\":\n      return reduceAccessor(maxIndex);\n    case \"mean\":\n      return reduceMaybeTemporalAccessor(mean);\n    case \"median\":\n      return reduceMaybeTemporalAccessor(median);\n    case \"variance\":\n      return reduceAccessor(variance);\n    case \"mode\":\n      return reduceAccessor(mode);\n  }\n  return fallback(reduce);\n}\n\nfunction invalidReduce(reduce) {\n  throw new Error(`invalid reduce: ${reduce}`);\n}\n\nexport function maybeGroupOutputs(outputs, inputs) {\n  return maybeOutputs(outputs, inputs, maybeGroupOutput);\n}\n\nfunction maybeGroupOutput(name, reduce, inputs) {\n  return maybeOutput(name, reduce, inputs, maybeGroupEvaluator);\n}\n\nfunction maybeGroupEvaluator(name, reduce, inputs) {\n  return maybeEvaluator(name, reduce, inputs, maybeGroupReduce);\n}\n\nfunction maybeGroupReduce(reduce, value) {\n  return maybeReduce(reduce, value, maybeGroupReduceFallback);\n}\n\nfunction maybeGroupReduceFallback(reduce) {\n  switch (`${reduce}`.toLowerCase()) {\n    case \"x\":\n      return reduceX;\n    case \"y\":\n      return reduceY;\n    case \"z\":\n      return reduceZ;\n  }\n  throw new Error(`invalid group reduce: ${reduce}`);\n}\n\nexport function maybeSubgroup(outputs, inputs) {\n  for (const name in inputs) {\n    const value = inputs[name];\n    if (value !== undefined && !outputs.some((o) => o.name === name)) {\n      return value;\n    }\n  }\n}\n\nexport function maybeSort(facets, sort, reverse) {\n  if (sort) {\n    const S = sort.output.transform();\n    const compare = (i, j) => ascendingDefined(S[i], S[j]);\n    facets.forEach((f) => f.sort(compare));\n  }\n  if (reverse) {\n    facets.forEach((f) => f.reverse());\n  }\n}\n\nfunction reduceReduce(reduce) {\n  console.warn(\"deprecated reduce interface; implement reduceIndex instead.\");\n  return {...reduce, reduceIndex: reduce.reduce.bind(reduce)};\n}\n\nfunction reduceFunction(f) {\n  return {\n    reduceIndex(I, X, extent) {\n      return f(take(X, I), extent);\n    }\n  };\n}\n\nfunction reduceAccessor(f) {\n  return {\n    reduceIndex(I, X) {\n      return f(I, (i) => X[i]);\n    }\n  };\n}\n\nfunction reduceMaybeTemporalAccessor(f) {\n  return {\n    reduceIndex(I, X) {\n      const x = f(I, (i) => X[i]);\n      return isTemporal(X) ? new Date(x) : x;\n    }\n  };\n}\n\nexport const reduceIdentity = {\n  reduceIndex(I, X) {\n    return take(X, I);\n  }\n};\n\nexport const reduceFirst = {\n  reduceIndex(I, X) {\n    return X[I[0]];\n  }\n};\n\nconst reduceTitle = {\n  reduceIndex(I, X) {\n    const n = 5;\n    const groups = sort(\n      rollup(\n        I,\n        (V) => V.length,\n        (i) => X[i]\n      ),\n      second\n    );\n    const top = groups.slice(-n).reverse();\n    if (top.length < groups.length) {\n      const bottom = groups.slice(0, 1 - n);\n      top[n - 1] = [`… ${bottom.length.toLocaleString(\"en-US\")} more`, sum(bottom, second)];\n    }\n    return top.map(([key, value]) => `${key} (${value.toLocaleString(\"en-US\")})`).join(\"\\n\");\n  }\n};\n\nconst reduceLast = {\n  reduceIndex(I, X) {\n    return X[I[I.length - 1]];\n  }\n};\n\nexport const reduceCount = {\n  label: \"Frequency\",\n  reduceIndex(I) {\n    return I.length;\n  }\n};\n\nconst reduceDistinct = {\n  label: \"Distinct\",\n  reduceIndex(I, X) {\n    const s = new InternSet();\n    for (const i of I) s.add(X[i]);\n    return s.size;\n  }\n};\n\nconst reduceSum = reduceAccessor(sum);\n\nfunction reduceProportion(value, scope) {\n  return value == null\n    ? {scope, label: \"Frequency\", reduceIndex: (I, V, basis = 1) => I.length / basis}\n    : {scope, reduceIndex: (I, V, basis = 1) => sum(I, (i) => V[i]) / basis};\n}\n\nconst reduceX = {\n  reduceIndex(I, X, {x}) {\n    return x;\n  }\n};\n\nconst reduceY = {\n  reduceIndex(I, X, {y}) {\n    return y;\n  }\n};\n\nexport const reduceZ = {\n  reduceIndex(I, X, {z}) {\n    return z;\n  }\n};\n\nexport function find(test) {\n  if (typeof test !== \"function\") throw new Error(`invalid test function: ${test}`);\n  return {\n    reduceIndex(I, V, {data}) {\n      return V[I.find(isArray(data) ? (i) => test(data[i], i, data) : (i) => test(data.get(i), i, data))];\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}