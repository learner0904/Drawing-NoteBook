{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { stratify, tree } from \"d3\";\nimport { ascendingDefined } from \"../defined.js\";\nimport { column, identity, isArray, isObject, one, valueof } from \"../options.js\";\nimport { basic } from \"./basic.js\";\nexport function treeNode({\n  path = identity,\n  // the delimited path\n  delimiter,\n  // how the path is separated\n  frameAnchor,\n  treeLayout = tree,\n  treeSort,\n  treeSeparation,\n  treeAnchor,\n  treeFilter,\n  ...options\n} = {}) {\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (treeFilter != null) treeFilter = maybeNodeValue(treeFilter);\n  if (frameAnchor === undefined) frameAnchor = treeAnchor.frameAnchor;\n  const normalize = normalizer(delimiter);\n  const outputs = treeOutputs(options, maybeNodeValue);\n  const [X, setX] = column();\n  const [Y, setY] = column();\n  return {\n    x: X,\n    y: Y,\n    frameAnchor,\n    ...basic(options, (data, facets) => {\n      const P = normalize(valueof(data, path));\n      const X = setX([]);\n      const Y = setY([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify().path(i => P[i]);\n      const setData = isArray(data) ? node => node.data = data[node.data] : node => node.data = data.get(node.data);\n      const layout = treeLayout();\n      if (layout.nodeSize) layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== undefined) layout.separation(treeSeparation ?? one);\n      for (const o of outputs) o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root = rootof(facet.filter(i => P[i] != null)).each(setData);\n        if (treeSort != null) root.sort(treeSort);\n        layout(root);\n        for (const node of root.descendants()) {\n          if (treeFilter != null && !treeFilter(node)) continue;\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = node.data;\n          treeAnchor.position(node, treeIndex, X, Y);\n          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](node);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return {\n        data: treeData,\n        facets: treeFacets\n      };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nexport function treeLink({\n  path = identity,\n  // the delimited path\n  delimiter,\n  // how the path is separated\n  curve = \"bump-x\",\n  stroke = \"#555\",\n  strokeWidth = 1.5,\n  strokeOpacity = 0.5,\n  treeLayout = tree,\n  treeSort,\n  treeSeparation,\n  treeAnchor,\n  treeFilter,\n  ...options\n} = {}) {\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (treeFilter != null) treeFilter = maybeLinkValue(treeFilter);\n  options = {\n    curve,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    ...options\n  };\n  const normalize = normalizer(delimiter);\n  const outputs = treeOutputs(options, maybeLinkValue);\n  const [X1, setX1] = column();\n  const [X2, setX2] = column();\n  const [Y1, setY1] = column();\n  const [Y2, setY2] = column();\n  return {\n    x1: X1,\n    x2: X2,\n    y1: Y1,\n    y2: Y2,\n    ...basic(options, (data, facets) => {\n      const P = normalize(valueof(data, path));\n      const X1 = setX1([]);\n      const X2 = setX2([]);\n      const Y1 = setY1([]);\n      const Y2 = setY2([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify().path(i => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize) layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== undefined) layout.separation(treeSeparation ?? one);\n      for (const o of outputs) o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root = rootof(facet.filter(i => P[i] != null)).each(node => node.data = data[node.data]);\n        if (treeSort != null) root.sort(treeSort);\n        layout(root);\n        for (const {\n          source,\n          target\n        } of root.links()) {\n          if (treeFilter != null && !treeFilter(target, source)) continue;\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = target.data;\n          treeAnchor.position(source, treeIndex, X1, Y1);\n          treeAnchor.position(target, treeIndex, X2, Y2);\n          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](target, source);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return {\n        data: treeData,\n        facets: treeFacets\n      };\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\nexport function maybeTreeAnchor(anchor = \"left\") {\n  switch (`${anchor}`.trim().toLowerCase()) {\n    case \"left\":\n      return treeAnchorLeft;\n    case \"right\":\n      return treeAnchorRight;\n  }\n  throw new Error(`invalid tree anchor: ${anchor}`);\n}\nconst treeAnchorLeft = {\n  frameAnchor: \"left\",\n  dx: 6,\n  position({\n    x,\n    y\n  }, i, X, Y) {\n    X[i] = y;\n    Y[i] = -x;\n  }\n};\nconst treeAnchorRight = {\n  frameAnchor: \"right\",\n  dx: -6,\n  position({\n    x,\n    y\n  }, i, X, Y) {\n    X[i] = -y;\n    Y[i] = -x;\n  }\n};\nfunction maybeTreeSort(sort) {\n  return sort == null || typeof sort === \"function\" ? sort : `${sort}`.trim().toLowerCase().startsWith(\"node:\") ? nodeSort(maybeNodeValue(sort)) : nodeSort(nodeData(sort));\n}\nfunction nodeSort(value) {\n  return (a, b) => ascendingDefined(value(a), value(b));\n}\nfunction nodeData(field) {\n  return node => node.data?.[field];\n}\nfunction normalizer(delimiter = \"/\") {\n  delimiter = `${delimiter}`;\n  if (delimiter === \"/\") return P => P; // paths are already slash-separated\n  if (delimiter.length !== 1) throw new Error(\"delimiter must be exactly one character\");\n  const delimiterCode = delimiter.charCodeAt(0);\n  return P => P.map(p => slashDelimiter(p, delimiterCode));\n}\nconst CODE_BACKSLASH = 92;\nconst CODE_SLASH = 47;\nfunction slashDelimiter(input, delimiterCode) {\n  if (delimiterCode === CODE_BACKSLASH) throw new Error(\"delimiter cannot be backslash\");\n  let afterBackslash = false;\n  for (let i = 0, n = input.length; i < n; ++i) {\n    switch (input.charCodeAt(i)) {\n      case CODE_BACKSLASH:\n        if (!afterBackslash) {\n          afterBackslash = true;\n          continue;\n        }\n        break;\n      case delimiterCode:\n        if (afterBackslash) {\n          input = input.slice(0, i - 1) + input.slice(i), --i, --n; // remove backslash\n        } else {\n          input = input.slice(0, i) + \"/\" + input.slice(i + 1); // replace delimiter with slash\n        }\n\n        break;\n      case CODE_SLASH:\n        if (afterBackslash) {\n          input = input.slice(0, i) + \"\\\\\\\\\" + input.slice(i), i += 2, n += 2; // add two backslashes\n        } else {\n          input = input.slice(0, i) + \"\\\\\" + input.slice(i), ++i, ++n; // add backslash\n        }\n\n        break;\n    }\n    afterBackslash = false;\n  }\n  return input;\n}\nfunction slashUnescape(input) {\n  let afterBackslash = false;\n  for (let i = 0, n = input.length; i < n; ++i) {\n    switch (input.charCodeAt(i)) {\n      case CODE_BACKSLASH:\n        if (!afterBackslash) {\n          afterBackslash = true;\n          continue;\n        }\n      // eslint-disable-next-line no-fallthrough\n      case CODE_SLASH:\n        if (afterBackslash) {\n          input = input.slice(0, i - 1) + input.slice(i), --i, --n; // remove backslash\n        }\n\n        break;\n    }\n    afterBackslash = false;\n  }\n  return input;\n}\nfunction isNodeValue(option) {\n  return isObject(option) && typeof option.node === \"function\";\n}\nfunction isLinkValue(option) {\n  return isObject(option) && typeof option.link === \"function\";\n}\nfunction maybeNodeValue(value) {\n  if (isNodeValue(value)) return value.node;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\")) return;\n  switch (value) {\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:external\":\n      return nodeExternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid node value: ${value}`);\n}\nfunction maybeLinkValue(value) {\n  if (isNodeValue(value)) return value.node;\n  if (isLinkValue(value)) return value.link;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\") && !value.startsWith(\"parent:\")) return;\n  switch (value) {\n    case \"parent:name\":\n      return parentValue(nodeName);\n    case \"parent:path\":\n      return parentValue(nodePath);\n    case \"parent:depth\":\n      return parentValue(nodeDepth);\n    case \"parent:height\":\n      return parentValue(nodeHeight);\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:external\":\n      return nodeExternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid link value: ${value}`);\n}\nfunction nodePath(node) {\n  return node.id;\n}\nfunction nodeName(node) {\n  return nameof(node.id);\n}\nfunction nodeDepth(node) {\n  return node.depth;\n}\nfunction nodeHeight(node) {\n  return node.height;\n}\nfunction nodeInternal(node) {\n  return !!node.children;\n}\nfunction nodeExternal(node) {\n  return !node.children;\n}\nfunction parentValue(evaluate) {\n  return (child, parent) => parent == null ? undefined : evaluate(parent);\n}\n\n// Walk backwards to find the first slash.\nfunction nameof(path) {\n  let i = path.length;\n  while (--i > 0) if (slash(path, i)) break;\n  return slashUnescape(path.slice(i + 1));\n}\n\n// Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n    if ((k & 1) === 0) return true;\n  }\n  return false;\n}\n\n// These indexes match the array returned by nodeOutputs. The first two elements\n// are always the name of the output and its column value definition so that\n// the outputs can be passed directly to Object.fromEntries.\nconst output_setValues = 2;\nconst output_evaluate = 3;\nconst output_values = 4;\nfunction treeOutputs(options, maybeTreeValue) {\n  const outputs = [];\n  for (const name in options) {\n    const value = options[name];\n    const treeValue = maybeTreeValue(value);\n    if (treeValue !== undefined) {\n      outputs.push([name, ...column(value), treeValue]);\n    }\n  }\n  return outputs;\n}","map":{"version":3,"names":["stratify","tree","ascendingDefined","column","identity","isArray","isObject","one","valueof","basic","treeNode","path","delimiter","frameAnchor","treeLayout","treeSort","treeSeparation","treeAnchor","treeFilter","options","maybeTreeAnchor","maybeTreeSort","maybeNodeValue","undefined","normalize","normalizer","outputs","treeOutputs","X","setX","Y","setY","x","y","data","facets","P","treeIndex","treeData","treeFacets","rootof","i","setData","node","get","layout","nodeSize","separation","o","output_values","output_setValues","facet","treeFacet","root","filter","each","sort","descendants","push","position","output_evaluate","Object","fromEntries","treeLink","curve","stroke","strokeWidth","strokeOpacity","maybeLinkValue","X1","setX1","X2","setX2","Y1","setY1","Y2","setY2","x1","x2","y1","y2","source","target","links","anchor","trim","toLowerCase","treeAnchorLeft","treeAnchorRight","Error","dx","startsWith","nodeSort","nodeData","value","a","b","field","length","delimiterCode","charCodeAt","map","p","slashDelimiter","CODE_BACKSLASH","CODE_SLASH","input","afterBackslash","n","slice","slashUnescape","isNodeValue","option","isLinkValue","link","nodeName","nodePath","nodeInternal","nodeExternal","nodeDepth","nodeHeight","parentValue","id","nameof","depth","height","children","evaluate","child","parent","slash","k","maybeTreeValue","name","treeValue"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/tree.js"],"sourcesContent":["import {stratify, tree} from \"d3\";\nimport {ascendingDefined} from \"../defined.js\";\nimport {column, identity, isArray, isObject, one, valueof} from \"../options.js\";\nimport {basic} from \"./basic.js\";\n\nexport function treeNode({\n  path = identity, // the delimited path\n  delimiter, // how the path is separated\n  frameAnchor,\n  treeLayout = tree,\n  treeSort,\n  treeSeparation,\n  treeAnchor,\n  treeFilter,\n  ...options\n} = {}) {\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (treeFilter != null) treeFilter = maybeNodeValue(treeFilter);\n  if (frameAnchor === undefined) frameAnchor = treeAnchor.frameAnchor;\n  const normalize = normalizer(delimiter);\n  const outputs = treeOutputs(options, maybeNodeValue);\n  const [X, setX] = column();\n  const [Y, setY] = column();\n  return {\n    x: X,\n    y: Y,\n    frameAnchor,\n    ...basic(options, (data, facets) => {\n      const P = normalize(valueof(data, path));\n      const X = setX([]);\n      const Y = setY([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify().path((i) => P[i]);\n      const setData = isArray(data)\n        ? (node) => (node.data = data[node.data])\n        : (node) => (node.data = data.get(node.data));\n      const layout = treeLayout();\n      if (layout.nodeSize) layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== undefined) layout.separation(treeSeparation ?? one);\n      for (const o of outputs) o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root = rootof(facet.filter((i) => P[i] != null)).each(setData);\n        if (treeSort != null) root.sort(treeSort);\n        layout(root);\n        for (const node of root.descendants()) {\n          if (treeFilter != null && !treeFilter(node)) continue;\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = node.data;\n          treeAnchor.position(node, treeIndex, X, Y);\n          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](node);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return {data: treeData, facets: treeFacets};\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\n\nexport function treeLink({\n  path = identity, // the delimited path\n  delimiter, // how the path is separated\n  curve = \"bump-x\",\n  stroke = \"#555\",\n  strokeWidth = 1.5,\n  strokeOpacity = 0.5,\n  treeLayout = tree,\n  treeSort,\n  treeSeparation,\n  treeAnchor,\n  treeFilter,\n  ...options\n} = {}) {\n  treeAnchor = maybeTreeAnchor(treeAnchor);\n  treeSort = maybeTreeSort(treeSort);\n  if (treeFilter != null) treeFilter = maybeLinkValue(treeFilter);\n  options = {curve, stroke, strokeWidth, strokeOpacity, ...options};\n  const normalize = normalizer(delimiter);\n  const outputs = treeOutputs(options, maybeLinkValue);\n  const [X1, setX1] = column();\n  const [X2, setX2] = column();\n  const [Y1, setY1] = column();\n  const [Y2, setY2] = column();\n  return {\n    x1: X1,\n    x2: X2,\n    y1: Y1,\n    y2: Y2,\n    ...basic(options, (data, facets) => {\n      const P = normalize(valueof(data, path));\n      const X1 = setX1([]);\n      const X2 = setX2([]);\n      const Y1 = setY1([]);\n      const Y2 = setY2([]);\n      let treeIndex = -1;\n      const treeData = [];\n      const treeFacets = [];\n      const rootof = stratify().path((i) => P[i]);\n      const layout = treeLayout();\n      if (layout.nodeSize) layout.nodeSize([1, 1]);\n      if (layout.separation && treeSeparation !== undefined) layout.separation(treeSeparation ?? one);\n      for (const o of outputs) o[output_values] = o[output_setValues]([]);\n      for (const facet of facets) {\n        const treeFacet = [];\n        const root = rootof(facet.filter((i) => P[i] != null)).each((node) => (node.data = data[node.data]));\n        if (treeSort != null) root.sort(treeSort);\n        layout(root);\n        for (const {source, target} of root.links()) {\n          if (treeFilter != null && !treeFilter(target, source)) continue;\n          treeFacet.push(++treeIndex);\n          treeData[treeIndex] = target.data;\n          treeAnchor.position(source, treeIndex, X1, Y1);\n          treeAnchor.position(target, treeIndex, X2, Y2);\n          for (const o of outputs) o[output_values][treeIndex] = o[output_evaluate](target, source);\n        }\n        treeFacets.push(treeFacet);\n      }\n      return {data: treeData, facets: treeFacets};\n    }),\n    ...Object.fromEntries(outputs)\n  };\n}\n\nexport function maybeTreeAnchor(anchor = \"left\") {\n  switch (`${anchor}`.trim().toLowerCase()) {\n    case \"left\":\n      return treeAnchorLeft;\n    case \"right\":\n      return treeAnchorRight;\n  }\n  throw new Error(`invalid tree anchor: ${anchor}`);\n}\n\nconst treeAnchorLeft = {\n  frameAnchor: \"left\",\n  dx: 6,\n  position({x, y}, i, X, Y) {\n    X[i] = y;\n    Y[i] = -x;\n  }\n};\n\nconst treeAnchorRight = {\n  frameAnchor: \"right\",\n  dx: -6,\n  position({x, y}, i, X, Y) {\n    X[i] = -y;\n    Y[i] = -x;\n  }\n};\n\nfunction maybeTreeSort(sort) {\n  return sort == null || typeof sort === \"function\"\n    ? sort\n    : `${sort}`.trim().toLowerCase().startsWith(\"node:\")\n    ? nodeSort(maybeNodeValue(sort))\n    : nodeSort(nodeData(sort));\n}\n\nfunction nodeSort(value) {\n  return (a, b) => ascendingDefined(value(a), value(b));\n}\n\nfunction nodeData(field) {\n  return (node) => node.data?.[field];\n}\n\nfunction normalizer(delimiter = \"/\") {\n  delimiter = `${delimiter}`;\n  if (delimiter === \"/\") return (P) => P; // paths are already slash-separated\n  if (delimiter.length !== 1) throw new Error(\"delimiter must be exactly one character\");\n  const delimiterCode = delimiter.charCodeAt(0);\n  return (P) => P.map((p) => slashDelimiter(p, delimiterCode));\n}\n\nconst CODE_BACKSLASH = 92;\nconst CODE_SLASH = 47;\n\nfunction slashDelimiter(input, delimiterCode) {\n  if (delimiterCode === CODE_BACKSLASH) throw new Error(\"delimiter cannot be backslash\");\n  let afterBackslash = false;\n  for (let i = 0, n = input.length; i < n; ++i) {\n    switch (input.charCodeAt(i)) {\n      case CODE_BACKSLASH:\n        if (!afterBackslash) {\n          afterBackslash = true;\n          continue;\n        }\n        break;\n      case delimiterCode:\n        if (afterBackslash) {\n          (input = input.slice(0, i - 1) + input.slice(i)), --i, --n; // remove backslash\n        } else {\n          input = input.slice(0, i) + \"/\" + input.slice(i + 1); // replace delimiter with slash\n        }\n        break;\n      case CODE_SLASH:\n        if (afterBackslash) {\n          (input = input.slice(0, i) + \"\\\\\\\\\" + input.slice(i)), (i += 2), (n += 2); // add two backslashes\n        } else {\n          (input = input.slice(0, i) + \"\\\\\" + input.slice(i)), ++i, ++n; // add backslash\n        }\n        break;\n    }\n    afterBackslash = false;\n  }\n  return input;\n}\n\nfunction slashUnescape(input) {\n  let afterBackslash = false;\n  for (let i = 0, n = input.length; i < n; ++i) {\n    switch (input.charCodeAt(i)) {\n      case CODE_BACKSLASH:\n        if (!afterBackslash) {\n          afterBackslash = true;\n          continue;\n        }\n      // eslint-disable-next-line no-fallthrough\n      case CODE_SLASH:\n        if (afterBackslash) {\n          (input = input.slice(0, i - 1) + input.slice(i)), --i, --n; // remove backslash\n        }\n        break;\n    }\n    afterBackslash = false;\n  }\n  return input;\n}\n\nfunction isNodeValue(option) {\n  return isObject(option) && typeof option.node === \"function\";\n}\n\nfunction isLinkValue(option) {\n  return isObject(option) && typeof option.link === \"function\";\n}\n\nfunction maybeNodeValue(value) {\n  if (isNodeValue(value)) return value.node;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\")) return;\n  switch (value) {\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:external\":\n      return nodeExternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid node value: ${value}`);\n}\n\nfunction maybeLinkValue(value) {\n  if (isNodeValue(value)) return value.node;\n  if (isLinkValue(value)) return value.link;\n  value = `${value}`.trim().toLowerCase();\n  if (!value.startsWith(\"node:\") && !value.startsWith(\"parent:\")) return;\n  switch (value) {\n    case \"parent:name\":\n      return parentValue(nodeName);\n    case \"parent:path\":\n      return parentValue(nodePath);\n    case \"parent:depth\":\n      return parentValue(nodeDepth);\n    case \"parent:height\":\n      return parentValue(nodeHeight);\n    case \"node:name\":\n      return nodeName;\n    case \"node:path\":\n      return nodePath;\n    case \"node:internal\":\n      return nodeInternal;\n    case \"node:external\":\n      return nodeExternal;\n    case \"node:depth\":\n      return nodeDepth;\n    case \"node:height\":\n      return nodeHeight;\n  }\n  throw new Error(`invalid link value: ${value}`);\n}\n\nfunction nodePath(node) {\n  return node.id;\n}\n\nfunction nodeName(node) {\n  return nameof(node.id);\n}\n\nfunction nodeDepth(node) {\n  return node.depth;\n}\n\nfunction nodeHeight(node) {\n  return node.height;\n}\n\nfunction nodeInternal(node) {\n  return !!node.children;\n}\n\nfunction nodeExternal(node) {\n  return !node.children;\n}\n\nfunction parentValue(evaluate) {\n  return (child, parent) => (parent == null ? undefined : evaluate(parent));\n}\n\n// Walk backwards to find the first slash.\nfunction nameof(path) {\n  let i = path.length;\n  while (--i > 0) if (slash(path, i)) break;\n  return slashUnescape(path.slice(i + 1));\n}\n\n// Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n    if ((k & 1) === 0) return true;\n  }\n  return false;\n}\n\n// These indexes match the array returned by nodeOutputs. The first two elements\n// are always the name of the output and its column value definition so that\n// the outputs can be passed directly to Object.fromEntries.\nconst output_setValues = 2;\nconst output_evaluate = 3;\nconst output_values = 4;\n\nfunction treeOutputs(options, maybeTreeValue) {\n  const outputs = [];\n  for (const name in options) {\n    const value = options[name];\n    const treeValue = maybeTreeValue(value);\n    if (treeValue !== undefined) {\n      outputs.push([name, ...column(value), treeValue]);\n    }\n  }\n  return outputs;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}