{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeProp } from '@lezer/common';\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n  /// @internal\n  constructor(\n  /// The set of this tag and all its parent tags, starting with\n  /// this one itself and sorted in order of decreasing specificity.\n  set,\n  /// The base unmodified tag that this one is based on, if it's\n  /// modified @internal\n  base,\n  /// The modifiers applied to this.base @internal\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    /// @internal\n    this.id = nextTagID++;\n  }\n  /// Define a new tag. If `parent` is given, the tag is treated as a\n  /// sub-tag of that parent, and\n  /// [highlighters](#highlight.tagHighlighter) that don't mention\n  /// this tag will try to fall back to the parent tag (or grandparent\n  /// tag, etc).\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  }\n  /// Define a tag _modifier_, which is a function that, given a tag,\n  /// will return a tag that is a subtag of the original. Applying the\n  /// same modifier to a twice tag will return the same value (`m1(t1)\n  /// == m1(t1)`) and applying multiple modifiers will, regardless or\n  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  ///\n  /// When multiple modifiers are applied to a given base tag, each\n  /// smaller set of modifiers is registered as a parent, so that for\n  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  /// `m1(m3(t1)`, and so on.\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n}\nlet nextModifierID = 0;\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n      tag = new Tag(set, base, mods);\n    for (let m of mods) m.instances.push(tag);\n    let configs = permute(mods);\n    for (let parent of base.set) for (let config of configs) set.push(Modifier.get(parent, config));\n    return tag;\n  }\n}\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n  let result = [array];\n  for (let i = 0; i < array.length; i++) {\n    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1)))) result.push(a);\n  }\n  return result;\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single level—wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n        mode = 2 /* Normal */,\n        rest = part;\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1 /* Inherit */;\n          break;\n        }\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n        if (pos == part.length && next == \"!\") {\n          mode = 0 /* Opaque */;\n          break;\n        }\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n      let last = pieces.length - 1,\n        inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n  return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n    other.next = this.sort(other.next);\n    return other;\n  }\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n}\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n  let map = Object.create(null);\n  for (let style of tags) {\n    if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else for (let tag of style.tag) map[tag.id] = style.class;\n  }\n  let {\n    scope,\n    all = null\n  } = options || {};\n  return {\n    style: tags => {\n      let cls = all;\n      for (let tag of tags) {\n        for (let sub of tag.set) {\n          let tagClass = map[sub.id];\n          if (tagClass) {\n            cls = cls ? cls + \" \" + tagClass : tagClass;\n            break;\n          }\n        }\n      }\n      return cls;\n    },\n    scope: scope\n  };\n}\nfunction highlightTags(highlighters, tags) {\n  let result = null;\n  for (let highlighter of highlighters) {\n    let value = highlighter.style(tags);\n    if (value) result = result ? result + \" \" + value : value;\n  }\n  return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter,\n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle,\n/// The start of the range to highlight.\nfrom = 0,\n/// The end of the range.\nto = tree.length) {\n  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n  builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n  builder.flush(to);\n}\nclass HighlightBuilder {\n  constructor(at, highlighters, span) {\n    this.at = at;\n    this.highlighters = highlighters;\n    this.span = span;\n    this.class = \"\";\n  }\n  startSpan(at, cls) {\n    if (cls != this.class) {\n      this.flush(at);\n      if (at > this.at) this.at = at;\n      this.class = cls;\n    }\n  }\n  flush(to) {\n    if (to > this.at && this.class) this.span(this.at, to, this.class);\n  }\n  highlightRange(cursor, from, to, inheritedClass, highlighters) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    if (type.isTop) highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n    let cls = inheritedClass;\n    let rule = type.prop(ruleNodeProp),\n      opaque = false;\n    while (rule) {\n      if (!rule.context || cursor.matchContext(rule.context)) {\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n          if (cls) cls += \" \";\n          cls += tagCls;\n          if (rule.mode == 1 /* Inherit */) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;else if (rule.mode == 0 /* Opaque */) opaque = true;\n        }\n        break;\n      }\n      rule = rule.next;\n    }\n    this.startSpan(cursor.from, cls);\n    if (opaque) return;\n    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n    if (mounted && mounted.overlay) {\n      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n      let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n      let hasChild = cursor.firstChild();\n      for (let i = 0, pos = start;; i++) {\n        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n        let nextPos = next ? next.from + start : end;\n        let rangeFrom = Math.max(from, pos),\n          rangeTo = Math.min(to, nextPos);\n        if (rangeFrom < rangeTo && hasChild) {\n          while (cursor.from < rangeTo) {\n            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n            this.startSpan(Math.min(to, cursor.to), cls);\n            if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n          }\n        }\n        if (!next || nextPos > to) break;\n        pos = next.to + start;\n        if (pos > from) {\n          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n          this.startSpan(pos, cls);\n        }\n      }\n      if (hasChild) cursor.parent();\n    } else if (cursor.firstChild()) {\n      do {\n        if (cursor.to <= from) continue;\n        if (cursor.from >= to) break;\n        this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n        this.startSpan(Math.min(to, cursor.to), cls);\n      } while (cursor.nextSibling());\n      cursor.parent();\n    }\n  }\n}\nconst t = Tag.define;\nconst comment = t(),\n  name = t(),\n  typeName = t(name),\n  propertyName = t(name),\n  literal = t(),\n  string = t(literal),\n  number = t(literal),\n  content = t(),\n  heading = t(content),\n  keyword = t(),\n  operator = t(),\n  punctuation = t(),\n  bracket = t(punctuation),\n  meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an element—if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n  /// A comment.\n  comment,\n  /// A line [comment](#highlight.tags.comment).\n  lineComment: t(comment),\n  /// A block [comment](#highlight.tags.comment).\n  blockComment: t(comment),\n  /// A documentation [comment](#highlight.tags.comment).\n  docComment: t(comment),\n  /// Any kind of identifier.\n  name,\n  /// The [name](#highlight.tags.name) of a variable.\n  variableName: t(name),\n  /// A type [name](#highlight.tags.name).\n  typeName: typeName,\n  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  tagName: t(typeName),\n  /// A property or field [name](#highlight.tags.name).\n  propertyName: propertyName,\n  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  attributeName: t(propertyName),\n  /// The [name](#highlight.tags.name) of a class.\n  className: t(name),\n  /// A label [name](#highlight.tags.name).\n  labelName: t(name),\n  /// A namespace [name](#highlight.tags.name).\n  namespace: t(name),\n  /// The [name](#highlight.tags.name) of a macro.\n  macroName: t(name),\n  /// A literal value.\n  literal,\n  /// A string [literal](#highlight.tags.literal).\n  string,\n  /// A documentation [string](#highlight.tags.string).\n  docString: t(string),\n  /// A character literal (subtag of [string](#highlight.tags.string)).\n  character: t(string),\n  /// An attribute value (subtag of [string](#highlight.tags.string)).\n  attributeValue: t(string),\n  /// A number [literal](#highlight.tags.literal).\n  number,\n  /// An integer [number](#highlight.tags.number) literal.\n  integer: t(number),\n  /// A floating-point [number](#highlight.tags.number) literal.\n  float: t(number),\n  /// A boolean [literal](#highlight.tags.literal).\n  bool: t(literal),\n  /// Regular expression [literal](#highlight.tags.literal).\n  regexp: t(literal),\n  /// An escape [literal](#highlight.tags.literal), for example a\n  /// backslash escape in a string.\n  escape: t(literal),\n  /// A color [literal](#highlight.tags.literal).\n  color: t(literal),\n  /// A URL [literal](#highlight.tags.literal).\n  url: t(literal),\n  /// A language keyword.\n  keyword,\n  /// The [keyword](#highlight.tags.keyword) for the self or this\n  /// object.\n  self: t(keyword),\n  /// The [keyword](#highlight.tags.keyword) for null.\n  null: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  atom: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that represents a unit.\n  unit: t(keyword),\n  /// A modifier [keyword](#highlight.tags.keyword).\n  modifier: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n  operatorKeyword: t(keyword),\n  /// A control-flow related [keyword](#highlight.tags.keyword).\n  controlKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that defines something.\n  definitionKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) related to defining or\n  /// interfacing with modules.\n  moduleKeyword: t(keyword),\n  /// An operator.\n  operator,\n  /// An [operator](#highlight.tags.operator) that defines something.\n  derefOperator: t(operator),\n  /// Arithmetic-related [operator](#highlight.tags.operator).\n  arithmeticOperator: t(operator),\n  /// Logical [operator](#highlight.tags.operator).\n  logicOperator: t(operator),\n  /// Bit [operator](#highlight.tags.operator).\n  bitwiseOperator: t(operator),\n  /// Comparison [operator](#highlight.tags.operator).\n  compareOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that updates its operand.\n  updateOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that defines something.\n  definitionOperator: t(operator),\n  /// Type-related [operator](#highlight.tags.operator).\n  typeOperator: t(operator),\n  /// Control-flow [operator](#highlight.tags.operator).\n  controlOperator: t(operator),\n  /// Program or markup punctuation.\n  punctuation,\n  /// [Punctuation](#highlight.tags.punctuation) that separates\n  /// things.\n  separator: t(punctuation),\n  /// Bracket-style [punctuation](#highlight.tags.punctuation).\n  bracket,\n  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  /// tokens).\n  angleBracket: t(bracket),\n  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  /// tokens).\n  squareBracket: t(bracket),\n  /// Parentheses (usually `(` and `)` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  paren: t(bracket),\n  /// Braces (usually `{` and `}` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  brace: t(bracket),\n  /// Content, for example plain text in XML or markup documents.\n  content,\n  /// [Content](#highlight.tags.content) that represents a heading.\n  heading,\n  /// A level 1 [heading](#highlight.tags.heading).\n  heading1: t(heading),\n  /// A level 2 [heading](#highlight.tags.heading).\n  heading2: t(heading),\n  /// A level 3 [heading](#highlight.tags.heading).\n  heading3: t(heading),\n  /// A level 4 [heading](#highlight.tags.heading).\n  heading4: t(heading),\n  /// A level 5 [heading](#highlight.tags.heading).\n  heading5: t(heading),\n  /// A level 6 [heading](#highlight.tags.heading).\n  heading6: t(heading),\n  /// A prose separator (such as a horizontal rule).\n  contentSeparator: t(content),\n  /// [Content](#highlight.tags.content) that represents a list.\n  list: t(content),\n  /// [Content](#highlight.tags.content) that represents a quote.\n  quote: t(content),\n  /// [Content](#highlight.tags.content) that is emphasized.\n  emphasis: t(content),\n  /// [Content](#highlight.tags.content) that is styled strong.\n  strong: t(content),\n  /// [Content](#highlight.tags.content) that is part of a link.\n  link: t(content),\n  /// [Content](#highlight.tags.content) that is styled as code or\n  /// monospace.\n  monospace: t(content),\n  /// [Content](#highlight.tags.content) that has a strike-through\n  /// style.\n  strikethrough: t(content),\n  /// Inserted text in a change-tracking format.\n  inserted: t(),\n  /// Deleted text.\n  deleted: t(),\n  /// Changed text.\n  changed: t(),\n  /// An invalid or unsyntactic element.\n  invalid: t(),\n  /// Metadata or meta-instruction.\n  meta,\n  /// [Metadata](#highlight.tags.meta) that applies to the entire\n  /// document.\n  documentMeta: t(meta),\n  /// [Metadata](#highlight.tags.meta) that annotates or adds\n  /// attributes to a given syntactic element.\n  annotation: t(meta),\n  /// Processing instruction or preprocessor directive. Subtag of\n  /// [meta](#highlight.tags.meta).\n  processingInstruction: t(meta),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  /// given element is being defined. Expected to be used with the\n  /// various [name](#highlight.tags.name) tags.\n  definition: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n  /// something is constant. Mostly expected to be used with\n  /// [variable names](#highlight.tags.variableName).\n  constant: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  /// a [variable](#highlight.tags.variableName) or [property\n  /// name](#highlight.tags.propertyName) is being called or defined\n  /// as a function.\n  function: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  /// [names](#highlight.tags.name) to indicate that they belong to\n  /// the language's standard environment.\n  standard: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  /// [names](#highlight.tags.name) is local to some scope.\n  local: Tag.defineModifier(),\n  /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n  /// can be used to tag language-specific alternative variants of\n  /// some common tag. It is recommended for themes to define special\n  /// forms of at least the [string](#highlight.tags.string) and\n  /// [variable name](#highlight.tags.variableName) tags, since those\n  /// come up a lot.\n  special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom) [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([{\n  tag: tags.link,\n  class: \"tok-link\"\n}, {\n  tag: tags.heading,\n  class: \"tok-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"tok-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"tok-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"tok-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"tok-atom\"\n}, {\n  tag: tags.bool,\n  class: \"tok-bool\"\n}, {\n  tag: tags.url,\n  class: \"tok-url\"\n}, {\n  tag: tags.labelName,\n  class: \"tok-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"tok-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"tok-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"tok-literal\"\n}, {\n  tag: tags.string,\n  class: \"tok-string\"\n}, {\n  tag: tags.number,\n  class: \"tok-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"tok-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"tok-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"tok-variableName tok-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"tok-variableName tok-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"tok-variableName2\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  class: \"tok-propertyName tok-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"tok-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"tok-namespace\"\n}, {\n  tag: tags.className,\n  class: \"tok-className\"\n}, {\n  tag: tags.macroName,\n  class: \"tok-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"tok-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"tok-operator\"\n}, {\n  tag: tags.comment,\n  class: \"tok-comment\"\n}, {\n  tag: tags.meta,\n  class: \"tok-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"tok-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"tok-punctuation\"\n}]);\nexport { Tag, classHighlighter, highlightTags, highlightTree, styleTags, tagHighlighter, tags };","map":{"version":3,"names":["NodeProp","nextTagID","Tag","constructor","set","base","modified","id","define","parent","Error","tag","push","t","defineModifier","mod","Modifier","indexOf","get","concat","sort","a","b","nextModifierID","instances","mods","length","exists","find","sameArray","m","configs","permute","config","every","x","i","array","result","slice","styleTags","spec","byName","Object","create","prop","tags","Array","isArray","part","split","pieces","mode","rest","pos","exec","RangeError","JSON","parse","next","last","inner","rule","Rule","ruleNodeProp","add","context","other","depth","tagHighlighter","options","map","style","class","scope","all","cls","sub","tagClass","highlightTags","highlighters","highlighter","value","highlightTree","tree","putStyle","from","to","builder","HighlightBuilder","highlightRange","cursor","flush","at","span","startSpan","inheritedClass","type","start","end","isTop","filter","h","opaque","matchContext","tagCls","mounted","overlay","node","enter","innerHighlighters","hasChild","firstChild","nextPos","rangeFrom","Math","max","rangeTo","min","nextSibling","comment","name","typeName","propertyName","literal","string","number","content","heading","keyword","operator","punctuation","bracket","meta","lineComment","blockComment","docComment","variableName","tagName","attributeName","className","labelName","namespace","macroName","docString","character","attributeValue","integer","float","bool","regexp","escape","color","url","self","null","atom","unit","modifier","operatorKeyword","controlKeyword","definitionKeyword","moduleKeyword","derefOperator","arithmeticOperator","logicOperator","bitwiseOperator","compareOperator","updateOperator","definitionOperator","typeOperator","controlOperator","separator","angleBracket","squareBracket","paren","brace","heading1","heading2","heading3","heading4","heading5","heading6","contentSeparator","list","quote","emphasis","strong","link","monospace","strikethrough","inserted","deleted","changed","invalid","documentMeta","annotation","processingInstruction","definition","constant","function","standard","local","special","classHighlighter"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@codemirror/commands/node_modules/@lezer/highlight/dist/index.js"],"sourcesContent":["import { NodeProp } from '@lezer/common';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of this tag and all its parent tags, starting with\n    /// this one itself and sorted in order of decreasing specificity.\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and\n    /// [highlighters](#highlight.tagHighlighter) that don't mention\n    /// this tag will try to fall back to the parent tag (or grandparent\n    /// tag, etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = permute(mods);\n        for (let parent of base.set)\n            for (let config of configs)\n                set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n    let result = [array];\n    for (let i = 0; i < array.length; i++) {\n        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))\n            result.push(a);\n    }\n    return result;\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single level—wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope: scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter, \n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle, \n/// The start of the range to highlight.\nfrom = 0, \n/// The end of the range.\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = type.prop(ruleNodeProp), opaque = false;\n        while (rule) {\n            if (!rule.context || cursor.matchContext(rule.context)) {\n                let tagCls = highlightTags(highlighters, rule.tags);\n                if (tagCls) {\n                    if (cls)\n                        cls += \" \";\n                    cls += tagCls;\n                    if (rule.mode == 1 /* Inherit */)\n                        inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n                    else if (rule.mode == 0 /* Opaque */)\n                        opaque = true;\n                }\n                break;\n            }\n            rule = rule.next;\n        }\n        this.startSpan(cursor.from, cls);\n        if (opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(to, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n                    this.startSpan(pos, cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an element—if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type [name](#highlight.tags.name).\n    typeName: typeName,\n    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    tagName: t(typeName),\n    /// A property or field [name](#highlight.tags.name).\n    propertyName: propertyName,\n    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    attributeName: t(propertyName),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// An attribute value (subtag of [string](#highlight.tags.string)).\n    attributeValue: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) related to defining or\n    /// interfacing with modules.\n    moduleKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that defines something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// A prose separator (such as a horizontal rule).\n    contentSeparator: t(content),\n    /// [Content](#highlight.tags.content) that represents a list.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// [Content](#highlight.tags.content) that has a strike-through\n    /// style.\n    strikethrough: t(content),\n    /// Inserted text in a change-tracking format.\n    inserted: t(),\n    /// Deleted text.\n    deleted: t(),\n    /// Changed text.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    /// a [variable](#highlight.tags.variableName) or [property\n    /// name](#highlight.tags.propertyName) is being called or defined\n    /// as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the language's standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom) [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\nexport { Tag, classHighlighter, highlightTags, highlightTree, styleTags, tagHighlighter, tags };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}