{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { getSource } from \"../channel.js\";\nimport { pointer, pointerX, pointerY } from \"../interactions/pointer.js\";\nimport { marks } from \"../mark.js\";\nimport { initializer } from \"../transforms/basic.js\";\nimport { ruleX, ruleY } from \"./rule.js\";\nimport { text } from \"./text.js\";\nexport function crosshair(data, options) {\n  return crosshairK(pointer, data, options);\n}\nexport function crosshairX(data, options = {}) {\n  return crosshairK(pointerX, data, options);\n}\nexport function crosshairY(data, options = {}) {\n  return crosshairK(pointerY, data, options);\n}\nfunction crosshairK(pointer, data, options = {}) {\n  const {\n    x,\n    y,\n    maxRadius\n  } = options;\n  const p = pointer({\n    px: x,\n    py: y,\n    maxRadius\n  });\n  const M = [];\n  if (x != null) M.push(ruleX(data, ruleOptions(\"x\", {\n    ...p,\n    inset: -6\n  }, options)));\n  if (y != null) M.push(ruleY(data, ruleOptions(\"y\", {\n    ...p,\n    inset: -6\n  }, options)));\n  if (x != null) M.push(text(data, textOptions(\"x\", {\n    ...p,\n    dy: 9,\n    frameAnchor: \"bottom\",\n    lineAnchor: \"top\"\n  }, options)));\n  if (y != null) M.push(text(data, textOptions(\"y\", {\n    ...p,\n    dx: -9,\n    frameAnchor: \"left\",\n    textAnchor: \"end\"\n  }, options)));\n  for (const m of M) m.ariaLabel = `crosshair ${m.ariaLabel}`;\n  return marks(...M);\n}\nfunction markOptions(k, {\n  channels: pointerChannels,\n  ...pointerOptions\n}, {\n  facet,\n  facetAnchor,\n  fx,\n  fy,\n  [k]: p,\n  channels,\n  transform,\n  initializer\n}) {\n  return {\n    ...pointerOptions,\n    facet,\n    facetAnchor,\n    fx,\n    fy,\n    [k]: p,\n    channels: {\n      ...pointerChannels,\n      ...channels\n    },\n    transform,\n    initializer: pxpy(k, initializer)\n  };\n}\n\n// Wrap the initializer, if any, mapping px and py to x and y temporarily (e.g.,\n// for hexbin) then mapping back to px and py for rendering.\nfunction pxpy(k, i) {\n  if (i == null) return i;\n  return function (data, facets, {\n    x: x1,\n    y: y1,\n    px,\n    py,\n    ...c1\n  }, ...args) {\n    const {\n      channels: {\n        x,\n        y,\n        ...c\n      } = {},\n      ...rest\n    } = i.call(this, data, facets, {\n      ...c1,\n      x: px,\n      y: py\n    }, ...args);\n    return {\n      channels: {\n        ...c,\n        ...(x && {\n          px: x,\n          ...(k === \"x\" && {\n            x\n          })\n        }),\n        ...(y && {\n          py: y,\n          ...(k === \"y\" && {\n            y\n          })\n        })\n      },\n      ...rest\n    };\n  };\n}\nfunction ruleOptions(k, pointerOptions, options) {\n  const {\n    color = \"currentColor\",\n    opacity = 0.2,\n    ruleStroke: stroke = color,\n    ruleStrokeOpacity: strokeOpacity = opacity,\n    ruleStrokeWidth: strokeWidth\n  } = options;\n  return {\n    ...markOptions(k, pointerOptions, options),\n    stroke,\n    strokeOpacity,\n    strokeWidth\n  };\n}\nfunction textOptions(k, pointerOptions, options) {\n  const {\n    color = \"currentColor\",\n    textFill: fill = color,\n    textFillOpacity: fillOpacity,\n    textStroke: stroke = \"var(--plot-background)\",\n    textStrokeOpacity: strokeOpacity,\n    textStrokeWidth: strokeWidth = 5\n  } = options;\n  return {\n    ...markOptions(k, pointerOptions, textChannel(k, options)),\n    fill,\n    fillOpacity,\n    stroke,\n    strokeOpacity,\n    strokeWidth\n  };\n}\n\n// Rather than aliasing text to have the same definition as x and y, we use an\n// initializer to alias the channel values, such that the text channel can be\n// derived by an initializer such as hexbin.\nfunction textChannel(source, options) {\n  return initializer(options, (data, facets, channels) => {\n    return {\n      channels: {\n        text: {\n          value: getSource(channels, source)?.value\n        }\n      }\n    };\n  });\n}","map":{"version":3,"names":["getSource","pointer","pointerX","pointerY","marks","initializer","ruleX","ruleY","text","crosshair","data","options","crosshairK","crosshairX","crosshairY","x","y","maxRadius","p","px","py","M","push","ruleOptions","inset","textOptions","dy","frameAnchor","lineAnchor","dx","textAnchor","m","ariaLabel","markOptions","k","channels","pointerChannels","pointerOptions","facet","facetAnchor","fx","fy","transform","pxpy","i","facets","x1","y1","c1","args","c","rest","call","color","opacity","ruleStroke","stroke","ruleStrokeOpacity","strokeOpacity","ruleStrokeWidth","strokeWidth","textFill","fill","textFillOpacity","fillOpacity","textStroke","textStrokeOpacity","textStrokeWidth","textChannel","source","value"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/crosshair.js"],"sourcesContent":["import {getSource} from \"../channel.js\";\nimport {pointer, pointerX, pointerY} from \"../interactions/pointer.js\";\nimport {marks} from \"../mark.js\";\nimport {initializer} from \"../transforms/basic.js\";\nimport {ruleX, ruleY} from \"./rule.js\";\nimport {text} from \"./text.js\";\n\nexport function crosshair(data, options) {\n  return crosshairK(pointer, data, options);\n}\n\nexport function crosshairX(data, options = {}) {\n  return crosshairK(pointerX, data, options);\n}\n\nexport function crosshairY(data, options = {}) {\n  return crosshairK(pointerY, data, options);\n}\n\nfunction crosshairK(pointer, data, options = {}) {\n  const {x, y, maxRadius} = options;\n  const p = pointer({px: x, py: y, maxRadius});\n  const M = [];\n  if (x != null) M.push(ruleX(data, ruleOptions(\"x\", {...p, inset: -6}, options)));\n  if (y != null) M.push(ruleY(data, ruleOptions(\"y\", {...p, inset: -6}, options)));\n  if (x != null) M.push(text(data, textOptions(\"x\", {...p, dy: 9, frameAnchor: \"bottom\", lineAnchor: \"top\"}, options)));\n  if (y != null) M.push(text(data, textOptions(\"y\", {...p, dx: -9, frameAnchor: \"left\", textAnchor: \"end\"}, options)));\n  for (const m of M) m.ariaLabel = `crosshair ${m.ariaLabel}`;\n  return marks(...M);\n}\n\nfunction markOptions(\n  k,\n  {channels: pointerChannels, ...pointerOptions},\n  {facet, facetAnchor, fx, fy, [k]: p, channels, transform, initializer}\n) {\n  return {\n    ...pointerOptions,\n    facet,\n    facetAnchor,\n    fx,\n    fy,\n    [k]: p,\n    channels: {...pointerChannels, ...channels},\n    transform,\n    initializer: pxpy(k, initializer)\n  };\n}\n\n// Wrap the initializer, if any, mapping px and py to x and y temporarily (e.g.,\n// for hexbin) then mapping back to px and py for rendering.\nfunction pxpy(k, i) {\n  if (i == null) return i;\n  return function (data, facets, {x: x1, y: y1, px, py, ...c1}, ...args) {\n    const {channels: {x, y, ...c} = {}, ...rest} = i.call(this, data, facets, {...c1, x: px, y: py}, ...args);\n    return {\n      channels: {\n        ...c,\n        ...(x && {px: x, ...(k === \"x\" && {x})}),\n        ...(y && {py: y, ...(k === \"y\" && {y})})\n      },\n      ...rest\n    };\n  };\n}\n\nfunction ruleOptions(k, pointerOptions, options) {\n  const {\n    color = \"currentColor\",\n    opacity = 0.2,\n    ruleStroke: stroke = color,\n    ruleStrokeOpacity: strokeOpacity = opacity,\n    ruleStrokeWidth: strokeWidth\n  } = options;\n  return {\n    ...markOptions(k, pointerOptions, options),\n    stroke,\n    strokeOpacity,\n    strokeWidth\n  };\n}\n\nfunction textOptions(k, pointerOptions, options) {\n  const {\n    color = \"currentColor\",\n    textFill: fill = color,\n    textFillOpacity: fillOpacity,\n    textStroke: stroke = \"var(--plot-background)\",\n    textStrokeOpacity: strokeOpacity,\n    textStrokeWidth: strokeWidth = 5\n  } = options;\n  return {\n    ...markOptions(k, pointerOptions, textChannel(k, options)),\n    fill,\n    fillOpacity,\n    stroke,\n    strokeOpacity,\n    strokeWidth\n  };\n}\n\n// Rather than aliasing text to have the same definition as x and y, we use an\n// initializer to alias the channel values, such that the text channel can be\n// derived by an initializer such as hexbin.\nfunction textChannel(source, options) {\n  return initializer(options, (data, facets, channels) => {\n    return {channels: {text: {value: getSource(channels, source)?.value}}};\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}