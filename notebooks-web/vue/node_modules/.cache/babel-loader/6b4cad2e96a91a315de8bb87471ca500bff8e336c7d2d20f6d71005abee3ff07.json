{"ast":null,"code":"import { geoPath, pathRound as path } from \"d3\";\nimport { create } from \"../context.js\";\nimport { curveAuto, maybeCurveAuto } from \"../curve.js\";\nimport { Mark } from \"../mark.js\";\nimport { markers, applyMarkers } from \"../marker.js\";\nimport { coerceNumbers } from \"../options.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform } from \"../style.js\";\nconst defaults = {\n  ariaLabel: \"link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nexport class Link extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1,\n      y1,\n      x2,\n      y2,\n      curve,\n      tension\n    } = options;\n    super(data, {\n      x1: {\n        value: x1,\n        scale: \"x\"\n      },\n      y1: {\n        value: y1,\n        scale: \"y\"\n      },\n      x2: {\n        value: x2,\n        scale: \"x\",\n        optional: true\n      },\n      y2: {\n        value: y2,\n        scale: \"y\",\n        optional: true\n      }\n    }, options, defaults);\n    this.curve = maybeCurveAuto(curve, tension);\n    markers(this, options);\n  }\n  project(channels, values, context) {\n    // For the auto curve, projection is handled at render.\n    if (this.curve !== curveAuto) {\n      super.project(channels, values, context);\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x1: X1,\n      y1: Y1,\n      x2: X2 = X1,\n      y2: Y2 = Y1\n    } = channels;\n    const {\n      curve\n    } = this;\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(g => g.selectAll().data(index).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", curve === curveAuto && context.projection ? sphereLink(context.projection, X1, Y1, X2, Y2) : i => {\n      const p = path();\n      const c = curve(p);\n      c.lineStart();\n      c.point(X1[i], Y1[i]);\n      c.point(X2[i], Y2[i]);\n      c.lineEnd();\n      return p;\n    }).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)).node();\n  }\n}\nfunction sphereLink(projection, X1, Y1, X2, Y2) {\n  const path = geoPath(projection);\n  X1 = coerceNumbers(X1);\n  Y1 = coerceNumbers(Y1);\n  X2 = coerceNumbers(X2);\n  Y2 = coerceNumbers(Y2);\n  return i => path({\n    type: \"LineString\",\n    coordinates: [[X1[i], Y1[i]], [X2[i], Y2[i]]]\n  });\n}\nexport function link(data, {\n  x,\n  x1,\n  x2,\n  y,\n  y1,\n  y2,\n  ...options\n} = {}) {\n  [x1, x2] = maybeSameValue(x, x1, x2);\n  [y1, y2] = maybeSameValue(y, y1, y2);\n  return new Link(data, {\n    ...options,\n    x1,\n    x2,\n    y1,\n    y2\n  });\n}\n\n// If x1 and x2 are specified, return them as {x1, x2}.\n// If x and x1 and specified, or x and x2 are specified, return them as {x1, x2}.\n// If only x, x1, or x2 are specified, return it as {x1}.\nexport function maybeSameValue(x, x1, x2) {\n  if (x === undefined) {\n    if (x1 === undefined) {\n      if (x2 !== undefined) return [x2];\n    } else {\n      if (x2 === undefined) return [x1];\n    }\n  } else if (x1 === undefined) {\n    return x2 === undefined ? [x] : [x, x2];\n  } else if (x2 === undefined) {\n    return [x, x1];\n  }\n  return [x1, x2];\n}","map":{"version":3,"names":["geoPath","pathRound","path","create","curveAuto","maybeCurveAuto","Mark","markers","applyMarkers","coerceNumbers","applyChannelStyles","applyDirectStyles","applyIndirectStyles","applyTransform","defaults","ariaLabel","fill","stroke","strokeMiterlimit","Link","constructor","data","options","x1","y1","x2","y2","curve","tension","value","scale","optional","project","channels","values","context","render","index","scales","dimensions","X1","Y1","X2","Y2","call","g","selectAll","enter","append","attr","projection","sphereLink","i","p","c","lineStart","point","lineEnd","node","type","coordinates","link","x","y","maybeSameValue","undefined"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/link.js"],"sourcesContent":["import {geoPath, pathRound as path} from \"d3\";\nimport {create} from \"../context.js\";\nimport {curveAuto, maybeCurveAuto} from \"../curve.js\";\nimport {Mark} from \"../mark.js\";\nimport {markers, applyMarkers} from \"../marker.js\";\nimport {coerceNumbers} from \"../options.js\";\nimport {applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform} from \"../style.js\";\n\nconst defaults = {\n  ariaLabel: \"link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nexport class Link extends Mark {\n  constructor(data, options = {}) {\n    const {x1, y1, x2, y2, curve, tension} = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\"},\n        y1: {value: y1, scale: \"y\"},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true}\n      },\n      options,\n      defaults\n    );\n    this.curve = maybeCurveAuto(curve, tension);\n    markers(this, options);\n  }\n  project(channels, values, context) {\n    // For the auto curve, projection is handled at render.\n    if (this.curve !== curveAuto) {\n      super.project(channels, values, context);\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1} = channels;\n    const {curve} = this;\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .attr(\n            \"d\",\n            curve === curveAuto && context.projection\n              ? sphereLink(context.projection, X1, Y1, X2, Y2)\n              : (i) => {\n                  const p = path();\n                  const c = curve(p);\n                  c.lineStart();\n                  c.point(X1[i], Y1[i]);\n                  c.point(X2[i], Y2[i]);\n                  c.lineEnd();\n                  return p;\n                }\n          )\n          .call(applyChannelStyles, this, channels)\n          .call(applyMarkers, this, channels, context)\n      )\n      .node();\n  }\n}\n\nfunction sphereLink(projection, X1, Y1, X2, Y2) {\n  const path = geoPath(projection);\n  X1 = coerceNumbers(X1);\n  Y1 = coerceNumbers(Y1);\n  X2 = coerceNumbers(X2);\n  Y2 = coerceNumbers(Y2);\n  return (i) =>\n    path({\n      type: \"LineString\",\n      coordinates: [\n        [X1[i], Y1[i]],\n        [X2[i], Y2[i]]\n      ]\n    });\n}\n\nexport function link(data, {x, x1, x2, y, y1, y2, ...options} = {}) {\n  [x1, x2] = maybeSameValue(x, x1, x2);\n  [y1, y2] = maybeSameValue(y, y1, y2);\n  return new Link(data, {...options, x1, x2, y1, y2});\n}\n\n// If x1 and x2 are specified, return them as {x1, x2}.\n// If x and x1 and specified, or x and x2 are specified, return them as {x1, x2}.\n// If only x, x1, or x2 are specified, return it as {x1}.\nexport function maybeSameValue(x, x1, x2) {\n  if (x === undefined) {\n    if (x1 === undefined) {\n      if (x2 !== undefined) return [x2];\n    } else {\n      if (x2 === undefined) return [x1];\n    }\n  } else if (x1 === undefined) {\n    return x2 === undefined ? [x] : [x, x2];\n  } else if (x2 === undefined) {\n    return [x, x1];\n  }\n  return [x1, x2];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}