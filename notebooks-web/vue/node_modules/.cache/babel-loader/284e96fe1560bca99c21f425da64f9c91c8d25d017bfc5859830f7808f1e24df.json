{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { pointer as pointof } from \"d3\";\nimport { composeRender } from \"../mark.js\";\nimport { isArray } from \"../options.js\";\nimport { applyFrameAnchor } from \"../style.js\";\nconst states = new WeakMap();\nfunction pointerK(kx, ky, {\n  x,\n  y,\n  px,\n  py,\n  maxRadius = 40,\n  channels,\n  render,\n  ...options\n} = {}) {\n  maxRadius = +maxRadius;\n  // When px or py is used, register an extra channel that the pointer\n  // interaction can use to control which point is focused; this allows pointing\n  // to function independently of where the downstream mark (e.g., a tip) is\n  // displayed. Also default x or y to null to disable maybeTuple etc.\n  if (px != null) x ??= null, channels = {\n    ...channels,\n    px: {\n      value: px,\n      scale: \"x\"\n    }\n  };\n  if (py != null) y ??= null, channels = {\n    ...channels,\n    py: {\n      value: py,\n      scale: \"y\"\n    }\n  };\n  return {\n    x,\n    y,\n    channels,\n    ...options,\n    // Unlike other composed transforms, the render transform must be the\n    // outermost render function because it will re-render dynamically in\n    // response to pointer events.\n    render: composeRender(function (index, scales, values, dimensions, context, next) {\n      context = {\n        ...context,\n        pointerSticky: false\n      };\n      const svg = context.ownerSVGElement;\n      const {\n        data\n      } = context.getMarkState(this);\n\n      // Isolate state per-pointer, per-plot; if the pointer is reused by\n      // multiple marks, they will share the same state (e.g., sticky modality).\n      let state = states.get(svg);\n      if (!state) states.set(svg, state = {\n        sticky: false,\n        roots: [],\n        renders: []\n      });\n\n      // This serves as a unique identifier of the rendered mark per-plot; it is\n      // used to record the currently-rendered elements (state.roots) so that we\n      // can tell when a rendered element is clicked on.\n      let renderIndex = state.renders.push(render) - 1;\n\n      // For faceting, we want to compute the local coordinates of each point,\n      // which means subtracting out the facet translation, if any. (It’s\n      // tempting to do this using the local coordinates in SVG, but that’s\n      // complicated by mark-specific transforms such as dx and dy.) Also, since\n      // band scales return the upper bound of the band, we have to offset by\n      // half the bandwidth.\n      const {\n        x,\n        y,\n        fx,\n        fy\n      } = scales;\n      let tx = fx ? fx(index.fx) - dimensions.marginLeft : 0;\n      let ty = fy ? fy(index.fy) - dimensions.marginTop : 0;\n      if (x?.bandwidth) tx += x.bandwidth() / 2;\n      if (y?.bandwidth) ty += y.bandwidth() / 2;\n\n      // For faceting, we also need to record the closest point per facet per\n      // mark (!), since each facet has its own pointer event listeners; we only\n      // want the closest point across facets to be visible.\n      const faceted = index.fi != null;\n      let facetState;\n      if (faceted) {\n        let facetStates = state.facetStates;\n        if (!facetStates) state.facetStates = facetStates = new Map();\n        facetState = facetStates.get(this);\n        if (!facetState) facetStates.set(this, facetState = new Map());\n      }\n\n      // The order of precedence for the pointer position is: px & py; the\n      // middle of x1 & y1 and x2 & y2; or x1 & y1 (e.g., area); or lastly x &\n      // y. If a dimension is unspecified, the frame anchor is used.\n      const [cx, cy] = applyFrameAnchor(this, dimensions);\n      const {\n        px: PX,\n        py: PY\n      } = values;\n      const px = PX ? i => PX[i] : anchorX(values, cx);\n      const py = PY ? i => PY[i] : anchorY(values, cy);\n      let i; // currently focused index\n      let g; // currently rendered mark\n      let s; // currently rendered stickiness\n      let f; // current animation frame\n\n      // When faceting, if more than one pointer would be visible, only show\n      // this one if it is the closest. We defer rendering using an animation\n      // frame to allow all pointer events to be received before deciding which\n      // mark to render; although when hiding, we render immediately.\n      function update(ii, ri) {\n        if (faceted) {\n          if (f) f = cancelAnimationFrame(f);\n          if (ii == null) facetState.delete(index.fi);else {\n            facetState.set(index.fi, ri);\n            f = requestAnimationFrame(() => {\n              f = null;\n              for (const [fi, r] of facetState) {\n                if (r < ri || r === ri && fi < index.fi) {\n                  ii = null;\n                  break;\n                }\n              }\n              render(ii);\n            });\n            return;\n          }\n        }\n        render(ii);\n      }\n      function render(ii) {\n        if (i === ii && s === state.sticky) return; // the tooltip hasn’t moved\n        i = ii;\n        s = context.pointerSticky = state.sticky;\n        const I = i == null ? [] : [i];\n        if (faceted) I.fx = index.fx, I.fy = index.fy, I.fi = index.fi;\n        const r = next(I, scales, values, dimensions, context);\n        if (g) {\n          // When faceting, preserve swapped mark and facet transforms; also\n          // remove ARIA attributes since these are promoted to the parent. This\n          // is perhaps brittle in that it depends on how Plot renders facets,\n          // but it produces a cleaner and more accessible SVG structure.\n          if (faceted) {\n            const p = g.parentNode;\n            const ft = g.getAttribute(\"transform\");\n            const mt = r.getAttribute(\"transform\");\n            ft ? r.setAttribute(\"transform\", ft) : r.removeAttribute(\"transform\");\n            mt ? p.setAttribute(\"transform\", mt) : p.removeAttribute(\"transform\");\n            r.removeAttribute(\"aria-label\");\n            r.removeAttribute(\"aria-description\");\n            r.removeAttribute(\"aria-hidden\");\n          }\n          g.replaceWith(r);\n        }\n        state.roots[renderIndex] = g = r;\n\n        // Dispatch the value. When simultaneously exiting this facet and\n        // entering a new one, prioritize the entering facet.\n        if (!(i == null && facetState?.size > 1)) {\n          const value = i == null ? null : isArray(data) ? data[i] : data.get(i);\n          context.dispatchValue(value);\n        }\n        return r;\n      }\n\n      // Select the closest point to the mouse in the current facet; for\n      // pointerX or pointerY, the orthogonal component of the distance is\n      // squashed, selecting primarily on the dominant dimension. Across facets,\n      // use unsquashed distance to determine the winner.\n      function pointermove(event) {\n        if (state.sticky || event.pointerType === \"mouse\" && event.buttons === 1) return; // dragging\n        let [xp, yp] = pointof(event);\n        xp -= tx, yp -= ty; // correct for facets and band scales\n        const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx;\n        const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky;\n        let ii = null;\n        let ri = maxRadius * maxRadius;\n        for (const j of index) {\n          const dx = kpx * (px(j) - xp);\n          const dy = kpy * (py(j) - yp);\n          const rj = dx * dx + dy * dy;\n          if (rj <= ri) ii = j, ri = rj;\n        }\n        if (ii != null && (kx !== 1 || ky !== 1)) {\n          const dx = px(ii) - xp;\n          const dy = py(ii) - yp;\n          ri = dx * dx + dy * dy;\n        }\n        update(ii, ri);\n      }\n      function pointerdown(event) {\n        if (event.pointerType !== \"mouse\") return;\n        if (i == null) return; // not pointing\n        if (state.sticky && state.roots.some(r => r?.contains(event.target))) return; // stay sticky\n        if (state.sticky) state.sticky = false, state.renders.forEach(r => r(null)); // clear all pointers\n        else state.sticky = true, render(i);\n        event.stopImmediatePropagation(); // suppress other pointers\n      }\n\n      function pointerleave(event) {\n        if (event.pointerType !== \"mouse\") return;\n        if (!state.sticky) update(null);\n      }\n\n      // We listen to the svg element; listening to the window instead would let\n      // us receive pointer events from farther away, but would also make it\n      // hard to know when to remove the listeners. (Using a mutation observer\n      // to watch the entire document is likely too expensive.)\n      svg.addEventListener(\"pointerenter\", pointermove);\n      svg.addEventListener(\"pointermove\", pointermove);\n      svg.addEventListener(\"pointerdown\", pointerdown);\n      svg.addEventListener(\"pointerleave\", pointerleave);\n      return render(null);\n    }, render)\n  };\n}\nexport function pointer(options) {\n  return pointerK(1, 1, options);\n}\nexport function pointerX(options) {\n  return pointerK(1, 0.01, options);\n}\nexport function pointerY(options) {\n  return pointerK(0.01, 1, options);\n}\nexport function anchorX({\n  x1: X1,\n  x2: X2,\n  x: X = X1\n}, cx) {\n  return X1 && X2 ? i => (X1[i] + X2[i]) / 2 : X ? i => X[i] : () => cx;\n}\nexport function anchorY({\n  y1: Y1,\n  y2: Y2,\n  y: Y = Y1\n}, cy) {\n  return Y1 && Y2 ? i => (Y1[i] + Y2[i]) / 2 : Y ? i => Y[i] : () => cy;\n}","map":{"version":3,"names":["pointer","pointof","composeRender","isArray","applyFrameAnchor","states","WeakMap","pointerK","kx","ky","x","y","px","py","maxRadius","channels","render","options","value","scale","index","scales","values","dimensions","context","next","pointerSticky","svg","ownerSVGElement","data","getMarkState","state","get","set","sticky","roots","renders","renderIndex","push","fx","fy","tx","marginLeft","ty","marginTop","bandwidth","faceted","fi","facetState","facetStates","Map","cx","cy","PX","PY","i","anchorX","anchorY","g","s","f","update","ii","ri","cancelAnimationFrame","delete","requestAnimationFrame","r","I","p","parentNode","ft","getAttribute","mt","setAttribute","removeAttribute","replaceWith","size","dispatchValue","pointermove","event","pointerType","buttons","xp","yp","kpx","width","marginRight","kpy","height","marginBottom","j","dx","dy","rj","pointerdown","some","contains","target","forEach","stopImmediatePropagation","pointerleave","addEventListener","pointerX","pointerY","x1","X1","x2","X2","X","y1","Y1","y2","Y2","Y"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/interactions/pointer.js"],"sourcesContent":["import {pointer as pointof} from \"d3\";\nimport {composeRender} from \"../mark.js\";\nimport {isArray} from \"../options.js\";\nimport {applyFrameAnchor} from \"../style.js\";\n\nconst states = new WeakMap();\n\nfunction pointerK(kx, ky, {x, y, px, py, maxRadius = 40, channels, render, ...options} = {}) {\n  maxRadius = +maxRadius;\n  // When px or py is used, register an extra channel that the pointer\n  // interaction can use to control which point is focused; this allows pointing\n  // to function independently of where the downstream mark (e.g., a tip) is\n  // displayed. Also default x or y to null to disable maybeTuple etc.\n  if (px != null) (x ??= null), (channels = {...channels, px: {value: px, scale: \"x\"}});\n  if (py != null) (y ??= null), (channels = {...channels, py: {value: py, scale: \"y\"}});\n  return {\n    x,\n    y,\n    channels,\n    ...options,\n    // Unlike other composed transforms, the render transform must be the\n    // outermost render function because it will re-render dynamically in\n    // response to pointer events.\n    render: composeRender(function (index, scales, values, dimensions, context, next) {\n      context = {...context, pointerSticky: false};\n      const svg = context.ownerSVGElement;\n      const {data} = context.getMarkState(this);\n\n      // Isolate state per-pointer, per-plot; if the pointer is reused by\n      // multiple marks, they will share the same state (e.g., sticky modality).\n      let state = states.get(svg);\n      if (!state) states.set(svg, (state = {sticky: false, roots: [], renders: []}));\n\n      // This serves as a unique identifier of the rendered mark per-plot; it is\n      // used to record the currently-rendered elements (state.roots) so that we\n      // can tell when a rendered element is clicked on.\n      let renderIndex = state.renders.push(render) - 1;\n\n      // For faceting, we want to compute the local coordinates of each point,\n      // which means subtracting out the facet translation, if any. (It’s\n      // tempting to do this using the local coordinates in SVG, but that’s\n      // complicated by mark-specific transforms such as dx and dy.) Also, since\n      // band scales return the upper bound of the band, we have to offset by\n      // half the bandwidth.\n      const {x, y, fx, fy} = scales;\n      let tx = fx ? fx(index.fx) - dimensions.marginLeft : 0;\n      let ty = fy ? fy(index.fy) - dimensions.marginTop : 0;\n      if (x?.bandwidth) tx += x.bandwidth() / 2;\n      if (y?.bandwidth) ty += y.bandwidth() / 2;\n\n      // For faceting, we also need to record the closest point per facet per\n      // mark (!), since each facet has its own pointer event listeners; we only\n      // want the closest point across facets to be visible.\n      const faceted = index.fi != null;\n      let facetState;\n      if (faceted) {\n        let facetStates = state.facetStates;\n        if (!facetStates) state.facetStates = facetStates = new Map();\n        facetState = facetStates.get(this);\n        if (!facetState) facetStates.set(this, (facetState = new Map()));\n      }\n\n      // The order of precedence for the pointer position is: px & py; the\n      // middle of x1 & y1 and x2 & y2; or x1 & y1 (e.g., area); or lastly x &\n      // y. If a dimension is unspecified, the frame anchor is used.\n      const [cx, cy] = applyFrameAnchor(this, dimensions);\n      const {px: PX, py: PY} = values;\n      const px = PX ? (i) => PX[i] : anchorX(values, cx);\n      const py = PY ? (i) => PY[i] : anchorY(values, cy);\n\n      let i; // currently focused index\n      let g; // currently rendered mark\n      let s; // currently rendered stickiness\n      let f; // current animation frame\n\n      // When faceting, if more than one pointer would be visible, only show\n      // this one if it is the closest. We defer rendering using an animation\n      // frame to allow all pointer events to be received before deciding which\n      // mark to render; although when hiding, we render immediately.\n      function update(ii, ri) {\n        if (faceted) {\n          if (f) f = cancelAnimationFrame(f);\n          if (ii == null) facetState.delete(index.fi);\n          else {\n            facetState.set(index.fi, ri);\n            f = requestAnimationFrame(() => {\n              f = null;\n              for (const [fi, r] of facetState) {\n                if (r < ri || (r === ri && fi < index.fi)) {\n                  ii = null;\n                  break;\n                }\n              }\n              render(ii);\n            });\n            return;\n          }\n        }\n        render(ii);\n      }\n\n      function render(ii) {\n        if (i === ii && s === state.sticky) return; // the tooltip hasn’t moved\n        i = ii;\n        s = context.pointerSticky = state.sticky;\n        const I = i == null ? [] : [i];\n        if (faceted) (I.fx = index.fx), (I.fy = index.fy), (I.fi = index.fi);\n        const r = next(I, scales, values, dimensions, context);\n        if (g) {\n          // When faceting, preserve swapped mark and facet transforms; also\n          // remove ARIA attributes since these are promoted to the parent. This\n          // is perhaps brittle in that it depends on how Plot renders facets,\n          // but it produces a cleaner and more accessible SVG structure.\n          if (faceted) {\n            const p = g.parentNode;\n            const ft = g.getAttribute(\"transform\");\n            const mt = r.getAttribute(\"transform\");\n            ft ? r.setAttribute(\"transform\", ft) : r.removeAttribute(\"transform\");\n            mt ? p.setAttribute(\"transform\", mt) : p.removeAttribute(\"transform\");\n            r.removeAttribute(\"aria-label\");\n            r.removeAttribute(\"aria-description\");\n            r.removeAttribute(\"aria-hidden\");\n          }\n          g.replaceWith(r);\n        }\n        state.roots[renderIndex] = g = r;\n\n        // Dispatch the value. When simultaneously exiting this facet and\n        // entering a new one, prioritize the entering facet.\n        if (!(i == null && facetState?.size > 1)) {\n          const value = i == null ? null : isArray(data) ? data[i] : data.get(i);\n          context.dispatchValue(value);\n        }\n\n        return r;\n      }\n\n      // Select the closest point to the mouse in the current facet; for\n      // pointerX or pointerY, the orthogonal component of the distance is\n      // squashed, selecting primarily on the dominant dimension. Across facets,\n      // use unsquashed distance to determine the winner.\n      function pointermove(event) {\n        if (state.sticky || (event.pointerType === \"mouse\" && event.buttons === 1)) return; // dragging\n        let [xp, yp] = pointof(event);\n        (xp -= tx), (yp -= ty); // correct for facets and band scales\n        const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx;\n        const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky;\n        let ii = null;\n        let ri = maxRadius * maxRadius;\n        for (const j of index) {\n          const dx = kpx * (px(j) - xp);\n          const dy = kpy * (py(j) - yp);\n          const rj = dx * dx + dy * dy;\n          if (rj <= ri) (ii = j), (ri = rj);\n        }\n        if (ii != null && (kx !== 1 || ky !== 1)) {\n          const dx = px(ii) - xp;\n          const dy = py(ii) - yp;\n          ri = dx * dx + dy * dy;\n        }\n        update(ii, ri);\n      }\n\n      function pointerdown(event) {\n        if (event.pointerType !== \"mouse\") return;\n        if (i == null) return; // not pointing\n        if (state.sticky && state.roots.some((r) => r?.contains(event.target))) return; // stay sticky\n        if (state.sticky) (state.sticky = false), state.renders.forEach((r) => r(null)); // clear all pointers\n        else (state.sticky = true), render(i);\n        event.stopImmediatePropagation(); // suppress other pointers\n      }\n\n      function pointerleave(event) {\n        if (event.pointerType !== \"mouse\") return;\n        if (!state.sticky) update(null);\n      }\n\n      // We listen to the svg element; listening to the window instead would let\n      // us receive pointer events from farther away, but would also make it\n      // hard to know when to remove the listeners. (Using a mutation observer\n      // to watch the entire document is likely too expensive.)\n      svg.addEventListener(\"pointerenter\", pointermove);\n      svg.addEventListener(\"pointermove\", pointermove);\n      svg.addEventListener(\"pointerdown\", pointerdown);\n      svg.addEventListener(\"pointerleave\", pointerleave);\n\n      return render(null);\n    }, render)\n  };\n}\n\nexport function pointer(options) {\n  return pointerK(1, 1, options);\n}\n\nexport function pointerX(options) {\n  return pointerK(1, 0.01, options);\n}\n\nexport function pointerY(options) {\n  return pointerK(0.01, 1, options);\n}\n\nexport function anchorX({x1: X1, x2: X2, x: X = X1}, cx) {\n  return X1 && X2 ? (i) => (X1[i] + X2[i]) / 2 : X ? (i) => X[i] : () => cx;\n}\n\nexport function anchorY({y1: Y1, y2: Y2, y: Y = Y1}, cy) {\n  return Y1 && Y2 ? (i) => (Y1[i] + Y2[i]) / 2 : Y ? (i) => Y[i] : () => cy;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}