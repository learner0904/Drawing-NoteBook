{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { descending, extent, interpolateHcl, interpolateHsl, interpolateLab, interpolateNumber, interpolateRgb, interpolateRound, max, median, min, piecewise, quantile, quantize, reverse as reverseof, scaleIdentity, scaleLinear, scaleLog, scalePow, scaleQuantile, scaleSymlog, scaleThreshold, ticks } from \"d3\";\nimport { finite, negative, positive } from \"../defined.js\";\nimport { arrayify, constant, maybeNiceInterval, maybeRangeInterval, slice } from \"../options.js\";\nimport { orderof } from \"../order.js\";\nimport { color, length, opacity, radius, registry, hasNumericRange } from \"./index.js\";\nimport { ordinalRange, quantitativeScheme } from \"./schemes.js\";\nexport const flip = i => t => i(1 - t);\nconst unit = [0, 1];\nconst interpolators = new Map([\n// numbers\n[\"number\", interpolateNumber],\n// color spaces\n[\"rgb\", interpolateRgb], [\"hsl\", interpolateHsl], [\"hcl\", interpolateHcl], [\"lab\", interpolateLab]]);\nexport function maybeInterpolator(interpolate) {\n  const i = `${interpolate}`.toLowerCase();\n  if (!interpolators.has(i)) throw new Error(`unknown interpolator: ${i}`);\n  return interpolators.get(i);\n}\nexport function createScaleQ(key, scale, channels, {\n  type,\n  nice,\n  clamp,\n  zero,\n  domain = inferAutoDomain(key, channels),\n  unknown,\n  round,\n  scheme,\n  interval,\n  range = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit : undefined,\n  interpolate = registry.get(key) === color ? scheme == null && range !== undefined ? interpolateRgb : quantitativeScheme(scheme !== undefined ? scheme : type === \"cyclical\" ? \"rainbow\" : \"turbo\") : round ? interpolateRound : interpolateNumber,\n  reverse\n}) {\n  interval = maybeRangeInterval(interval, type);\n  if (type === \"cyclical\" || type === \"sequential\") type = \"linear\"; // shorthand for color schemes\n  if (typeof interpolate !== \"function\") interpolate = maybeInterpolator(interpolate); // named interpolator\n  reverse = !!reverse;\n\n  // If an explicit range is specified, and it has a different length than the\n  // domain, then redistribute the range using a piecewise interpolator.\n  if (range !== undefined) {\n    const n = (domain = arrayify(domain)).length;\n    const m = (range = arrayify(range)).length;\n    if (n !== m) {\n      if (interpolate.length === 1) throw new Error(\"invalid piecewise interpolator\"); // e.g., turbo\n      interpolate = piecewise(interpolate, range);\n      range = undefined;\n    }\n  }\n\n  // Disambiguate between a two-argument interpolator that is used in\n  // conjunction with the range, and a one-argument “fixed” interpolator on the\n  // [0, 1] interval as with the RdBu color scheme.\n  if (interpolate.length === 1) {\n    if (reverse) {\n      interpolate = flip(interpolate);\n      reverse = false;\n    }\n    if (range === undefined) {\n      range = Float64Array.from(domain, (_, i) => i / (domain.length - 1));\n      if (range.length === 2) range = unit; // optimize common case of [0, 1]\n    }\n\n    scale.interpolate((range === unit ? constant : interpolatePiecewise)(interpolate));\n  } else {\n    scale.interpolate(interpolate);\n  }\n\n  // If a zero option is specified, we assume that the domain is numeric, and we\n  // want to ensure that the domain crosses zero. However, note that the domain\n  // may be reversed (descending) so we shouldn’t assume that the first value is\n  // smaller than the last; and also it’s possible that the domain has more than\n  // two values for a “poly” scale. And lastly be careful not to mutate input!\n  if (zero) {\n    const [min, max] = extent(domain);\n    if (min > 0 || max < 0) {\n      domain = slice(domain);\n      const o = orderof(domain) || 1; // treat degenerate as ascending\n      if (o === Math.sign(min)) domain[0] = 0; // [1, 2] or [-1, -2]\n      else domain[domain.length - 1] = 0; // [2, 1] or [-2, -1]\n    }\n  }\n\n  if (reverse) domain = reverseof(domain);\n  scale.domain(domain).unknown(unknown);\n  if (nice) scale.nice(maybeNice(nice, type)), domain = scale.domain();\n  if (range !== undefined) scale.range(range);\n  if (clamp) scale.clamp(clamp);\n  return {\n    type,\n    domain,\n    range,\n    scale,\n    interpolate,\n    interval\n  };\n}\nfunction maybeNice(nice, type) {\n  return nice === true ? undefined : typeof nice === \"number\" ? nice : maybeNiceInterval(nice, type);\n}\nexport function createScaleLinear(key, channels, options) {\n  return createScaleQ(key, scaleLinear(), channels, options);\n}\nexport function createScaleSqrt(key, channels, options) {\n  return createScalePow(key, channels, {\n    ...options,\n    exponent: 0.5\n  });\n}\nexport function createScalePow(key, channels, {\n  exponent = 1,\n  ...options\n}) {\n  return createScaleQ(key, scalePow().exponent(exponent), channels, {\n    ...options,\n    type: \"pow\"\n  });\n}\nexport function createScaleLog(key, channels, {\n  base = 10,\n  domain = inferLogDomain(channels),\n  ...options\n}) {\n  return createScaleQ(key, scaleLog().base(base), channels, {\n    ...options,\n    domain\n  });\n}\nexport function createScaleSymlog(key, channels, {\n  constant = 1,\n  ...options\n}) {\n  return createScaleQ(key, scaleSymlog().constant(constant), channels, options);\n}\nexport function createScaleQuantile(key, channels, {\n  range,\n  quantiles = range === undefined ? 5 : (range = [...range]).length,\n  // deprecated; use n instead\n  n = quantiles,\n  scheme = \"rdylbu\",\n  domain = inferQuantileDomain(channels),\n  unknown,\n  interpolate,\n  reverse\n}) {\n  if (range === undefined) {\n    range = interpolate !== undefined ? quantize(interpolate, n) : registry.get(key) === color ? ordinalRange(scheme, n) : undefined;\n  }\n  if (domain.length > 0) {\n    domain = scaleQuantile(domain, range === undefined ? {\n      length: n\n    } : range).quantiles();\n  }\n  return createScaleThreshold(key, channels, {\n    domain,\n    range,\n    reverse,\n    unknown\n  });\n}\nexport function createScaleQuantize(key, channels, {\n  range,\n  n = range === undefined ? 5 : (range = [...range]).length,\n  scheme = \"rdylbu\",\n  domain = inferAutoDomain(key, channels),\n  unknown,\n  interpolate,\n  reverse\n}) {\n  const [min, max] = extent(domain);\n  let thresholds;\n  if (range === undefined) {\n    thresholds = ticks(min, max, n); // approximate number of nice, round thresholds\n    if (thresholds[0] <= min) thresholds.splice(0, 1); // drop exact lower bound\n    if (thresholds[thresholds.length - 1] >= max) thresholds.pop(); // drop exact upper bound\n    n = thresholds.length + 1;\n    range = interpolate !== undefined ? quantize(interpolate, n) : registry.get(key) === color ? ordinalRange(scheme, n) : undefined;\n  } else {\n    thresholds = quantize(interpolateNumber(min, max), n + 1).slice(1, -1); // exactly n - 1 thresholds to match range\n    if (min instanceof Date) thresholds = thresholds.map(x => new Date(x)); // preserve date types\n  }\n\n  if (orderof(arrayify(domain)) < 0) thresholds.reverse(); // preserve descending domain\n  return createScaleThreshold(key, channels, {\n    domain: thresholds,\n    range,\n    reverse,\n    unknown\n  });\n}\nexport function createScaleThreshold(key, channels, {\n  domain = [0],\n  // explicit thresholds in ascending order\n  unknown,\n  scheme = \"rdylbu\",\n  interpolate,\n  range = interpolate !== undefined ? quantize(interpolate, domain.length + 1) : registry.get(key) === color ? ordinalRange(scheme, domain.length + 1) : undefined,\n  reverse\n}) {\n  domain = arrayify(domain);\n  const sign = orderof(domain); // preserve descending domain\n  if (!isNaN(sign) && !isOrdered(domain, sign)) throw new Error(`the ${key} scale has a non-monotonic domain`);\n  if (reverse) range = reverseof(range); // domain ascending, so reverse range\n  return {\n    type: \"threshold\",\n    scale: scaleThreshold(sign < 0 ? reverseof(domain) : domain, range === undefined ? [] : range).unknown(unknown),\n    domain,\n    range\n  };\n}\nfunction isOrdered(domain, sign) {\n  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {\n    const s = descending(d, d = domain[i]);\n    if (s !== 0 && s !== sign) return false;\n  }\n  return true;\n}\n\n// For non-numeric identity scales such as color and symbol, we can’t use D3’s\n// identity scale because it coerces to number; and we can’t compute the domain\n// (and equivalently range) since we can’t know whether the values are\n// continuous or discrete.\nexport function createScaleIdentity(key) {\n  return {\n    type: \"identity\",\n    scale: hasNumericRange(registry.get(key)) ? scaleIdentity() : d => d\n  };\n}\nexport function inferDomain(channels, f = finite) {\n  return channels.length ? [min(channels, ({\n    value\n  }) => value === undefined ? value : min(value, f)), max(channels, ({\n    value\n  }) => value === undefined ? value : max(value, f))] : [0, 1];\n}\nfunction inferAutoDomain(key, channels) {\n  const type = registry.get(key);\n  return (type === radius || type === opacity || type === length ? inferZeroDomain : inferDomain)(channels);\n}\nfunction inferZeroDomain(channels) {\n  return [0, channels.length ? max(channels, ({\n    value\n  }) => value === undefined ? value : max(value, finite)) : 1];\n}\n\n// We don’t want the upper bound of the radial domain to be zero, as this would\n// be degenerate, so we ignore nonpositive values. We also don’t want the\n// maximum default radius to exceed 30px.\nfunction inferRadialRange(channels, domain) {\n  const hint = channels.find(({\n    radius\n  }) => radius !== undefined);\n  if (hint !== undefined) return [0, hint.radius]; // a natural maximum radius, e.g. hexbins\n  const h25 = quantile(channels, 0.5, ({\n    value\n  }) => value === undefined ? NaN : quantile(value, 0.25, positive));\n  const range = domain.map(d => 3 * Math.sqrt(d / h25));\n  const k = 30 / max(range);\n  return k < 1 ? range.map(r => r * k) : range;\n}\n\n// We want a length scale’s domain to go from zero to a positive value, and to\n// treat negative lengths if any as inverted vectors of equivalent magnitude. We\n// also don’t want the maximum default length to exceed 60px.\nfunction inferLengthRange(channels, domain) {\n  const h50 = median(channels, ({\n    value\n  }) => value === undefined ? NaN : median(value, Math.abs));\n  const range = domain.map(d => 12 * d / h50);\n  const k = 60 / max(range);\n  return k < 1 ? range.map(r => r * k) : range;\n}\nfunction inferLogDomain(channels) {\n  for (const {\n    value\n  } of channels) {\n    if (value !== undefined) {\n      for (let v of value) {\n        if (v > 0) return inferDomain(channels, positive);\n        if (v < 0) return inferDomain(channels, negative);\n      }\n    }\n  }\n  return [1, 10];\n}\nfunction inferQuantileDomain(channels) {\n  const domain = [];\n  for (const {\n    value\n  } of channels) {\n    if (value === undefined) continue;\n    for (const v of value) domain.push(v);\n  }\n  return domain;\n}\nexport function interpolatePiecewise(interpolate) {\n  return (i, j) => t => interpolate(i + t * (j - i));\n}","map":{"version":3,"names":["descending","extent","interpolateHcl","interpolateHsl","interpolateLab","interpolateNumber","interpolateRgb","interpolateRound","max","median","min","piecewise","quantile","quantize","reverse","reverseof","scaleIdentity","scaleLinear","scaleLog","scalePow","scaleQuantile","scaleSymlog","scaleThreshold","ticks","finite","negative","positive","arrayify","constant","maybeNiceInterval","maybeRangeInterval","slice","orderof","color","length","opacity","radius","registry","hasNumericRange","ordinalRange","quantitativeScheme","flip","i","t","unit","interpolators","Map","maybeInterpolator","interpolate","toLowerCase","has","Error","get","createScaleQ","key","scale","channels","type","nice","clamp","zero","domain","inferAutoDomain","unknown","round","scheme","interval","range","inferRadialRange","inferLengthRange","undefined","n","m","Float64Array","from","_","interpolatePiecewise","o","Math","sign","maybeNice","createScaleLinear","options","createScaleSqrt","createScalePow","exponent","createScaleLog","base","inferLogDomain","createScaleSymlog","createScaleQuantile","quantiles","inferQuantileDomain","createScaleThreshold","createScaleQuantize","thresholds","splice","pop","Date","map","x","isNaN","isOrdered","d","s","createScaleIdentity","inferDomain","f","value","inferZeroDomain","hint","find","h25","NaN","sqrt","k","r","h50","abs","v","push","j"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/scales/quantitative.js"],"sourcesContent":["import {\n  descending,\n  extent,\n  interpolateHcl,\n  interpolateHsl,\n  interpolateLab,\n  interpolateNumber,\n  interpolateRgb,\n  interpolateRound,\n  max,\n  median,\n  min,\n  piecewise,\n  quantile,\n  quantize,\n  reverse as reverseof,\n  scaleIdentity,\n  scaleLinear,\n  scaleLog,\n  scalePow,\n  scaleQuantile,\n  scaleSymlog,\n  scaleThreshold,\n  ticks\n} from \"d3\";\nimport {finite, negative, positive} from \"../defined.js\";\nimport {arrayify, constant, maybeNiceInterval, maybeRangeInterval, slice} from \"../options.js\";\nimport {orderof} from \"../order.js\";\nimport {color, length, opacity, radius, registry, hasNumericRange} from \"./index.js\";\nimport {ordinalRange, quantitativeScheme} from \"./schemes.js\";\n\nexport const flip = (i) => (t) => i(1 - t);\nconst unit = [0, 1];\n\nconst interpolators = new Map([\n  // numbers\n  [\"number\", interpolateNumber],\n\n  // color spaces\n  [\"rgb\", interpolateRgb],\n  [\"hsl\", interpolateHsl],\n  [\"hcl\", interpolateHcl],\n  [\"lab\", interpolateLab]\n]);\n\nexport function maybeInterpolator(interpolate) {\n  const i = `${interpolate}`.toLowerCase();\n  if (!interpolators.has(i)) throw new Error(`unknown interpolator: ${i}`);\n  return interpolators.get(i);\n}\n\nexport function createScaleQ(\n  key,\n  scale,\n  channels,\n  {\n    type,\n    nice,\n    clamp,\n    zero,\n    domain = inferAutoDomain(key, channels),\n    unknown,\n    round,\n    scheme,\n    interval,\n    range = registry.get(key) === radius\n      ? inferRadialRange(channels, domain)\n      : registry.get(key) === length\n      ? inferLengthRange(channels, domain)\n      : registry.get(key) === opacity\n      ? unit\n      : undefined,\n    interpolate = registry.get(key) === color\n      ? scheme == null && range !== undefined\n        ? interpolateRgb\n        : quantitativeScheme(scheme !== undefined ? scheme : type === \"cyclical\" ? \"rainbow\" : \"turbo\")\n      : round\n      ? interpolateRound\n      : interpolateNumber,\n    reverse\n  }\n) {\n  interval = maybeRangeInterval(interval, type);\n  if (type === \"cyclical\" || type === \"sequential\") type = \"linear\"; // shorthand for color schemes\n  if (typeof interpolate !== \"function\") interpolate = maybeInterpolator(interpolate); // named interpolator\n  reverse = !!reverse;\n\n  // If an explicit range is specified, and it has a different length than the\n  // domain, then redistribute the range using a piecewise interpolator.\n  if (range !== undefined) {\n    const n = (domain = arrayify(domain)).length;\n    const m = (range = arrayify(range)).length;\n    if (n !== m) {\n      if (interpolate.length === 1) throw new Error(\"invalid piecewise interpolator\"); // e.g., turbo\n      interpolate = piecewise(interpolate, range);\n      range = undefined;\n    }\n  }\n\n  // Disambiguate between a two-argument interpolator that is used in\n  // conjunction with the range, and a one-argument “fixed” interpolator on the\n  // [0, 1] interval as with the RdBu color scheme.\n  if (interpolate.length === 1) {\n    if (reverse) {\n      interpolate = flip(interpolate);\n      reverse = false;\n    }\n    if (range === undefined) {\n      range = Float64Array.from(domain, (_, i) => i / (domain.length - 1));\n      if (range.length === 2) range = unit; // optimize common case of [0, 1]\n    }\n    scale.interpolate((range === unit ? constant : interpolatePiecewise)(interpolate));\n  } else {\n    scale.interpolate(interpolate);\n  }\n\n  // If a zero option is specified, we assume that the domain is numeric, and we\n  // want to ensure that the domain crosses zero. However, note that the domain\n  // may be reversed (descending) so we shouldn’t assume that the first value is\n  // smaller than the last; and also it’s possible that the domain has more than\n  // two values for a “poly” scale. And lastly be careful not to mutate input!\n  if (zero) {\n    const [min, max] = extent(domain);\n    if (min > 0 || max < 0) {\n      domain = slice(domain);\n      const o = orderof(domain) || 1; // treat degenerate as ascending\n      if (o === Math.sign(min)) domain[0] = 0; // [1, 2] or [-1, -2]\n      else domain[domain.length - 1] = 0; // [2, 1] or [-2, -1]\n    }\n  }\n\n  if (reverse) domain = reverseof(domain);\n  scale.domain(domain).unknown(unknown);\n  if (nice) scale.nice(maybeNice(nice, type)), (domain = scale.domain());\n  if (range !== undefined) scale.range(range);\n  if (clamp) scale.clamp(clamp);\n  return {type, domain, range, scale, interpolate, interval};\n}\n\nfunction maybeNice(nice, type) {\n  return nice === true ? undefined : typeof nice === \"number\" ? nice : maybeNiceInterval(nice, type);\n}\n\nexport function createScaleLinear(key, channels, options) {\n  return createScaleQ(key, scaleLinear(), channels, options);\n}\n\nexport function createScaleSqrt(key, channels, options) {\n  return createScalePow(key, channels, {...options, exponent: 0.5});\n}\n\nexport function createScalePow(key, channels, {exponent = 1, ...options}) {\n  return createScaleQ(key, scalePow().exponent(exponent), channels, {...options, type: \"pow\"});\n}\n\nexport function createScaleLog(key, channels, {base = 10, domain = inferLogDomain(channels), ...options}) {\n  return createScaleQ(key, scaleLog().base(base), channels, {...options, domain});\n}\n\nexport function createScaleSymlog(key, channels, {constant = 1, ...options}) {\n  return createScaleQ(key, scaleSymlog().constant(constant), channels, options);\n}\n\nexport function createScaleQuantile(\n  key,\n  channels,\n  {\n    range,\n    quantiles = range === undefined ? 5 : (range = [...range]).length, // deprecated; use n instead\n    n = quantiles,\n    scheme = \"rdylbu\",\n    domain = inferQuantileDomain(channels),\n    unknown,\n    interpolate,\n    reverse\n  }\n) {\n  if (range === undefined) {\n    range =\n      interpolate !== undefined\n        ? quantize(interpolate, n)\n        : registry.get(key) === color\n        ? ordinalRange(scheme, n)\n        : undefined;\n  }\n  if (domain.length > 0) {\n    domain = scaleQuantile(domain, range === undefined ? {length: n} : range).quantiles();\n  }\n  return createScaleThreshold(key, channels, {domain, range, reverse, unknown});\n}\n\nexport function createScaleQuantize(\n  key,\n  channels,\n  {\n    range,\n    n = range === undefined ? 5 : (range = [...range]).length,\n    scheme = \"rdylbu\",\n    domain = inferAutoDomain(key, channels),\n    unknown,\n    interpolate,\n    reverse\n  }\n) {\n  const [min, max] = extent(domain);\n  let thresholds;\n  if (range === undefined) {\n    thresholds = ticks(min, max, n); // approximate number of nice, round thresholds\n    if (thresholds[0] <= min) thresholds.splice(0, 1); // drop exact lower bound\n    if (thresholds[thresholds.length - 1] >= max) thresholds.pop(); // drop exact upper bound\n    n = thresholds.length + 1;\n    range =\n      interpolate !== undefined\n        ? quantize(interpolate, n)\n        : registry.get(key) === color\n        ? ordinalRange(scheme, n)\n        : undefined;\n  } else {\n    thresholds = quantize(interpolateNumber(min, max), n + 1).slice(1, -1); // exactly n - 1 thresholds to match range\n    if (min instanceof Date) thresholds = thresholds.map((x) => new Date(x)); // preserve date types\n  }\n  if (orderof(arrayify(domain)) < 0) thresholds.reverse(); // preserve descending domain\n  return createScaleThreshold(key, channels, {domain: thresholds, range, reverse, unknown});\n}\n\nexport function createScaleThreshold(\n  key,\n  channels,\n  {\n    domain = [0], // explicit thresholds in ascending order\n    unknown,\n    scheme = \"rdylbu\",\n    interpolate,\n    range = interpolate !== undefined\n      ? quantize(interpolate, domain.length + 1)\n      : registry.get(key) === color\n      ? ordinalRange(scheme, domain.length + 1)\n      : undefined,\n    reverse\n  }\n) {\n  domain = arrayify(domain);\n  const sign = orderof(domain); // preserve descending domain\n  if (!isNaN(sign) && !isOrdered(domain, sign)) throw new Error(`the ${key} scale has a non-monotonic domain`);\n  if (reverse) range = reverseof(range); // domain ascending, so reverse range\n  return {\n    type: \"threshold\",\n    scale: scaleThreshold(sign < 0 ? reverseof(domain) : domain, range === undefined ? [] : range).unknown(unknown),\n    domain,\n    range\n  };\n}\n\nfunction isOrdered(domain, sign) {\n  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {\n    const s = descending(d, (d = domain[i]));\n    if (s !== 0 && s !== sign) return false;\n  }\n  return true;\n}\n\n// For non-numeric identity scales such as color and symbol, we can’t use D3’s\n// identity scale because it coerces to number; and we can’t compute the domain\n// (and equivalently range) since we can’t know whether the values are\n// continuous or discrete.\nexport function createScaleIdentity(key) {\n  return {type: \"identity\", scale: hasNumericRange(registry.get(key)) ? scaleIdentity() : (d) => d};\n}\n\nexport function inferDomain(channels, f = finite) {\n  return channels.length\n    ? [\n        min(channels, ({value}) => (value === undefined ? value : min(value, f))),\n        max(channels, ({value}) => (value === undefined ? value : max(value, f)))\n      ]\n    : [0, 1];\n}\n\nfunction inferAutoDomain(key, channels) {\n  const type = registry.get(key);\n  return (type === radius || type === opacity || type === length ? inferZeroDomain : inferDomain)(channels);\n}\n\nfunction inferZeroDomain(channels) {\n  return [0, channels.length ? max(channels, ({value}) => (value === undefined ? value : max(value, finite))) : 1];\n}\n\n// We don’t want the upper bound of the radial domain to be zero, as this would\n// be degenerate, so we ignore nonpositive values. We also don’t want the\n// maximum default radius to exceed 30px.\nfunction inferRadialRange(channels, domain) {\n  const hint = channels.find(({radius}) => radius !== undefined);\n  if (hint !== undefined) return [0, hint.radius]; // a natural maximum radius, e.g. hexbins\n  const h25 = quantile(channels, 0.5, ({value}) => (value === undefined ? NaN : quantile(value, 0.25, positive)));\n  const range = domain.map((d) => 3 * Math.sqrt(d / h25));\n  const k = 30 / max(range);\n  return k < 1 ? range.map((r) => r * k) : range;\n}\n\n// We want a length scale’s domain to go from zero to a positive value, and to\n// treat negative lengths if any as inverted vectors of equivalent magnitude. We\n// also don’t want the maximum default length to exceed 60px.\nfunction inferLengthRange(channels, domain) {\n  const h50 = median(channels, ({value}) => (value === undefined ? NaN : median(value, Math.abs)));\n  const range = domain.map((d) => (12 * d) / h50);\n  const k = 60 / max(range);\n  return k < 1 ? range.map((r) => r * k) : range;\n}\n\nfunction inferLogDomain(channels) {\n  for (const {value} of channels) {\n    if (value !== undefined) {\n      for (let v of value) {\n        if (v > 0) return inferDomain(channels, positive);\n        if (v < 0) return inferDomain(channels, negative);\n      }\n    }\n  }\n  return [1, 10];\n}\n\nfunction inferQuantileDomain(channels) {\n  const domain = [];\n  for (const {value} of channels) {\n    if (value === undefined) continue;\n    for (const v of value) domain.push(v);\n  }\n  return domain;\n}\n\nexport function interpolatePiecewise(interpolate) {\n  return (i, j) => (t) => interpolate(i + t * (j - i));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}