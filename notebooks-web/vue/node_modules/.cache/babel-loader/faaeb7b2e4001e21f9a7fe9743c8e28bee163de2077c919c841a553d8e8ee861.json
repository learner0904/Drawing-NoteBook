{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { InternMap, cumsum, greatest, group, groupSort, max, min, rollup, sum } from \"d3\";\nimport { ascendingDefined, descendingDefined } from \"../defined.js\";\nimport { withTip } from \"../mark.js\";\nimport { maybeApplyInterval, maybeColumn, maybeZ, maybeZero } from \"../options.js\";\nimport { column, field, isArray, lengthof, mid, one, range, valueof } from \"../options.js\";\nimport { basic } from \"./basic.js\";\nimport { exclusiveFacets } from \"./exclusiveFacets.js\";\nexport function stackX(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {\n    y1,\n    y = y1,\n    x,\n    ...rest\n  } = options; // note: consumes x!\n  const [transform, Y, x1, x2] = stack(y, x, \"y\", \"x\", stackOptions, rest);\n  return {\n    ...transform,\n    y1,\n    y: Y,\n    x1,\n    x2,\n    x: mid(x1, x2)\n  };\n}\nexport function stackX1(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {\n    y1,\n    y = y1,\n    x\n  } = options;\n  const [transform, Y, X] = stack(y, x, \"y\", \"x\", stackOptions, options);\n  return {\n    ...transform,\n    y1,\n    y: Y,\n    x: X\n  };\n}\nexport function stackX2(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {\n    y1,\n    y = y1,\n    x\n  } = options;\n  const [transform, Y,, X] = stack(y, x, \"y\", \"x\", stackOptions, options);\n  return {\n    ...transform,\n    y1,\n    y: Y,\n    x: X\n  };\n}\nexport function stackY(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {\n    x1,\n    x = x1,\n    y,\n    ...rest\n  } = options; // note: consumes y!\n  const [transform, X, y1, y2] = stack(x, y, \"x\", \"y\", stackOptions, rest);\n  return {\n    ...transform,\n    x1,\n    x: X,\n    y1,\n    y2,\n    y: mid(y1, y2)\n  };\n}\nexport function stackY1(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {\n    x1,\n    x = x1,\n    y\n  } = options;\n  const [transform, X, Y] = stack(x, y, \"x\", \"y\", stackOptions, options);\n  return {\n    ...transform,\n    x1,\n    x: X,\n    y: Y\n  };\n}\nexport function stackY2(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {\n    x1,\n    x = x1,\n    y\n  } = options;\n  const [transform, X,, Y] = stack(x, y, \"x\", \"y\", stackOptions, options);\n  return {\n    ...transform,\n    x1,\n    x: X,\n    y: Y\n  };\n}\nexport function maybeStackX({\n  x,\n  x1,\n  x2,\n  ...options\n} = {}) {\n  options = withTip(options, \"y\");\n  if (x1 === undefined && x2 === undefined) return stackX({\n    x,\n    ...options\n  });\n  [x1, x2] = maybeZero(x, x1, x2);\n  return {\n    ...options,\n    x1,\n    x2\n  };\n}\nexport function maybeStackY({\n  y,\n  y1,\n  y2,\n  ...options\n} = {}) {\n  options = withTip(options, \"x\");\n  if (y1 === undefined && y2 === undefined) return stackY({\n    y,\n    ...options\n  });\n  [y1, y2] = maybeZero(y, y1, y2);\n  return {\n    ...options,\n    y1,\n    y2\n  };\n}\n\n// The reverse option is ambiguous: it is both a stack option and a basic\n// transform. If only one options object is specified, we interpret it as a\n// stack option, and therefore must remove it from the propagated options.\nfunction mergeOptions(options) {\n  const {\n    offset,\n    order,\n    reverse,\n    ...rest\n  } = options;\n  return [{\n    offset,\n    order,\n    reverse\n  }, rest];\n}\n\n// This is a hint to the tooltip mark that the y1 and y2 channels (for stackY,\n// or conversely x1 and x2 for stackX) represent a stacked length, and that the\n// tooltip should therefore show y2-y1 instead of an extent.\nconst lengthy = {\n  length: true\n};\nfunction stack(x, y = one, kx, ky, {\n  offset,\n  order,\n  reverse\n}, options) {\n  if (y === null) throw new Error(`stack requires ${ky}`);\n  const z = maybeZ(options);\n  const [X, setX] = maybeColumn(x);\n  const [Y1, setY1] = column(y);\n  const [Y2, setY2] = column(y);\n  Y1.hint = Y2.hint = lengthy;\n  offset = maybeOffset(offset);\n  order = maybeOrder(order, offset, ky);\n  return [basic(options, (data, facets, plotOptions) => {\n    ({\n      data,\n      facets\n    } = exclusiveFacets(data, facets));\n    const X = x == null ? undefined : setX(maybeApplyInterval(valueof(data, x), plotOptions?.[kx]));\n    const Y = valueof(data, y, Float64Array);\n    const Z = valueof(data, z);\n    const compare = order && order(data, X, Y, Z);\n    const n = lengthof(data);\n    const Y1 = setY1(new Float64Array(n));\n    const Y2 = setY2(new Float64Array(n));\n    const facetstacks = [];\n    for (const facet of facets) {\n      const stacks = X ? Array.from(group(facet, i => X[i]).values()) : [facet];\n      if (compare) for (const stack of stacks) stack.sort(compare);\n      for (const stack of stacks) {\n        let yn = 0;\n        let yp = 0;\n        if (reverse) stack.reverse();\n        for (const i of stack) {\n          const y = Y[i];\n          if (y < 0) yn = Y2[i] = (Y1[i] = yn) + y;else if (y > 0) yp = Y2[i] = (Y1[i] = yp) + y;else Y2[i] = Y1[i] = yp; // NaN or zero\n        }\n      }\n\n      facetstacks.push(stacks);\n    }\n    if (offset) offset(facetstacks, Y1, Y2, Z);\n    return {\n      data,\n      facets\n    };\n  }), X, Y1, Y2];\n}\nfunction maybeOffset(offset) {\n  if (offset == null) return;\n  if (typeof offset === \"function\") return offset;\n  switch (`${offset}`.toLowerCase()) {\n    case \"expand\":\n    case \"normalize\":\n      return offsetExpand;\n    case \"center\":\n    case \"silhouette\":\n      return offsetCenter;\n    case \"wiggle\":\n      return offsetWiggle;\n  }\n  throw new Error(`unknown offset: ${offset}`);\n}\n\n// Given a single stack, returns the minimum and maximum values from the given\n// Y2 column. Note that this relies on Y2 always being the outer column for\n// diverging values.\nfunction extent(stack, Y2) {\n  let min = 0,\n    max = 0;\n  for (const i of stack) {\n    const y = Y2[i];\n    if (y < min) min = y;\n    if (y > max) max = y;\n  }\n  return [min, max];\n}\nfunction offsetExpand(facetstacks, Y1, Y2) {\n  for (const stacks of facetstacks) {\n    for (const stack of stacks) {\n      const [yn, yp] = extent(stack, Y2);\n      for (const i of stack) {\n        const m = 1 / (yp - yn || 1);\n        Y1[i] = m * (Y1[i] - yn);\n        Y2[i] = m * (Y2[i] - yn);\n      }\n    }\n  }\n}\nfunction offsetCenter(facetstacks, Y1, Y2) {\n  for (const stacks of facetstacks) {\n    for (const stack of stacks) {\n      const [yn, yp] = extent(stack, Y2);\n      for (const i of stack) {\n        const m = (yp + yn) / 2;\n        Y1[i] -= m;\n        Y2[i] -= m;\n      }\n    }\n    offsetZero(stacks, Y1, Y2);\n  }\n  offsetCenterFacets(facetstacks, Y1, Y2);\n}\nfunction offsetWiggle(facetstacks, Y1, Y2, Z) {\n  for (const stacks of facetstacks) {\n    const prev = new InternMap();\n    let y = 0;\n    for (const stack of stacks) {\n      let j = -1;\n      const Fi = stack.map(i => Math.abs(Y2[i] - Y1[i]));\n      const Df = stack.map(i => {\n        j = Z ? Z[i] : ++j;\n        const value = Y2[i] - Y1[i];\n        const diff = prev.has(j) ? value - prev.get(j) : 0;\n        prev.set(j, value);\n        return diff;\n      });\n      const Cf1 = [0, ...cumsum(Df)];\n      for (const i of stack) {\n        Y1[i] += y;\n        Y2[i] += y;\n      }\n      const s1 = sum(Fi);\n      if (s1) y -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;\n    }\n    offsetZero(stacks, Y1, Y2);\n  }\n  offsetCenterFacets(facetstacks, Y1, Y2);\n}\nfunction offsetZero(stacks, Y1, Y2) {\n  const m = min(stacks, stack => min(stack, i => Y1[i]));\n  for (const stack of stacks) {\n    for (const i of stack) {\n      Y1[i] -= m;\n      Y2[i] -= m;\n    }\n  }\n}\nfunction offsetCenterFacets(facetstacks, Y1, Y2) {\n  const n = facetstacks.length;\n  if (n === 1) return;\n  const facets = facetstacks.map(stacks => stacks.flat());\n  const m = facets.map(I => (min(I, i => Y1[i]) + max(I, i => Y2[i])) / 2);\n  const m0 = min(m);\n  for (let j = 0; j < n; j++) {\n    const p = m0 - m[j];\n    for (const i of facets[j]) {\n      Y1[i] += p;\n      Y2[i] += p;\n    }\n  }\n}\nfunction maybeOrder(order, offset, ky) {\n  if (order === undefined && offset === offsetWiggle) return orderInsideOut(ascendingDefined);\n  if (order == null) return;\n  if (typeof order === \"string\") {\n    const negate = order.startsWith(\"-\");\n    const compare = negate ? descendingDefined : ascendingDefined;\n    switch ((negate ? order.slice(1) : order).toLowerCase()) {\n      case \"value\":\n      case ky:\n        return orderY(compare);\n      case \"z\":\n        return orderZ(compare);\n      case \"sum\":\n        return orderSum(compare);\n      case \"appearance\":\n        return orderAppearance(compare);\n      case \"inside-out\":\n        return orderInsideOut(compare);\n    }\n    return orderAccessor(field(order));\n  }\n  if (typeof order === \"function\") return (order.length === 1 ? orderAccessor : orderComparator)(order);\n  if (isArray(order)) return orderGiven(order);\n  throw new Error(`invalid order: ${order}`);\n}\n\n// by value\nfunction orderY(compare) {\n  return (data, X, Y) => (i, j) => compare(Y[i], Y[j]);\n}\n\n// by location\nfunction orderZ(compare) {\n  return (data, X, Y, Z) => (i, j) => compare(Z[i], Z[j]);\n}\n\n// by sum of value (a.k.a. “ascending”)\nfunction orderSum(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) => groupSort(range(data), I => sum(I, i => Y[i]), i => Z[i]));\n}\n\n// by x = argmax of value\nfunction orderAppearance(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) => groupSort(range(data), I => X[greatest(I, i => Y[i])], i => Z[i]));\n}\n\n// by x = argmax of value, but rearranged inside-out by alternating series\n// according to the sign of a running divergence of sums\nfunction orderInsideOut(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) => {\n    const I = range(data);\n    const K = groupSort(I, I => X[greatest(I, i => Y[i])], i => Z[i]);\n    const sums = rollup(I, I => sum(I, i => Y[i]), i => Z[i]);\n    const Kp = [],\n      Kn = [];\n    let s = 0;\n    for (const k of K) {\n      if (s < 0) {\n        s += sums.get(k);\n        Kp.push(k);\n      } else {\n        s -= sums.get(k);\n        Kn.push(k);\n      }\n    }\n    return Kn.reverse().concat(Kp);\n  });\n}\nfunction orderAccessor(f) {\n  return data => {\n    const O = valueof(data, f);\n    return (i, j) => ascendingDefined(O[i], O[j]);\n  };\n}\nfunction orderComparator(f) {\n  return data => {\n    return isArray(data) ? (i, j) => f(data[i], data[j]) : (i, j) => f(data.get(i), data.get(j));\n  };\n}\nfunction orderGiven(domain) {\n  return orderZDomain(ascendingDefined, () => domain);\n}\n\n// Given an ordering (domain) of distinct values in z that can be derived from\n// the data, returns a comparator that can be used to sort stacks. Note that\n// this is a series order: it will be consistent across stacks.\nfunction orderZDomain(compare, domain) {\n  return (data, X, Y, Z) => {\n    if (!Z) throw new Error(\"missing channel: z\");\n    const map = new InternMap(domain(data, X, Y, Z).map((d, i) => [d, i]));\n    return (i, j) => compare(map.get(Z[i]), map.get(Z[j]));\n  };\n}","map":{"version":3,"names":["InternMap","cumsum","greatest","group","groupSort","max","min","rollup","sum","ascendingDefined","descendingDefined","withTip","maybeApplyInterval","maybeColumn","maybeZ","maybeZero","column","field","isArray","lengthof","mid","one","range","valueof","basic","exclusiveFacets","stackX","stackOptions","options","arguments","length","mergeOptions","y1","y","x","rest","transform","Y","x1","x2","stack","stackX1","X","stackX2","stackY","y2","stackY1","stackY2","maybeStackX","undefined","maybeStackY","offset","order","reverse","lengthy","kx","ky","Error","z","setX","Y1","setY1","Y2","setY2","hint","maybeOffset","maybeOrder","data","facets","plotOptions","Float64Array","Z","compare","n","facetstacks","facet","stacks","Array","from","i","values","sort","yn","yp","push","toLowerCase","offsetExpand","offsetCenter","offsetWiggle","extent","m","offsetZero","offsetCenterFacets","prev","j","Fi","map","Math","abs","Df","value","diff","has","get","set","Cf1","s1","d","flat","I","m0","p","orderInsideOut","negate","startsWith","slice","orderY","orderZ","orderSum","orderAppearance","orderAccessor","orderComparator","orderGiven","orderZDomain","K","sums","Kp","Kn","s","k","concat","f","O","domain"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/stack.js"],"sourcesContent":["import {InternMap, cumsum, greatest, group, groupSort, max, min, rollup, sum} from \"d3\";\nimport {ascendingDefined, descendingDefined} from \"../defined.js\";\nimport {withTip} from \"../mark.js\";\nimport {maybeApplyInterval, maybeColumn, maybeZ, maybeZero} from \"../options.js\";\nimport {column, field, isArray, lengthof, mid, one, range, valueof} from \"../options.js\";\nimport {basic} from \"./basic.js\";\nimport {exclusiveFacets} from \"./exclusiveFacets.js\";\n\nexport function stackX(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {y1, y = y1, x, ...rest} = options; // note: consumes x!\n  const [transform, Y, x1, x2] = stack(y, x, \"y\", \"x\", stackOptions, rest);\n  return {...transform, y1, y: Y, x1, x2, x: mid(x1, x2)};\n}\n\nexport function stackX1(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {y1, y = y1, x} = options;\n  const [transform, Y, X] = stack(y, x, \"y\", \"x\", stackOptions, options);\n  return {...transform, y1, y: Y, x: X};\n}\n\nexport function stackX2(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {y1, y = y1, x} = options;\n  const [transform, Y, , X] = stack(y, x, \"y\", \"x\", stackOptions, options);\n  return {...transform, y1, y: Y, x: X};\n}\n\nexport function stackY(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {x1, x = x1, y, ...rest} = options; // note: consumes y!\n  const [transform, X, y1, y2] = stack(x, y, \"x\", \"y\", stackOptions, rest);\n  return {...transform, x1, x: X, y1, y2, y: mid(y1, y2)};\n}\n\nexport function stackY1(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {x1, x = x1, y} = options;\n  const [transform, X, Y] = stack(x, y, \"x\", \"y\", stackOptions, options);\n  return {...transform, x1, x: X, y: Y};\n}\n\nexport function stackY2(stackOptions = {}, options = {}) {\n  if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);\n  const {x1, x = x1, y} = options;\n  const [transform, X, , Y] = stack(x, y, \"x\", \"y\", stackOptions, options);\n  return {...transform, x1, x: X, y: Y};\n}\n\nexport function maybeStackX({x, x1, x2, ...options} = {}) {\n  options = withTip(options, \"y\");\n  if (x1 === undefined && x2 === undefined) return stackX({x, ...options});\n  [x1, x2] = maybeZero(x, x1, x2);\n  return {...options, x1, x2};\n}\n\nexport function maybeStackY({y, y1, y2, ...options} = {}) {\n  options = withTip(options, \"x\");\n  if (y1 === undefined && y2 === undefined) return stackY({y, ...options});\n  [y1, y2] = maybeZero(y, y1, y2);\n  return {...options, y1, y2};\n}\n\n// The reverse option is ambiguous: it is both a stack option and a basic\n// transform. If only one options object is specified, we interpret it as a\n// stack option, and therefore must remove it from the propagated options.\nfunction mergeOptions(options) {\n  const {offset, order, reverse, ...rest} = options;\n  return [{offset, order, reverse}, rest];\n}\n\n// This is a hint to the tooltip mark that the y1 and y2 channels (for stackY,\n// or conversely x1 and x2 for stackX) represent a stacked length, and that the\n// tooltip should therefore show y2-y1 instead of an extent.\nconst lengthy = {length: true};\n\nfunction stack(x, y = one, kx, ky, {offset, order, reverse}, options) {\n  if (y === null) throw new Error(`stack requires ${ky}`);\n  const z = maybeZ(options);\n  const [X, setX] = maybeColumn(x);\n  const [Y1, setY1] = column(y);\n  const [Y2, setY2] = column(y);\n  Y1.hint = Y2.hint = lengthy;\n  offset = maybeOffset(offset);\n  order = maybeOrder(order, offset, ky);\n  return [\n    basic(options, (data, facets, plotOptions) => {\n      ({data, facets} = exclusiveFacets(data, facets));\n      const X = x == null ? undefined : setX(maybeApplyInterval(valueof(data, x), plotOptions?.[kx]));\n      const Y = valueof(data, y, Float64Array);\n      const Z = valueof(data, z);\n      const compare = order && order(data, X, Y, Z);\n      const n = lengthof(data);\n      const Y1 = setY1(new Float64Array(n));\n      const Y2 = setY2(new Float64Array(n));\n      const facetstacks = [];\n      for (const facet of facets) {\n        const stacks = X ? Array.from(group(facet, (i) => X[i]).values()) : [facet];\n        if (compare) for (const stack of stacks) stack.sort(compare);\n        for (const stack of stacks) {\n          let yn = 0;\n          let yp = 0;\n          if (reverse) stack.reverse();\n          for (const i of stack) {\n            const y = Y[i];\n            if (y < 0) yn = Y2[i] = (Y1[i] = yn) + y;\n            else if (y > 0) yp = Y2[i] = (Y1[i] = yp) + y;\n            else Y2[i] = Y1[i] = yp; // NaN or zero\n          }\n        }\n        facetstacks.push(stacks);\n      }\n      if (offset) offset(facetstacks, Y1, Y2, Z);\n      return {data, facets};\n    }),\n    X,\n    Y1,\n    Y2\n  ];\n}\n\nfunction maybeOffset(offset) {\n  if (offset == null) return;\n  if (typeof offset === \"function\") return offset;\n  switch (`${offset}`.toLowerCase()) {\n    case \"expand\":\n    case \"normalize\":\n      return offsetExpand;\n    case \"center\":\n    case \"silhouette\":\n      return offsetCenter;\n    case \"wiggle\":\n      return offsetWiggle;\n  }\n  throw new Error(`unknown offset: ${offset}`);\n}\n\n// Given a single stack, returns the minimum and maximum values from the given\n// Y2 column. Note that this relies on Y2 always being the outer column for\n// diverging values.\nfunction extent(stack, Y2) {\n  let min = 0,\n    max = 0;\n  for (const i of stack) {\n    const y = Y2[i];\n    if (y < min) min = y;\n    if (y > max) max = y;\n  }\n  return [min, max];\n}\n\nfunction offsetExpand(facetstacks, Y1, Y2) {\n  for (const stacks of facetstacks) {\n    for (const stack of stacks) {\n      const [yn, yp] = extent(stack, Y2);\n      for (const i of stack) {\n        const m = 1 / (yp - yn || 1);\n        Y1[i] = m * (Y1[i] - yn);\n        Y2[i] = m * (Y2[i] - yn);\n      }\n    }\n  }\n}\n\nfunction offsetCenter(facetstacks, Y1, Y2) {\n  for (const stacks of facetstacks) {\n    for (const stack of stacks) {\n      const [yn, yp] = extent(stack, Y2);\n      for (const i of stack) {\n        const m = (yp + yn) / 2;\n        Y1[i] -= m;\n        Y2[i] -= m;\n      }\n    }\n    offsetZero(stacks, Y1, Y2);\n  }\n  offsetCenterFacets(facetstacks, Y1, Y2);\n}\n\nfunction offsetWiggle(facetstacks, Y1, Y2, Z) {\n  for (const stacks of facetstacks) {\n    const prev = new InternMap();\n    let y = 0;\n    for (const stack of stacks) {\n      let j = -1;\n      const Fi = stack.map((i) => Math.abs(Y2[i] - Y1[i]));\n      const Df = stack.map((i) => {\n        j = Z ? Z[i] : ++j;\n        const value = Y2[i] - Y1[i];\n        const diff = prev.has(j) ? value - prev.get(j) : 0;\n        prev.set(j, value);\n        return diff;\n      });\n      const Cf1 = [0, ...cumsum(Df)];\n      for (const i of stack) {\n        Y1[i] += y;\n        Y2[i] += y;\n      }\n      const s1 = sum(Fi);\n      if (s1) y -= sum(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;\n    }\n    offsetZero(stacks, Y1, Y2);\n  }\n  offsetCenterFacets(facetstacks, Y1, Y2);\n}\n\nfunction offsetZero(stacks, Y1, Y2) {\n  const m = min(stacks, (stack) => min(stack, (i) => Y1[i]));\n  for (const stack of stacks) {\n    for (const i of stack) {\n      Y1[i] -= m;\n      Y2[i] -= m;\n    }\n  }\n}\n\nfunction offsetCenterFacets(facetstacks, Y1, Y2) {\n  const n = facetstacks.length;\n  if (n === 1) return;\n  const facets = facetstacks.map((stacks) => stacks.flat());\n  const m = facets.map((I) => (min(I, (i) => Y1[i]) + max(I, (i) => Y2[i])) / 2);\n  const m0 = min(m);\n  for (let j = 0; j < n; j++) {\n    const p = m0 - m[j];\n    for (const i of facets[j]) {\n      Y1[i] += p;\n      Y2[i] += p;\n    }\n  }\n}\n\nfunction maybeOrder(order, offset, ky) {\n  if (order === undefined && offset === offsetWiggle) return orderInsideOut(ascendingDefined);\n  if (order == null) return;\n  if (typeof order === \"string\") {\n    const negate = order.startsWith(\"-\");\n    const compare = negate ? descendingDefined : ascendingDefined;\n    switch ((negate ? order.slice(1) : order).toLowerCase()) {\n      case \"value\":\n      case ky:\n        return orderY(compare);\n      case \"z\":\n        return orderZ(compare);\n      case \"sum\":\n        return orderSum(compare);\n      case \"appearance\":\n        return orderAppearance(compare);\n      case \"inside-out\":\n        return orderInsideOut(compare);\n    }\n    return orderAccessor(field(order));\n  }\n  if (typeof order === \"function\") return (order.length === 1 ? orderAccessor : orderComparator)(order);\n  if (isArray(order)) return orderGiven(order);\n  throw new Error(`invalid order: ${order}`);\n}\n\n// by value\nfunction orderY(compare) {\n  return (data, X, Y) => (i, j) => compare(Y[i], Y[j]);\n}\n\n// by location\nfunction orderZ(compare) {\n  return (data, X, Y, Z) => (i, j) => compare(Z[i], Z[j]);\n}\n\n// by sum of value (a.k.a. “ascending”)\nfunction orderSum(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) =>\n    groupSort(\n      range(data),\n      (I) => sum(I, (i) => Y[i]),\n      (i) => Z[i]\n    )\n  );\n}\n\n// by x = argmax of value\nfunction orderAppearance(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) =>\n    groupSort(\n      range(data),\n      (I) => X[greatest(I, (i) => Y[i])],\n      (i) => Z[i]\n    )\n  );\n}\n\n// by x = argmax of value, but rearranged inside-out by alternating series\n// according to the sign of a running divergence of sums\nfunction orderInsideOut(compare) {\n  return orderZDomain(compare, (data, X, Y, Z) => {\n    const I = range(data);\n    const K = groupSort(\n      I,\n      (I) => X[greatest(I, (i) => Y[i])],\n      (i) => Z[i]\n    );\n    const sums = rollup(\n      I,\n      (I) => sum(I, (i) => Y[i]),\n      (i) => Z[i]\n    );\n    const Kp = [],\n      Kn = [];\n    let s = 0;\n    for (const k of K) {\n      if (s < 0) {\n        s += sums.get(k);\n        Kp.push(k);\n      } else {\n        s -= sums.get(k);\n        Kn.push(k);\n      }\n    }\n    return Kn.reverse().concat(Kp);\n  });\n}\n\nfunction orderAccessor(f) {\n  return (data) => {\n    const O = valueof(data, f);\n    return (i, j) => ascendingDefined(O[i], O[j]);\n  };\n}\n\nfunction orderComparator(f) {\n  return (data) => {\n    return isArray(data) ? (i, j) => f(data[i], data[j]) : (i, j) => f(data.get(i), data.get(j));\n  };\n}\n\nfunction orderGiven(domain) {\n  return orderZDomain(ascendingDefined, () => domain);\n}\n\n// Given an ordering (domain) of distinct values in z that can be derived from\n// the data, returns a comparator that can be used to sort stacks. Note that\n// this is a series order: it will be consistent across stacks.\nfunction orderZDomain(compare, domain) {\n  return (data, X, Y, Z) => {\n    if (!Z) throw new Error(\"missing channel: z\");\n    const map = new InternMap(domain(data, X, Y, Z).map((d, i) => [d, i]));\n    return (i, j) => compare(map.get(Z[i]), map.get(Z[j]));\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}