{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEquidistant, geoClipRectangle, geoConicConformal, geoConicEqualArea, geoConicEquidistant, geoEqualEarth, geoEquirectangular, geoGnomonic, geoMercator, geoOrthographic, geoPath, geoStereographic, geoStream, geoTransform, geoTransverseMercator } from \"d3\";\nimport { valueObject } from \"./channel.js\";\nimport { coerceNumbers, constant, isObject } from \"./options.js\";\nimport { warn } from \"./warnings.js\";\nconst pi = Math.PI;\nconst tau = 2 * pi;\nconst defaultAspectRatio = 0.618;\nexport function createProjection({\n  projection,\n  inset: globalInset = 0,\n  insetTop = globalInset,\n  insetRight = globalInset,\n  insetBottom = globalInset,\n  insetLeft = globalInset\n} = {}, dimensions) {\n  if (projection == null) return;\n  if (typeof projection.stream === \"function\") return projection; // d3 projection\n  let options;\n  let domain;\n  let clip = \"frame\";\n\n  // If the projection was specified as an object with additional options,\n  // extract those. The order of precedence for insetTop (and other insets) is:\n  // projection.insetTop, projection.inset, (global) insetTop, (global) inset.\n  // Any other options on this object will be passed through to the initializer.\n  if (isObject(projection)) {\n    let inset;\n    ({\n      type: projection,\n      domain,\n      inset,\n      insetTop = inset !== undefined ? inset : insetTop,\n      insetRight = inset !== undefined ? inset : insetRight,\n      insetBottom = inset !== undefined ? inset : insetBottom,\n      insetLeft = inset !== undefined ? inset : insetLeft,\n      clip = clip,\n      ...options\n    } = projection);\n    if (projection == null) return;\n  }\n\n  // For named projections, retrieve the corresponding projection initializer.\n  if (typeof projection !== \"function\") ({\n    type: projection\n  } = namedProjection(projection));\n\n  // Compute the frame dimensions and invoke the projection initializer.\n  const {\n    width,\n    height,\n    marginLeft,\n    marginRight,\n    marginTop,\n    marginBottom\n  } = dimensions;\n  const dx = width - marginLeft - marginRight - insetLeft - insetRight;\n  const dy = height - marginTop - marginBottom - insetTop - insetBottom;\n  projection = projection?.({\n    width: dx,\n    height: dy,\n    clip,\n    ...options\n  });\n\n  // The projection initializer might decide to not use a projection.\n  if (projection == null) return;\n  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);\n\n  // Translate the origin to the top-left corner, respecting margins and insets.\n  let tx = marginLeft + insetLeft;\n  let ty = marginTop + insetTop;\n  let transform;\n\n  // If a domain is specified, fit the projection to the frame.\n  if (domain != null) {\n    const [[x0, y0], [x1, y1]] = geoPath(projection).bounds(domain);\n    const k = Math.min(dx / (x1 - x0), dy / (y1 - y0));\n    if (k > 0) {\n      tx -= (k * (x0 + x1) - dx) / 2;\n      ty -= (k * (y0 + y1) - dy) / 2;\n      transform = geoTransform({\n        point(x, y) {\n          this.stream.point(x * k + tx, y * k + ty);\n        }\n      });\n    } else {\n      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);\n    }\n  }\n  transform ??= tx === 0 && ty === 0 ? identity() : geoTransform({\n    point(x, y) {\n      this.stream.point(x + tx, y + ty);\n    }\n  });\n  return {\n    stream: s => projection.stream(transform.stream(clip(s)))\n  };\n}\nfunction namedProjection(projection) {\n  switch (`${projection}`.toLowerCase()) {\n    case \"albers-usa\":\n      return scaleProjection(geoAlbersUsa, 0.7463, 0.4673);\n    case \"albers\":\n      return conicProjection(geoAlbers, 0.7463, 0.4673);\n    case \"azimuthal-equal-area\":\n      return scaleProjection(geoAzimuthalEqualArea, 4, 4);\n    case \"azimuthal-equidistant\":\n      return scaleProjection(geoAzimuthalEquidistant, tau, tau);\n    case \"conic-conformal\":\n      return conicProjection(geoConicConformal, tau, tau);\n    case \"conic-equal-area\":\n      return conicProjection(geoConicEqualArea, 6.1702, 2.9781);\n    case \"conic-equidistant\":\n      return conicProjection(geoConicEquidistant, 7.312, 3.6282);\n    case \"equal-earth\":\n      return scaleProjection(geoEqualEarth, 5.4133, 2.6347);\n    case \"equirectangular\":\n      return scaleProjection(geoEquirectangular, tau, pi);\n    case \"gnomonic\":\n      return scaleProjection(geoGnomonic, 3.4641, 3.4641);\n    case \"identity\":\n      return {\n        type: identity\n      };\n    case \"reflect-y\":\n      return {\n        type: reflectY\n      };\n    case \"mercator\":\n      return scaleProjection(geoMercator, tau, tau);\n    case \"orthographic\":\n      return scaleProjection(geoOrthographic, 2, 2);\n    case \"stereographic\":\n      return scaleProjection(geoStereographic, 2, 2);\n    case \"transverse-mercator\":\n      return scaleProjection(geoTransverseMercator, tau, tau);\n    default:\n      throw new Error(`unknown projection type: ${projection}`);\n  }\n}\nfunction maybePostClip(clip, x1, y1, x2, y2) {\n  if (clip === false || clip == null || typeof clip === \"number\") return s => s;\n  if (clip === true) clip = \"frame\";\n  switch (`${clip}`.toLowerCase()) {\n    case \"frame\":\n      return geoClipRectangle(x1, y1, x2, y2);\n    default:\n      throw new Error(`unknown projection clip type: ${clip}`);\n  }\n}\nfunction scaleProjection(createProjection, kx, ky) {\n  return {\n    type: ({\n      width,\n      height,\n      rotate,\n      precision = 0.15,\n      clip\n    }) => {\n      const projection = createProjection();\n      if (precision != null) projection.precision?.(precision);\n      if (rotate != null) projection.rotate?.(rotate);\n      if (typeof clip === \"number\") projection.clipAngle?.(clip);\n      if (width != null) {\n        projection.scale(Math.min(width / kx, height / ky));\n        projection.translate([width / 2, height / 2]);\n      }\n      return projection;\n    },\n    aspectRatio: ky / kx\n  };\n}\nfunction conicProjection(createProjection, kx, ky) {\n  const {\n    type,\n    aspectRatio\n  } = scaleProjection(createProjection, kx, ky);\n  return {\n    type: options => {\n      const {\n        parallels,\n        domain,\n        width,\n        height\n      } = options;\n      const projection = type(options);\n      if (parallels != null) {\n        projection.parallels(parallels);\n        if (domain === undefined && width != null) {\n          projection.fitSize([width, height], {\n            type: \"Sphere\"\n          });\n        }\n      }\n      return projection;\n    },\n    aspectRatio\n  };\n}\nconst identity = constant({\n  stream: stream => stream\n});\nconst reflectY = constant(geoTransform({\n  point(x, y) {\n    this.stream.point(x, -y);\n  }\n}));\n\n// Applies a point-wise projection to the given paired x and y channels.\n// Note: mutates values!\nexport function project(cx, cy, values, projection) {\n  const x = values[cx];\n  const y = values[cy];\n  const n = x.length;\n  const X = values[cx] = new Float64Array(n).fill(NaN);\n  const Y = values[cy] = new Float64Array(n).fill(NaN);\n  let i;\n  const stream = projection.stream({\n    point(x, y) {\n      X[i] = x;\n      Y[i] = y;\n    }\n  });\n  for (i = 0; i < n; ++i) {\n    stream.point(x[i], y[i]);\n  }\n}\n\n// Returns true if a projection was specified. This should match the logic of\n// createProjection above, and is called before we construct the projection.\n// (Though note that we ignore the edge case where the projection initializer\n// may return null.)\nexport function hasProjection({\n  projection\n} = {}) {\n  if (projection == null) return false;\n  if (typeof projection.stream === \"function\") return true;\n  if (isObject(projection)) projection = projection.type;\n  return projection != null;\n}\n\n// When a projection is specified, we can use its aspect ratio to determine a\n// good value for the projection’s height based on the desired width. When we\n// don’t have a way to know, the golden ratio is our best guess. Due to a\n// circular dependency (we need to know the height before we can construct the\n// projection), we have to test the raw projection option rather than the\n// materialized projection; therefore we must be extremely careful that the\n// logic of this function exactly matches createProjection above!\nexport function projectionAspectRatio(projection) {\n  if (typeof projection?.stream === \"function\") return defaultAspectRatio;\n  if (isObject(projection)) {\n    let domain, options;\n    ({\n      domain,\n      type: projection,\n      ...options\n    } = projection);\n    if (domain != null && projection != null) {\n      const type = typeof projection === \"string\" ? namedProjection(projection).type : projection;\n      const [[x0, y0], [x1, y1]] = geoPath(type({\n        ...options,\n        width: 100,\n        height: 100\n      })).bounds(domain);\n      const r = (y1 - y0) / (x1 - x0);\n      return r && isFinite(r) ? r < 0.2 ? 0.2 : r > 5 ? 5 : r : defaultAspectRatio;\n    }\n  }\n  if (projection == null) return;\n  if (typeof projection !== \"function\") {\n    const {\n      aspectRatio\n    } = namedProjection(projection);\n    if (aspectRatio) return aspectRatio;\n  }\n  return defaultAspectRatio;\n}\n\n// Extract the (possibly) scaled values for the x and y channels, and apply the\n// projection if any.\nexport function applyPosition(channels, scales, {\n  projection\n}) {\n  const {\n    x,\n    y\n  } = channels;\n  let position = {};\n  if (x) position.x = x;\n  if (y) position.y = y;\n  position = valueObject(position, scales);\n  if (projection && x?.scale === \"x\" && y?.scale === \"y\") project(\"x\", \"y\", position, projection);\n  if (x) position.x = coerceNumbers(position.x);\n  if (y) position.y = coerceNumbers(position.y);\n  return position;\n}\nexport function getGeometryChannels(channel) {\n  const X = [];\n  const Y = [];\n  const x = {\n    scale: \"x\",\n    value: X\n  };\n  const y = {\n    scale: \"y\",\n    value: Y\n  };\n  const sink = {\n    point(x, y) {\n      X.push(x);\n      Y.push(y);\n    },\n    lineStart() {},\n    lineEnd() {},\n    polygonStart() {},\n    polygonEnd() {},\n    sphere() {}\n  };\n  for (const object of channel.value) geoStream(object, sink);\n  return [x, y];\n}","map":{"version":3,"names":["geoAlbers","geoAlbersUsa","geoAzimuthalEqualArea","geoAzimuthalEquidistant","geoClipRectangle","geoConicConformal","geoConicEqualArea","geoConicEquidistant","geoEqualEarth","geoEquirectangular","geoGnomonic","geoMercator","geoOrthographic","geoPath","geoStereographic","geoStream","geoTransform","geoTransverseMercator","valueObject","coerceNumbers","constant","isObject","warn","pi","Math","PI","tau","defaultAspectRatio","createProjection","projection","inset","globalInset","insetTop","insetRight","insetBottom","insetLeft","dimensions","stream","options","domain","clip","type","undefined","namedProjection","width","height","marginLeft","marginRight","marginTop","marginBottom","dx","dy","maybePostClip","tx","ty","transform","x0","y0","x1","y1","bounds","k","min","point","x","y","identity","s","toLowerCase","scaleProjection","conicProjection","reflectY","Error","x2","y2","kx","ky","rotate","precision","clipAngle","scale","translate","aspectRatio","parallels","fitSize","project","cx","cy","values","n","length","X","Float64Array","fill","NaN","Y","i","hasProjection","projectionAspectRatio","r","isFinite","applyPosition","channels","scales","position","getGeometryChannels","channel","value","sink","push","lineStart","lineEnd","polygonStart","polygonEnd","sphere","object"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/projection.js"],"sourcesContent":["import {\n  geoAlbers,\n  geoAlbersUsa,\n  geoAzimuthalEqualArea,\n  geoAzimuthalEquidistant,\n  geoClipRectangle,\n  geoConicConformal,\n  geoConicEqualArea,\n  geoConicEquidistant,\n  geoEqualEarth,\n  geoEquirectangular,\n  geoGnomonic,\n  geoMercator,\n  geoOrthographic,\n  geoPath,\n  geoStereographic,\n  geoStream,\n  geoTransform,\n  geoTransverseMercator\n} from \"d3\";\nimport {valueObject} from \"./channel.js\";\nimport {coerceNumbers, constant, isObject} from \"./options.js\";\nimport {warn} from \"./warnings.js\";\n\nconst pi = Math.PI;\nconst tau = 2 * pi;\nconst defaultAspectRatio = 0.618;\n\nexport function createProjection(\n  {\n    projection,\n    inset: globalInset = 0,\n    insetTop = globalInset,\n    insetRight = globalInset,\n    insetBottom = globalInset,\n    insetLeft = globalInset\n  } = {},\n  dimensions\n) {\n  if (projection == null) return;\n  if (typeof projection.stream === \"function\") return projection; // d3 projection\n  let options;\n  let domain;\n  let clip = \"frame\";\n\n  // If the projection was specified as an object with additional options,\n  // extract those. The order of precedence for insetTop (and other insets) is:\n  // projection.insetTop, projection.inset, (global) insetTop, (global) inset.\n  // Any other options on this object will be passed through to the initializer.\n  if (isObject(projection)) {\n    let inset;\n    ({\n      type: projection,\n      domain,\n      inset,\n      insetTop = inset !== undefined ? inset : insetTop,\n      insetRight = inset !== undefined ? inset : insetRight,\n      insetBottom = inset !== undefined ? inset : insetBottom,\n      insetLeft = inset !== undefined ? inset : insetLeft,\n      clip = clip,\n      ...options\n    } = projection);\n    if (projection == null) return;\n  }\n\n  // For named projections, retrieve the corresponding projection initializer.\n  if (typeof projection !== \"function\") ({type: projection} = namedProjection(projection));\n\n  // Compute the frame dimensions and invoke the projection initializer.\n  const {width, height, marginLeft, marginRight, marginTop, marginBottom} = dimensions;\n  const dx = width - marginLeft - marginRight - insetLeft - insetRight;\n  const dy = height - marginTop - marginBottom - insetTop - insetBottom;\n  projection = projection?.({width: dx, height: dy, clip, ...options});\n\n  // The projection initializer might decide to not use a projection.\n  if (projection == null) return;\n  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);\n\n  // Translate the origin to the top-left corner, respecting margins and insets.\n  let tx = marginLeft + insetLeft;\n  let ty = marginTop + insetTop;\n  let transform;\n\n  // If a domain is specified, fit the projection to the frame.\n  if (domain != null) {\n    const [[x0, y0], [x1, y1]] = geoPath(projection).bounds(domain);\n    const k = Math.min(dx / (x1 - x0), dy / (y1 - y0));\n    if (k > 0) {\n      tx -= (k * (x0 + x1) - dx) / 2;\n      ty -= (k * (y0 + y1) - dy) / 2;\n      transform = geoTransform({\n        point(x, y) {\n          this.stream.point(x * k + tx, y * k + ty);\n        }\n      });\n    } else {\n      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);\n    }\n  }\n\n  transform ??=\n    tx === 0 && ty === 0\n      ? identity()\n      : geoTransform({\n          point(x, y) {\n            this.stream.point(x + tx, y + ty);\n          }\n        });\n\n  return {stream: (s) => projection.stream(transform.stream(clip(s)))};\n}\n\nfunction namedProjection(projection) {\n  switch (`${projection}`.toLowerCase()) {\n    case \"albers-usa\":\n      return scaleProjection(geoAlbersUsa, 0.7463, 0.4673);\n    case \"albers\":\n      return conicProjection(geoAlbers, 0.7463, 0.4673);\n    case \"azimuthal-equal-area\":\n      return scaleProjection(geoAzimuthalEqualArea, 4, 4);\n    case \"azimuthal-equidistant\":\n      return scaleProjection(geoAzimuthalEquidistant, tau, tau);\n    case \"conic-conformal\":\n      return conicProjection(geoConicConformal, tau, tau);\n    case \"conic-equal-area\":\n      return conicProjection(geoConicEqualArea, 6.1702, 2.9781);\n    case \"conic-equidistant\":\n      return conicProjection(geoConicEquidistant, 7.312, 3.6282);\n    case \"equal-earth\":\n      return scaleProjection(geoEqualEarth, 5.4133, 2.6347);\n    case \"equirectangular\":\n      return scaleProjection(geoEquirectangular, tau, pi);\n    case \"gnomonic\":\n      return scaleProjection(geoGnomonic, 3.4641, 3.4641);\n    case \"identity\":\n      return {type: identity};\n    case \"reflect-y\":\n      return {type: reflectY};\n    case \"mercator\":\n      return scaleProjection(geoMercator, tau, tau);\n    case \"orthographic\":\n      return scaleProjection(geoOrthographic, 2, 2);\n    case \"stereographic\":\n      return scaleProjection(geoStereographic, 2, 2);\n    case \"transverse-mercator\":\n      return scaleProjection(geoTransverseMercator, tau, tau);\n    default:\n      throw new Error(`unknown projection type: ${projection}`);\n  }\n}\n\nfunction maybePostClip(clip, x1, y1, x2, y2) {\n  if (clip === false || clip == null || typeof clip === \"number\") return (s) => s;\n  if (clip === true) clip = \"frame\";\n  switch (`${clip}`.toLowerCase()) {\n    case \"frame\":\n      return geoClipRectangle(x1, y1, x2, y2);\n    default:\n      throw new Error(`unknown projection clip type: ${clip}`);\n  }\n}\n\nfunction scaleProjection(createProjection, kx, ky) {\n  return {\n    type: ({width, height, rotate, precision = 0.15, clip}) => {\n      const projection = createProjection();\n      if (precision != null) projection.precision?.(precision);\n      if (rotate != null) projection.rotate?.(rotate);\n      if (typeof clip === \"number\") projection.clipAngle?.(clip);\n      if (width != null) {\n        projection.scale(Math.min(width / kx, height / ky));\n        projection.translate([width / 2, height / 2]);\n      }\n      return projection;\n    },\n    aspectRatio: ky / kx\n  };\n}\n\nfunction conicProjection(createProjection, kx, ky) {\n  const {type, aspectRatio} = scaleProjection(createProjection, kx, ky);\n  return {\n    type: (options) => {\n      const {parallels, domain, width, height} = options;\n      const projection = type(options);\n      if (parallels != null) {\n        projection.parallels(parallels);\n        if (domain === undefined && width != null) {\n          projection.fitSize([width, height], {type: \"Sphere\"});\n        }\n      }\n      return projection;\n    },\n    aspectRatio\n  };\n}\n\nconst identity = constant({stream: (stream) => stream});\n\nconst reflectY = constant(\n  geoTransform({\n    point(x, y) {\n      this.stream.point(x, -y);\n    }\n  })\n);\n\n// Applies a point-wise projection to the given paired x and y channels.\n// Note: mutates values!\nexport function project(cx, cy, values, projection) {\n  const x = values[cx];\n  const y = values[cy];\n  const n = x.length;\n  const X = (values[cx] = new Float64Array(n).fill(NaN));\n  const Y = (values[cy] = new Float64Array(n).fill(NaN));\n  let i;\n  const stream = projection.stream({\n    point(x, y) {\n      X[i] = x;\n      Y[i] = y;\n    }\n  });\n  for (i = 0; i < n; ++i) {\n    stream.point(x[i], y[i]);\n  }\n}\n\n// Returns true if a projection was specified. This should match the logic of\n// createProjection above, and is called before we construct the projection.\n// (Though note that we ignore the edge case where the projection initializer\n// may return null.)\nexport function hasProjection({projection} = {}) {\n  if (projection == null) return false;\n  if (typeof projection.stream === \"function\") return true;\n  if (isObject(projection)) projection = projection.type;\n  return projection != null;\n}\n\n// When a projection is specified, we can use its aspect ratio to determine a\n// good value for the projection’s height based on the desired width. When we\n// don’t have a way to know, the golden ratio is our best guess. Due to a\n// circular dependency (we need to know the height before we can construct the\n// projection), we have to test the raw projection option rather than the\n// materialized projection; therefore we must be extremely careful that the\n// logic of this function exactly matches createProjection above!\nexport function projectionAspectRatio(projection) {\n  if (typeof projection?.stream === \"function\") return defaultAspectRatio;\n  if (isObject(projection)) {\n    let domain, options;\n    ({domain, type: projection, ...options} = projection);\n    if (domain != null && projection != null) {\n      const type = typeof projection === \"string\" ? namedProjection(projection).type : projection;\n      const [[x0, y0], [x1, y1]] = geoPath(type({...options, width: 100, height: 100})).bounds(domain);\n      const r = (y1 - y0) / (x1 - x0);\n      return r && isFinite(r) ? (r < 0.2 ? 0.2 : r > 5 ? 5 : r) : defaultAspectRatio;\n    }\n  }\n  if (projection == null) return;\n  if (typeof projection !== \"function\") {\n    const {aspectRatio} = namedProjection(projection);\n    if (aspectRatio) return aspectRatio;\n  }\n  return defaultAspectRatio;\n}\n\n// Extract the (possibly) scaled values for the x and y channels, and apply the\n// projection if any.\nexport function applyPosition(channels, scales, {projection}) {\n  const {x, y} = channels;\n  let position = {};\n  if (x) position.x = x;\n  if (y) position.y = y;\n  position = valueObject(position, scales);\n  if (projection && x?.scale === \"x\" && y?.scale === \"y\") project(\"x\", \"y\", position, projection);\n  if (x) position.x = coerceNumbers(position.x);\n  if (y) position.y = coerceNumbers(position.y);\n  return position;\n}\n\nexport function getGeometryChannels(channel) {\n  const X = [];\n  const Y = [];\n  const x = {scale: \"x\", value: X};\n  const y = {scale: \"y\", value: Y};\n  const sink = {\n    point(x, y) {\n      X.push(x);\n      Y.push(y);\n    },\n    lineStart() {},\n    lineEnd() {},\n    polygonStart() {},\n    polygonEnd() {},\n    sphere() {}\n  };\n  for (const object of channel.value) geoStream(object, sink);\n  return [x, y];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}