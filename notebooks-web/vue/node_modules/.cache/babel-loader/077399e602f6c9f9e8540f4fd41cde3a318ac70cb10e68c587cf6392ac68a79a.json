{"ast":null,"code":"import { InternSet, extent, format, utcFormat } from \"d3\";\nimport { formatDefault } from \"../format.js\";\nimport { marks } from \"../mark.js\";\nimport { radians } from \"../math.js\";\nimport { arrayify, constant, identity, keyword, number, range, valueof } from \"../options.js\";\nimport { isIterable, isNoneish, isTemporal, isInterval } from \"../options.js\";\nimport { maybeColorChannel, maybeNumberChannel, maybeRangeInterval } from \"../options.js\";\nimport { inferScaleOrder } from \"../scales.js\";\nimport { offset } from \"../style.js\";\nimport { generalizeTimeInterval, inferTimeFormat, intervalDuration } from \"../time.js\";\nimport { initializer } from \"../transforms/basic.js\";\nimport { warn } from \"../warnings.js\";\nimport { ruleX, ruleY } from \"./rule.js\";\nimport { text, textX, textY } from \"./text.js\";\nimport { vectorX, vectorY } from \"./vector.js\";\nfunction maybeData(data, options) {\n  if (arguments.length < 2 && !isIterable(data)) options = data, data = null;\n  if (options === undefined) options = {};\n  return [data, options];\n}\nfunction maybeAnchor({\n  anchor\n} = {}, anchors) {\n  return anchor === undefined ? anchors[0] : keyword(anchor, \"anchor\", anchors);\n}\nfunction anchorY(options) {\n  return maybeAnchor(options, [\"left\", \"right\"]);\n}\nfunction anchorFy(options) {\n  return maybeAnchor(options, [\"right\", \"left\"]);\n}\nfunction anchorX(options) {\n  return maybeAnchor(options, [\"bottom\", \"top\"]);\n}\nfunction anchorFx(options) {\n  return maybeAnchor(options, [\"top\", \"bottom\"]);\n}\nexport function axisY() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"y\", anchorY(options), data, options);\n}\nexport function axisFy() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"fy\", anchorFy(options), data, options);\n}\nexport function axisX() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"x\", anchorX(options), data, options);\n}\nexport function axisFx() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"fx\", anchorFx(options), data, options);\n}\nfunction axisKy(k, anchor, data, {\n  color = \"currentColor\",\n  opacity = 1,\n  stroke = color,\n  strokeOpacity = opacity,\n  strokeWidth = 1,\n  fill = color,\n  fillOpacity = opacity,\n  textAnchor,\n  textStroke,\n  textStrokeOpacity,\n  textStrokeWidth,\n  tickSize = k === \"y\" ? 6 : 0,\n  tickPadding,\n  tickRotate,\n  x,\n  margin,\n  marginTop = margin === undefined ? 20 : margin,\n  marginRight = margin === undefined ? anchor === \"right\" ? 40 : 0 : margin,\n  marginBottom = margin === undefined ? 20 : margin,\n  marginLeft = margin === undefined ? anchor === \"left\" ? 40 : 0 : margin,\n  label,\n  labelAnchor,\n  labelArrow,\n  labelOffset,\n  ...options\n}) {\n  tickSize = number(tickSize);\n  tickPadding = number(tickPadding);\n  tickRotate = number(tickRotate);\n  if (labelAnchor !== undefined) labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"top\", \"bottom\"]);\n  labelArrow = maybeLabelArrow(labelArrow);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKy(k, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKy(k, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    x,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], labelOptions({\n    fill,\n    fillOpacity,\n    ...options\n  }, function (data, facets, channels, scales, dimensions) {\n    const scale = scales[k];\n    const {\n      marginTop,\n      marginRight,\n      marginBottom,\n      marginLeft\n    } = k === \"y\" && dimensions.inset || dimensions;\n    const cla = labelAnchor ?? (scale.bandwidth ? \"center\" : \"top\");\n    const clo = labelOffset ?? (anchor === \"right\" ? marginRight : marginLeft) - 3;\n    if (cla === \"center\") {\n      this.textAnchor = undefined; // middle\n      this.lineAnchor = anchor === \"right\" ? \"bottom\" : \"top\";\n      this.frameAnchor = anchor;\n      this.rotate = -90;\n    } else {\n      this.textAnchor = anchor === \"right\" ? \"end\" : \"start\";\n      this.lineAnchor = cla;\n      this.frameAnchor = `${cla}-${anchor}`;\n      this.rotate = 0;\n    }\n    this.dy = cla === \"top\" ? 3 - marginTop : cla === \"bottom\" ? marginBottom - 3 : 0;\n    this.dx = anchor === \"right\" ? clo : -clo;\n    this.ariaLabel = `${k}-axis label`;\n    return {\n      facets: [[0]],\n      channels: {\n        text: {\n          value: [formatAxisLabel(k, scale, {\n            anchor,\n            label,\n            labelAnchor: cla,\n            labelArrow\n          })]\n        }\n      }\n    };\n  })) : null);\n}\nfunction axisKx(k, anchor, data, {\n  color = \"currentColor\",\n  opacity = 1,\n  stroke = color,\n  strokeOpacity = opacity,\n  strokeWidth = 1,\n  fill = color,\n  fillOpacity = opacity,\n  textAnchor,\n  textStroke,\n  textStrokeOpacity,\n  textStrokeWidth,\n  tickSize = k === \"x\" ? 6 : 0,\n  tickPadding,\n  tickRotate,\n  y,\n  margin,\n  marginTop = margin === undefined ? anchor === \"top\" ? 30 : 0 : margin,\n  marginRight = margin === undefined ? 20 : margin,\n  marginBottom = margin === undefined ? anchor === \"bottom\" ? 30 : 0 : margin,\n  marginLeft = margin === undefined ? 20 : margin,\n  label,\n  labelAnchor,\n  labelArrow,\n  labelOffset,\n  ...options\n}) {\n  tickSize = number(tickSize);\n  tickPadding = number(tickPadding);\n  tickRotate = number(tickRotate);\n  if (labelAnchor !== undefined) labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"left\", \"right\"]);\n  labelArrow = maybeLabelArrow(labelArrow);\n  return marks(tickSize && !isNoneish(stroke) ? axisTickKx(k, anchor, data, {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y,\n    ...options\n  }) : null, !isNoneish(fill) ? axisTextKx(k, anchor, data, {\n    fill,\n    fillOpacity,\n    stroke: textStroke,\n    strokeOpacity: textStrokeOpacity,\n    strokeWidth: textStrokeWidth,\n    textAnchor,\n    tickSize,\n    tickPadding,\n    tickRotate,\n    y,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    ...options\n  }) : null, !isNoneish(fill) && label !== null ? text([], labelOptions({\n    fill,\n    fillOpacity,\n    ...options\n  }, function (data, facets, channels, scales, dimensions) {\n    const scale = scales[k];\n    const {\n      marginTop,\n      marginRight,\n      marginBottom,\n      marginLeft\n    } = k === \"x\" && dimensions.inset || dimensions;\n    const cla = labelAnchor ?? (scale.bandwidth ? \"center\" : \"right\");\n    const clo = labelOffset ?? (anchor === \"top\" ? marginTop : marginBottom) - 3;\n    if (cla === \"center\") {\n      this.frameAnchor = anchor;\n      this.textAnchor = undefined; // middle\n    } else {\n      this.frameAnchor = `${anchor}-${cla}`;\n      this.textAnchor = cla === \"right\" ? \"end\" : \"start\";\n    }\n    this.lineAnchor = anchor;\n    this.dy = anchor === \"top\" ? -clo : clo;\n    this.dx = cla === \"right\" ? marginRight - 3 : cla === \"left\" ? 3 - marginLeft : 0;\n    this.ariaLabel = `${k}-axis label`;\n    return {\n      facets: [[0]],\n      channels: {\n        text: {\n          value: [formatAxisLabel(k, scale, {\n            anchor,\n            label,\n            labelAnchor: cla,\n            labelArrow\n          })]\n        }\n      }\n    };\n  })) : null);\n}\nfunction axisTickKy(k, anchor, data, {\n  strokeWidth = 1,\n  strokeLinecap = null,\n  strokeLinejoin = null,\n  facetAnchor = anchor + (k === \"y\" ? \"-empty\" : \"\"),\n  frameAnchor = anchor,\n  tickSize,\n  inset = 0,\n  insetLeft = inset,\n  insetRight = inset,\n  dx = 0,\n  y = k === \"y\" ? undefined : null,\n  ...options\n}) {\n  return axisMark(vectorY, k, data, {\n    ariaLabel: `${k}-axis tick`,\n    ariaHidden: true\n  }, {\n    strokeWidth,\n    strokeLinecap,\n    strokeLinejoin,\n    facetAnchor,\n    frameAnchor,\n    y,\n    ...options,\n    dx: anchor === \"left\" ? +dx - offset + +insetLeft : +dx + offset - insetRight,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"left\" ? shapeTickLeft : shapeTickRight\n  });\n}\nfunction axisTickKx(k, anchor, data, {\n  strokeWidth = 1,\n  strokeLinecap = null,\n  strokeLinejoin = null,\n  facetAnchor = anchor + (k === \"x\" ? \"-empty\" : \"\"),\n  frameAnchor = anchor,\n  tickSize,\n  inset = 0,\n  insetTop = inset,\n  insetBottom = inset,\n  dy = 0,\n  x = k === \"x\" ? undefined : null,\n  ...options\n}) {\n  return axisMark(vectorX, k, data, {\n    ariaLabel: `${k}-axis tick`,\n    ariaHidden: true\n  }, {\n    strokeWidth,\n    strokeLinejoin,\n    strokeLinecap,\n    facetAnchor,\n    frameAnchor,\n    x,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy - offset - insetBottom : +dy + offset + +insetTop,\n    anchor: \"start\",\n    length: tickSize,\n    shape: anchor === \"bottom\" ? shapeTickBottom : shapeTickTop\n  });\n}\nfunction axisTextKy(k, anchor, data, {\n  facetAnchor = anchor + (k === \"y\" ? \"-empty\" : \"\"),\n  frameAnchor = anchor,\n  tickSize,\n  tickRotate = 0,\n  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians) : 0),\n  text,\n  textAnchor = Math.abs(tickRotate) > 60 ? \"middle\" : anchor === \"left\" ? \"end\" : \"start\",\n  lineAnchor = tickRotate > 60 ? \"top\" : tickRotate < -60 ? \"bottom\" : \"middle\",\n  fontVariant,\n  inset = 0,\n  insetLeft = inset,\n  insetRight = inset,\n  dx = 0,\n  y = k === \"y\" ? undefined : null,\n  ...options\n}) {\n  return axisMark(textY, k, data, {\n    ariaLabel: `${k}-axis tick label`\n  }, {\n    facetAnchor,\n    frameAnchor,\n    text,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    y,\n    ...options,\n    dx: anchor === \"left\" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight\n  }, function (scale, data, ticks, tickFormat, channels) {\n    if (fontVariant === undefined) this.fontVariant = inferFontVariant(scale);\n    if (text === undefined) channels.text = inferTextChannel(scale, data, ticks, tickFormat, anchor);\n  });\n}\nfunction axisTextKx(k, anchor, data, {\n  facetAnchor = anchor + (k === \"x\" ? \"-empty\" : \"\"),\n  frameAnchor = anchor,\n  tickSize,\n  tickRotate = 0,\n  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians) : 0),\n  text,\n  textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === \"bottom\" ? \"start\" : \"end\" : \"middle\",\n  lineAnchor = Math.abs(tickRotate) >= 10 ? \"middle\" : anchor === \"bottom\" ? \"top\" : \"bottom\",\n  fontVariant,\n  inset = 0,\n  insetTop = inset,\n  insetBottom = inset,\n  dy = 0,\n  x = k === \"x\" ? undefined : null,\n  ...options\n}) {\n  return axisMark(textX, k, data, {\n    ariaLabel: `${k}-axis tick label`\n  }, {\n    facetAnchor,\n    frameAnchor,\n    text: text === undefined ? null : text,\n    textAnchor,\n    lineAnchor,\n    fontVariant,\n    rotate: tickRotate,\n    x,\n    ...options,\n    dy: anchor === \"bottom\" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop\n  }, function (scale, data, ticks, tickFormat, channels) {\n    if (fontVariant === undefined) this.fontVariant = inferFontVariant(scale);\n    if (text === undefined) channels.text = inferTextChannel(scale, data, ticks, tickFormat, anchor);\n  });\n}\nexport function gridY() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"y\", anchorY(options), data, options);\n}\nexport function gridFy() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"fy\", anchorFy(options), data, options);\n}\nexport function gridX() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"x\", anchorX(options), data, options);\n}\nexport function gridFx() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"fx\", anchorFx(options), data, options);\n}\nfunction gridKy(k, anchor, data, {\n  y = k === \"y\" ? undefined : null,\n  x = null,\n  x1 = anchor === \"left\" ? x : null,\n  x2 = anchor === \"right\" ? x : null,\n  ...options\n}) {\n  return axisMark(ruleY, k, data, {\n    ariaLabel: `${k}-grid`,\n    ariaHidden: true\n  }, {\n    y,\n    x1,\n    x2,\n    ...gridDefaults(options)\n  });\n}\nfunction gridKx(k, anchor, data, {\n  x = k === \"x\" ? undefined : null,\n  y = null,\n  y1 = anchor === \"top\" ? y : null,\n  y2 = anchor === \"bottom\" ? y : null,\n  ...options\n}) {\n  return axisMark(ruleX, k, data, {\n    ariaLabel: `${k}-grid`,\n    ariaHidden: true\n  }, {\n    x,\n    y1,\n    y2,\n    ...gridDefaults(options)\n  });\n}\nfunction gridDefaults({\n  color = \"currentColor\",\n  opacity = 0.1,\n  stroke = color,\n  strokeOpacity = opacity,\n  strokeWidth = 1,\n  ...options\n}) {\n  return {\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    ...options\n  };\n}\nfunction labelOptions({\n  fill,\n  fillOpacity,\n  fontFamily,\n  fontSize,\n  fontStyle,\n  fontVariant,\n  fontWeight,\n  monospace,\n  pointerEvents,\n  shapeRendering,\n  clip = false\n}, initializer) {\n  // Only propagate these options if constant.\n  [, fill] = maybeColorChannel(fill);\n  [, fillOpacity] = maybeNumberChannel(fillOpacity);\n  return {\n    facet: \"super\",\n    x: null,\n    y: null,\n    fill,\n    fillOpacity,\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontVariant,\n    fontWeight,\n    monospace,\n    pointerEvents,\n    shapeRendering,\n    clip,\n    initializer\n  };\n}\nfunction axisMark(mark, k, data, properties, options, initialize) {\n  let channels;\n  function axisInitializer(data, facets, _channels, scales, dimensions, context) {\n    const initializeFacets = data == null && (k === \"fx\" || k === \"fy\");\n    const {\n      [k]: scale\n    } = scales;\n    if (!scale) throw new Error(`missing scale: ${k}`);\n    const domain = scale.domain();\n    let {\n      interval,\n      ticks,\n      tickFormat,\n      tickSpacing = k === \"x\" ? 80 : 35\n    } = options;\n    // For a scale with a temporal domain, also allow the ticks to be specified\n    // as a string which is promoted to a time interval. In the case of ordinal\n    // scales, the interval is interpreted as UTC.\n    if (typeof ticks === \"string\" && hasTemporalDomain(scale)) interval = ticks, ticks = undefined;\n    // The interval axis option is an alternative method of specifying ticks;\n    // for example, for a numeric scale, ticks = 5 means “about 5 ticks” whereas\n    // interval = 5 means “ticks every 5 units”. (This is not to be confused\n    // with the interval scale option, which affects the scale’s behavior!)\n    // Lastly use the tickSpacing option to infer the desired tick count.\n    if (ticks === undefined) ticks = maybeRangeInterval(interval, scale.type) ?? inferTickCount(scale, tickSpacing);\n    if (data == null) {\n      if (isIterable(ticks)) {\n        // Use explicit ticks, if specified.\n        data = arrayify(ticks);\n      } else if (isInterval(ticks)) {\n        // Use the tick interval, if specified.\n        data = inclusiveRange(ticks, ...extent(domain));\n      } else if (scale.interval) {\n        // If the scale interval is a standard time interval such as \"day\", we\n        // may be able to generalize the scale interval it to a larger aligned\n        // time interval to create the desired number of ticks.\n        let interval = scale.interval;\n        if (scale.ticks) {\n          const [min, max] = extent(domain);\n          const n = (max - min) / interval[intervalDuration]; // current tick count\n          // We don’t explicitly check that given interval is a time interval;\n          // in that case the generalized interval will be undefined, just like\n          // a nonstandard interval. TODO Generalize integer intervals, too.\n          interval = generalizeTimeInterval(interval, n / ticks) ?? interval;\n          data = inclusiveRange(interval, min, max);\n        } else {\n          data = domain;\n          const n = data.length; // current tick count\n          interval = generalizeTimeInterval(interval, n / ticks) ?? interval;\n          if (interval !== scale.interval) data = inclusiveRange(interval, ...extent(data));\n        }\n        if (interval === scale.interval) {\n          // If we weren’t able to generalize the scale’s interval, compute the\n          // positive number n such that taking every nth value from the scale’s\n          // domain produces as close as possible to the desired number of\n          // ticks. For example, if the domain has 100 values and 5 ticks are\n          // desired, n = 20.\n          const n = Math.round(data.length / ticks);\n          if (n > 1) data = data.filter((d, i) => i % n === 0);\n        }\n      } else if (scale.ticks) {\n        data = scale.ticks(ticks);\n      } else {\n        // For ordinal scales, the domain will already be generated using the\n        // scale’s interval, if any.\n        data = domain;\n      }\n      if (!scale.ticks && data.length && data !== domain) {\n        // For ordinal scales, intersect the ticks with the scale domain since\n        // the scale is only defined on its domain. If all of the ticks are\n        // removed, then warn that the ticks and scale domain may be misaligned\n        // (e.g., \"year\" ticks and \"4 weeks\" interval).\n        const domainSet = new InternSet(domain);\n        data = data.filter(d => domainSet.has(d));\n        if (!data.length) warn(`Warning: the ${k}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`); // prettier-ignore\n      }\n\n      if (k === \"y\" || k === \"x\") {\n        facets = [range(data)];\n      } else {\n        channels[k] = {\n          scale: k,\n          value: identity\n        };\n      }\n    }\n    initialize?.call(this, scale, data, ticks, tickFormat, channels);\n    const initializedChannels = Object.fromEntries(Object.entries(channels).map(([name, channel]) => {\n      return [name, {\n        ...channel,\n        value: valueof(data, channel.value)\n      }];\n    }));\n    if (initializeFacets) facets = context.filterFacets(data, initializedChannels);\n    return {\n      data,\n      facets,\n      channels: initializedChannels\n    };\n  }\n\n  // Apply any basic initializers after the axis initializer computes the ticks.\n  const basicInitializer = initializer(options).initializer;\n  const m = mark(data, initializer({\n    ...options,\n    initializer: axisInitializer\n  }, basicInitializer));\n  if (data == null) {\n    channels = m.channels;\n    m.channels = {};\n  } else {\n    channels = {};\n  }\n  if (properties !== undefined) Object.assign(m, properties);\n  if (m.clip === undefined) m.clip = false; // don’t clip axes by default\n  return m;\n}\nfunction inferTickCount(scale, tickSpacing) {\n  const [min, max] = extent(scale.range());\n  return (max - min) / tickSpacing;\n}\nfunction inferTextChannel(scale, data, ticks, tickFormat, anchor) {\n  return {\n    value: inferTickFormat(scale, data, ticks, tickFormat, anchor)\n  };\n}\n\n// D3’s ordinal scales simply use toString by default, but if the ordinal scale\n// domain (or ticks) are numbers or dates (say because we’re applying a time\n// interval to the ordinal scale), we want Plot’s default formatter. And for\n// time ticks, we want to use the multi-line time format (e.g., Jan 26) if\n// possible, or the default ISO format (2014-01-26). TODO We need a better way\n// to infer whether the ordinal scale is UTC or local time.\nexport function inferTickFormat(scale, data, ticks, tickFormat, anchor) {\n  return typeof tickFormat === \"function\" && !(scale.type === \"log\" && scale.tickFormat) ? tickFormat : tickFormat === undefined && data && isTemporal(data) ? inferTimeFormat(scale.type, data, anchor) ?? formatDefault : scale.tickFormat ? scale.tickFormat(typeof ticks === \"number\" ? ticks : null, tickFormat) : tickFormat === undefined ? formatDefault : typeof tickFormat === \"string\" ? (isTemporal(scale.domain()) ? utcFormat : format)(tickFormat) : constant(tickFormat);\n}\nfunction inclusiveRange(interval, min, max) {\n  return interval.range(min, interval.offset(interval.floor(max)));\n}\nconst shapeTickBottom = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, l);\n  }\n};\nconst shapeTickTop = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n  }\n};\nconst shapeTickLeft = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(-l, 0);\n  }\n};\nconst shapeTickRight = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(l, 0);\n  }\n};\n\n// TODO Unify this with the other inferFontVariant; here we only have a scale\n// function rather than a scale descriptor.\nfunction inferFontVariant(scale) {\n  return scale.bandwidth && !scale.interval ? undefined : \"tabular-nums\";\n}\n\n// Takes the scale label, and if this is not an ordinal scale and the label was\n// inferred from an associated channel, adds an orientation-appropriate arrow.\nfunction formatAxisLabel(k, scale, {\n  anchor,\n  label = scale.label,\n  labelAnchor,\n  labelArrow\n} = {}) {\n  if (label == null || label.inferred && hasTemporalDomain(scale) && /^(date|time|year)$/i.test(label)) return;\n  label = String(label); // coerce to a string after checking if inferred\n  if (labelArrow === \"auto\") labelArrow = (!scale.bandwidth || scale.interval) && !/[↑↓→←]/.test(label);\n  if (!labelArrow) return label;\n  if (labelArrow === true) {\n    const order = inferScaleOrder(scale);\n    if (order) labelArrow = /x$/.test(k) || labelAnchor === \"center\" ? /x$/.test(k) === order < 0 ? \"left\" : \"right\" : order < 0 ? \"up\" : \"down\";\n  }\n  switch (labelArrow) {\n    case \"left\":\n      return `← ${label}`;\n    case \"right\":\n      return `${label} →`;\n    case \"up\":\n      return anchor === \"right\" ? `${label} ↑` : `↑ ${label}`;\n    case \"down\":\n      return anchor === \"right\" ? `${label} ↓` : `↓ ${label}`;\n  }\n  return label;\n}\nfunction maybeLabelArrow(labelArrow = \"auto\") {\n  return isNoneish(labelArrow) ? false : typeof labelArrow === \"boolean\" ? labelArrow : keyword(labelArrow, \"labelArrow\", [\"auto\", \"up\", \"right\", \"down\", \"left\"]);\n}\nfunction hasTemporalDomain(scale) {\n  return isTemporal(scale.domain());\n}","map":{"version":3,"names":["InternSet","extent","format","utcFormat","formatDefault","marks","radians","arrayify","constant","identity","keyword","number","range","valueof","isIterable","isNoneish","isTemporal","isInterval","maybeColorChannel","maybeNumberChannel","maybeRangeInterval","inferScaleOrder","offset","generalizeTimeInterval","inferTimeFormat","intervalDuration","initializer","warn","ruleX","ruleY","text","textX","textY","vectorX","vectorY","maybeData","data","options","arguments","length","undefined","maybeAnchor","anchor","anchors","anchorY","anchorFy","anchorX","anchorFx","axisY","axisKy","axisFy","axisX","axisKx","axisFx","k","color","opacity","stroke","strokeOpacity","strokeWidth","fill","fillOpacity","textAnchor","textStroke","textStrokeOpacity","textStrokeWidth","tickSize","tickPadding","tickRotate","x","margin","marginTop","marginRight","marginBottom","marginLeft","label","labelAnchor","labelArrow","labelOffset","maybeLabelArrow","axisTickKy","axisTextKy","labelOptions","facets","channels","scales","dimensions","scale","inset","cla","bandwidth","clo","lineAnchor","frameAnchor","rotate","dy","dx","ariaLabel","value","formatAxisLabel","y","axisTickKx","axisTextKx","strokeLinecap","strokeLinejoin","facetAnchor","insetLeft","insetRight","axisMark","ariaHidden","shape","shapeTickLeft","shapeTickRight","insetTop","insetBottom","shapeTickBottom","shapeTickTop","Math","max","abs","cos","fontVariant","ticks","tickFormat","inferFontVariant","inferTextChannel","gridY","gridKy","gridFy","gridX","gridKx","gridFx","x1","x2","gridDefaults","y1","y2","fontFamily","fontSize","fontStyle","fontWeight","monospace","pointerEvents","shapeRendering","clip","facet","mark","properties","initialize","axisInitializer","_channels","context","initializeFacets","Error","domain","interval","tickSpacing","hasTemporalDomain","type","inferTickCount","inclusiveRange","min","n","round","filter","d","i","domainSet","has","call","initializedChannels","Object","fromEntries","entries","map","name","channel","filterFacets","basicInitializer","m","assign","inferTickFormat","floor","draw","l","moveTo","lineTo","inferred","test","String","order"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/axis.js"],"sourcesContent":["import {InternSet, extent, format, utcFormat} from \"d3\";\nimport {formatDefault} from \"../format.js\";\nimport {marks} from \"../mark.js\";\nimport {radians} from \"../math.js\";\nimport {arrayify, constant, identity, keyword, number, range, valueof} from \"../options.js\";\nimport {isIterable, isNoneish, isTemporal, isInterval} from \"../options.js\";\nimport {maybeColorChannel, maybeNumberChannel, maybeRangeInterval} from \"../options.js\";\nimport {inferScaleOrder} from \"../scales.js\";\nimport {offset} from \"../style.js\";\nimport {generalizeTimeInterval, inferTimeFormat, intervalDuration} from \"../time.js\";\nimport {initializer} from \"../transforms/basic.js\";\nimport {warn} from \"../warnings.js\";\nimport {ruleX, ruleY} from \"./rule.js\";\nimport {text, textX, textY} from \"./text.js\";\nimport {vectorX, vectorY} from \"./vector.js\";\n\nfunction maybeData(data, options) {\n  if (arguments.length < 2 && !isIterable(data)) (options = data), (data = null);\n  if (options === undefined) options = {};\n  return [data, options];\n}\n\nfunction maybeAnchor({anchor} = {}, anchors) {\n  return anchor === undefined ? anchors[0] : keyword(anchor, \"anchor\", anchors);\n}\n\nfunction anchorY(options) {\n  return maybeAnchor(options, [\"left\", \"right\"]);\n}\n\nfunction anchorFy(options) {\n  return maybeAnchor(options, [\"right\", \"left\"]);\n}\n\nfunction anchorX(options) {\n  return maybeAnchor(options, [\"bottom\", \"top\"]);\n}\n\nfunction anchorFx(options) {\n  return maybeAnchor(options, [\"top\", \"bottom\"]);\n}\n\nexport function axisY() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"y\", anchorY(options), data, options);\n}\n\nexport function axisFy() {\n  const [data, options] = maybeData(...arguments);\n  return axisKy(\"fy\", anchorFy(options), data, options);\n}\n\nexport function axisX() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"x\", anchorX(options), data, options);\n}\n\nexport function axisFx() {\n  const [data, options] = maybeData(...arguments);\n  return axisKx(\"fx\", anchorFx(options), data, options);\n}\n\nfunction axisKy(\n  k,\n  anchor,\n  data,\n  {\n    color = \"currentColor\",\n    opacity = 1,\n    stroke = color,\n    strokeOpacity = opacity,\n    strokeWidth = 1,\n    fill = color,\n    fillOpacity = opacity,\n    textAnchor,\n    textStroke,\n    textStrokeOpacity,\n    textStrokeWidth,\n    tickSize = k === \"y\" ? 6 : 0,\n    tickPadding,\n    tickRotate,\n    x,\n    margin,\n    marginTop = margin === undefined ? 20 : margin,\n    marginRight = margin === undefined ? (anchor === \"right\" ? 40 : 0) : margin,\n    marginBottom = margin === undefined ? 20 : margin,\n    marginLeft = margin === undefined ? (anchor === \"left\" ? 40 : 0) : margin,\n    label,\n    labelAnchor,\n    labelArrow,\n    labelOffset,\n    ...options\n  }\n) {\n  tickSize = number(tickSize);\n  tickPadding = number(tickPadding);\n  tickRotate = number(tickRotate);\n  if (labelAnchor !== undefined) labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"top\", \"bottom\"]);\n  labelArrow = maybeLabelArrow(labelArrow);\n  return marks(\n    tickSize && !isNoneish(stroke)\n      ? axisTickKy(k, anchor, data, {\n          stroke,\n          strokeOpacity,\n          strokeWidth,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          x,\n          ...options\n        })\n      : null,\n    !isNoneish(fill)\n      ? axisTextKy(k, anchor, data, {\n          fill,\n          fillOpacity,\n          stroke: textStroke,\n          strokeOpacity: textStrokeOpacity,\n          strokeWidth: textStrokeWidth,\n          textAnchor,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          x,\n          marginTop,\n          marginRight,\n          marginBottom,\n          marginLeft,\n          ...options\n        })\n      : null,\n    !isNoneish(fill) && label !== null\n      ? text(\n          [],\n          labelOptions({fill, fillOpacity, ...options}, function (data, facets, channels, scales, dimensions) {\n            const scale = scales[k];\n            const {marginTop, marginRight, marginBottom, marginLeft} = (k === \"y\" && dimensions.inset) || dimensions;\n            const cla = labelAnchor ?? (scale.bandwidth ? \"center\" : \"top\");\n            const clo = labelOffset ?? (anchor === \"right\" ? marginRight : marginLeft) - 3;\n            if (cla === \"center\") {\n              this.textAnchor = undefined; // middle\n              this.lineAnchor = anchor === \"right\" ? \"bottom\" : \"top\";\n              this.frameAnchor = anchor;\n              this.rotate = -90;\n            } else {\n              this.textAnchor = anchor === \"right\" ? \"end\" : \"start\";\n              this.lineAnchor = cla;\n              this.frameAnchor = `${cla}-${anchor}`;\n              this.rotate = 0;\n            }\n            this.dy = cla === \"top\" ? 3 - marginTop : cla === \"bottom\" ? marginBottom - 3 : 0;\n            this.dx = anchor === \"right\" ? clo : -clo;\n            this.ariaLabel = `${k}-axis label`;\n            return {\n              facets: [[0]],\n              channels: {text: {value: [formatAxisLabel(k, scale, {anchor, label, labelAnchor: cla, labelArrow})]}}\n            };\n          })\n        )\n      : null\n  );\n}\n\nfunction axisKx(\n  k,\n  anchor,\n  data,\n  {\n    color = \"currentColor\",\n    opacity = 1,\n    stroke = color,\n    strokeOpacity = opacity,\n    strokeWidth = 1,\n    fill = color,\n    fillOpacity = opacity,\n    textAnchor,\n    textStroke,\n    textStrokeOpacity,\n    textStrokeWidth,\n    tickSize = k === \"x\" ? 6 : 0,\n    tickPadding,\n    tickRotate,\n    y,\n    margin,\n    marginTop = margin === undefined ? (anchor === \"top\" ? 30 : 0) : margin,\n    marginRight = margin === undefined ? 20 : margin,\n    marginBottom = margin === undefined ? (anchor === \"bottom\" ? 30 : 0) : margin,\n    marginLeft = margin === undefined ? 20 : margin,\n    label,\n    labelAnchor,\n    labelArrow,\n    labelOffset,\n    ...options\n  }\n) {\n  tickSize = number(tickSize);\n  tickPadding = number(tickPadding);\n  tickRotate = number(tickRotate);\n  if (labelAnchor !== undefined) labelAnchor = keyword(labelAnchor, \"labelAnchor\", [\"center\", \"left\", \"right\"]);\n  labelArrow = maybeLabelArrow(labelArrow);\n  return marks(\n    tickSize && !isNoneish(stroke)\n      ? axisTickKx(k, anchor, data, {\n          stroke,\n          strokeOpacity,\n          strokeWidth,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          y,\n          ...options\n        })\n      : null,\n    !isNoneish(fill)\n      ? axisTextKx(k, anchor, data, {\n          fill,\n          fillOpacity,\n          stroke: textStroke,\n          strokeOpacity: textStrokeOpacity,\n          strokeWidth: textStrokeWidth,\n          textAnchor,\n          tickSize,\n          tickPadding,\n          tickRotate,\n          y,\n          marginTop,\n          marginRight,\n          marginBottom,\n          marginLeft,\n          ...options\n        })\n      : null,\n    !isNoneish(fill) && label !== null\n      ? text(\n          [],\n          labelOptions({fill, fillOpacity, ...options}, function (data, facets, channels, scales, dimensions) {\n            const scale = scales[k];\n            const {marginTop, marginRight, marginBottom, marginLeft} = (k === \"x\" && dimensions.inset) || dimensions;\n            const cla = labelAnchor ?? (scale.bandwidth ? \"center\" : \"right\");\n            const clo = labelOffset ?? (anchor === \"top\" ? marginTop : marginBottom) - 3;\n            if (cla === \"center\") {\n              this.frameAnchor = anchor;\n              this.textAnchor = undefined; // middle\n            } else {\n              this.frameAnchor = `${anchor}-${cla}`;\n              this.textAnchor = cla === \"right\" ? \"end\" : \"start\";\n            }\n            this.lineAnchor = anchor;\n            this.dy = anchor === \"top\" ? -clo : clo;\n            this.dx = cla === \"right\" ? marginRight - 3 : cla === \"left\" ? 3 - marginLeft : 0;\n            this.ariaLabel = `${k}-axis label`;\n            return {\n              facets: [[0]],\n              channels: {text: {value: [formatAxisLabel(k, scale, {anchor, label, labelAnchor: cla, labelArrow})]}}\n            };\n          })\n        )\n      : null\n  );\n}\n\nfunction axisTickKy(\n  k,\n  anchor,\n  data,\n  {\n    strokeWidth = 1,\n    strokeLinecap = null,\n    strokeLinejoin = null,\n    facetAnchor = anchor + (k === \"y\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    inset = 0,\n    insetLeft = inset,\n    insetRight = inset,\n    dx = 0,\n    y = k === \"y\" ? undefined : null,\n    ...options\n  }\n) {\n  return axisMark(\n    vectorY,\n    k,\n    data,\n    {\n      ariaLabel: `${k}-axis tick`,\n      ariaHidden: true\n    },\n    {\n      strokeWidth,\n      strokeLinecap,\n      strokeLinejoin,\n      facetAnchor,\n      frameAnchor,\n      y,\n      ...options,\n      dx: anchor === \"left\" ? +dx - offset + +insetLeft : +dx + offset - insetRight,\n      anchor: \"start\",\n      length: tickSize,\n      shape: anchor === \"left\" ? shapeTickLeft : shapeTickRight\n    }\n  );\n}\n\nfunction axisTickKx(\n  k,\n  anchor,\n  data,\n  {\n    strokeWidth = 1,\n    strokeLinecap = null,\n    strokeLinejoin = null,\n    facetAnchor = anchor + (k === \"x\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    inset = 0,\n    insetTop = inset,\n    insetBottom = inset,\n    dy = 0,\n    x = k === \"x\" ? undefined : null,\n    ...options\n  }\n) {\n  return axisMark(\n    vectorX,\n    k,\n    data,\n    {\n      ariaLabel: `${k}-axis tick`,\n      ariaHidden: true\n    },\n    {\n      strokeWidth,\n      strokeLinejoin,\n      strokeLinecap,\n      facetAnchor,\n      frameAnchor,\n      x,\n      ...options,\n      dy: anchor === \"bottom\" ? +dy - offset - insetBottom : +dy + offset + +insetTop,\n      anchor: \"start\",\n      length: tickSize,\n      shape: anchor === \"bottom\" ? shapeTickBottom : shapeTickTop\n    }\n  );\n}\n\nfunction axisTextKy(\n  k,\n  anchor,\n  data,\n  {\n    facetAnchor = anchor + (k === \"y\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    tickRotate = 0,\n    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians) : 0),\n    text,\n    textAnchor = Math.abs(tickRotate) > 60 ? \"middle\" : anchor === \"left\" ? \"end\" : \"start\",\n    lineAnchor = tickRotate > 60 ? \"top\" : tickRotate < -60 ? \"bottom\" : \"middle\",\n    fontVariant,\n    inset = 0,\n    insetLeft = inset,\n    insetRight = inset,\n    dx = 0,\n    y = k === \"y\" ? undefined : null,\n    ...options\n  }\n) {\n  return axisMark(\n    textY,\n    k,\n    data,\n    {ariaLabel: `${k}-axis tick label`},\n    {\n      facetAnchor,\n      frameAnchor,\n      text,\n      textAnchor,\n      lineAnchor,\n      fontVariant,\n      rotate: tickRotate,\n      y,\n      ...options,\n      dx: anchor === \"left\" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight\n    },\n    function (scale, data, ticks, tickFormat, channels) {\n      if (fontVariant === undefined) this.fontVariant = inferFontVariant(scale);\n      if (text === undefined) channels.text = inferTextChannel(scale, data, ticks, tickFormat, anchor);\n    }\n  );\n}\n\nfunction axisTextKx(\n  k,\n  anchor,\n  data,\n  {\n    facetAnchor = anchor + (k === \"x\" ? \"-empty\" : \"\"),\n    frameAnchor = anchor,\n    tickSize,\n    tickRotate = 0,\n    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians) : 0),\n    text,\n    textAnchor = Math.abs(tickRotate) >= 10 ? ((tickRotate < 0) ^ (anchor === \"bottom\") ? \"start\" : \"end\") : \"middle\",\n    lineAnchor = Math.abs(tickRotate) >= 10 ? \"middle\" : anchor === \"bottom\" ? \"top\" : \"bottom\",\n    fontVariant,\n    inset = 0,\n    insetTop = inset,\n    insetBottom = inset,\n    dy = 0,\n    x = k === \"x\" ? undefined : null,\n    ...options\n  }\n) {\n  return axisMark(\n    textX,\n    k,\n    data,\n    {ariaLabel: `${k}-axis tick label`},\n    {\n      facetAnchor,\n      frameAnchor,\n      text: text === undefined ? null : text,\n      textAnchor,\n      lineAnchor,\n      fontVariant,\n      rotate: tickRotate,\n      x,\n      ...options,\n      dy: anchor === \"bottom\" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop\n    },\n    function (scale, data, ticks, tickFormat, channels) {\n      if (fontVariant === undefined) this.fontVariant = inferFontVariant(scale);\n      if (text === undefined) channels.text = inferTextChannel(scale, data, ticks, tickFormat, anchor);\n    }\n  );\n}\n\nexport function gridY() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"y\", anchorY(options), data, options);\n}\n\nexport function gridFy() {\n  const [data, options] = maybeData(...arguments);\n  return gridKy(\"fy\", anchorFy(options), data, options);\n}\n\nexport function gridX() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"x\", anchorX(options), data, options);\n}\n\nexport function gridFx() {\n  const [data, options] = maybeData(...arguments);\n  return gridKx(\"fx\", anchorFx(options), data, options);\n}\n\nfunction gridKy(\n  k,\n  anchor,\n  data,\n  {\n    y = k === \"y\" ? undefined : null,\n    x = null,\n    x1 = anchor === \"left\" ? x : null,\n    x2 = anchor === \"right\" ? x : null,\n    ...options\n  }\n) {\n  return axisMark(ruleY, k, data, {ariaLabel: `${k}-grid`, ariaHidden: true}, {y, x1, x2, ...gridDefaults(options)});\n}\n\nfunction gridKx(\n  k,\n  anchor,\n  data,\n  {\n    x = k === \"x\" ? undefined : null,\n    y = null,\n    y1 = anchor === \"top\" ? y : null,\n    y2 = anchor === \"bottom\" ? y : null,\n    ...options\n  }\n) {\n  return axisMark(ruleX, k, data, {ariaLabel: `${k}-grid`, ariaHidden: true}, {x, y1, y2, ...gridDefaults(options)});\n}\n\nfunction gridDefaults({\n  color = \"currentColor\",\n  opacity = 0.1,\n  stroke = color,\n  strokeOpacity = opacity,\n  strokeWidth = 1,\n  ...options\n}) {\n  return {stroke, strokeOpacity, strokeWidth, ...options};\n}\n\nfunction labelOptions(\n  {\n    fill,\n    fillOpacity,\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontVariant,\n    fontWeight,\n    monospace,\n    pointerEvents,\n    shapeRendering,\n    clip = false\n  },\n  initializer\n) {\n  // Only propagate these options if constant.\n  [, fill] = maybeColorChannel(fill);\n  [, fillOpacity] = maybeNumberChannel(fillOpacity);\n  return {\n    facet: \"super\",\n    x: null,\n    y: null,\n    fill,\n    fillOpacity,\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontVariant,\n    fontWeight,\n    monospace,\n    pointerEvents,\n    shapeRendering,\n    clip,\n    initializer\n  };\n}\n\nfunction axisMark(mark, k, data, properties, options, initialize) {\n  let channels;\n\n  function axisInitializer(data, facets, _channels, scales, dimensions, context) {\n    const initializeFacets = data == null && (k === \"fx\" || k === \"fy\");\n    const {[k]: scale} = scales;\n    if (!scale) throw new Error(`missing scale: ${k}`);\n    const domain = scale.domain();\n    let {interval, ticks, tickFormat, tickSpacing = k === \"x\" ? 80 : 35} = options;\n    // For a scale with a temporal domain, also allow the ticks to be specified\n    // as a string which is promoted to a time interval. In the case of ordinal\n    // scales, the interval is interpreted as UTC.\n    if (typeof ticks === \"string\" && hasTemporalDomain(scale)) (interval = ticks), (ticks = undefined);\n    // The interval axis option is an alternative method of specifying ticks;\n    // for example, for a numeric scale, ticks = 5 means “about 5 ticks” whereas\n    // interval = 5 means “ticks every 5 units”. (This is not to be confused\n    // with the interval scale option, which affects the scale’s behavior!)\n    // Lastly use the tickSpacing option to infer the desired tick count.\n    if (ticks === undefined) ticks = maybeRangeInterval(interval, scale.type) ?? inferTickCount(scale, tickSpacing);\n    if (data == null) {\n      if (isIterable(ticks)) {\n        // Use explicit ticks, if specified.\n        data = arrayify(ticks);\n      } else if (isInterval(ticks)) {\n        // Use the tick interval, if specified.\n        data = inclusiveRange(ticks, ...extent(domain));\n      } else if (scale.interval) {\n        // If the scale interval is a standard time interval such as \"day\", we\n        // may be able to generalize the scale interval it to a larger aligned\n        // time interval to create the desired number of ticks.\n        let interval = scale.interval;\n        if (scale.ticks) {\n          const [min, max] = extent(domain);\n          const n = (max - min) / interval[intervalDuration]; // current tick count\n          // We don’t explicitly check that given interval is a time interval;\n          // in that case the generalized interval will be undefined, just like\n          // a nonstandard interval. TODO Generalize integer intervals, too.\n          interval = generalizeTimeInterval(interval, n / ticks) ?? interval;\n          data = inclusiveRange(interval, min, max);\n        } else {\n          data = domain;\n          const n = data.length; // current tick count\n          interval = generalizeTimeInterval(interval, n / ticks) ?? interval;\n          if (interval !== scale.interval) data = inclusiveRange(interval, ...extent(data));\n        }\n        if (interval === scale.interval) {\n          // If we weren’t able to generalize the scale’s interval, compute the\n          // positive number n such that taking every nth value from the scale’s\n          // domain produces as close as possible to the desired number of\n          // ticks. For example, if the domain has 100 values and 5 ticks are\n          // desired, n = 20.\n          const n = Math.round(data.length / ticks);\n          if (n > 1) data = data.filter((d, i) => i % n === 0);\n        }\n      } else if (scale.ticks) {\n        data = scale.ticks(ticks);\n      } else {\n        // For ordinal scales, the domain will already be generated using the\n        // scale’s interval, if any.\n        data = domain;\n      }\n      if (!scale.ticks && data.length && data !== domain) {\n        // For ordinal scales, intersect the ticks with the scale domain since\n        // the scale is only defined on its domain. If all of the ticks are\n        // removed, then warn that the ticks and scale domain may be misaligned\n        // (e.g., \"year\" ticks and \"4 weeks\" interval).\n        const domainSet = new InternSet(domain);\n        data = data.filter((d) => domainSet.has(d));\n        if (!data.length) warn(`Warning: the ${k}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`); // prettier-ignore\n      }\n      if (k === \"y\" || k === \"x\") {\n        facets = [range(data)];\n      } else {\n        channels[k] = {scale: k, value: identity};\n      }\n    }\n    initialize?.call(this, scale, data, ticks, tickFormat, channels);\n    const initializedChannels = Object.fromEntries(\n      Object.entries(channels).map(([name, channel]) => {\n        return [name, {...channel, value: valueof(data, channel.value)}];\n      })\n    );\n    if (initializeFacets) facets = context.filterFacets(data, initializedChannels);\n    return {data, facets, channels: initializedChannels};\n  }\n\n  // Apply any basic initializers after the axis initializer computes the ticks.\n  const basicInitializer = initializer(options).initializer;\n  const m = mark(data, initializer({...options, initializer: axisInitializer}, basicInitializer));\n  if (data == null) {\n    channels = m.channels;\n    m.channels = {};\n  } else {\n    channels = {};\n  }\n  if (properties !== undefined) Object.assign(m, properties);\n  if (m.clip === undefined) m.clip = false; // don’t clip axes by default\n  return m;\n}\n\nfunction inferTickCount(scale, tickSpacing) {\n  const [min, max] = extent(scale.range());\n  return (max - min) / tickSpacing;\n}\n\nfunction inferTextChannel(scale, data, ticks, tickFormat, anchor) {\n  return {value: inferTickFormat(scale, data, ticks, tickFormat, anchor)};\n}\n\n// D3’s ordinal scales simply use toString by default, but if the ordinal scale\n// domain (or ticks) are numbers or dates (say because we’re applying a time\n// interval to the ordinal scale), we want Plot’s default formatter. And for\n// time ticks, we want to use the multi-line time format (e.g., Jan 26) if\n// possible, or the default ISO format (2014-01-26). TODO We need a better way\n// to infer whether the ordinal scale is UTC or local time.\nexport function inferTickFormat(scale, data, ticks, tickFormat, anchor) {\n  return typeof tickFormat === \"function\" && !(scale.type === \"log\" && scale.tickFormat)\n    ? tickFormat\n    : tickFormat === undefined && data && isTemporal(data)\n    ? inferTimeFormat(scale.type, data, anchor) ?? formatDefault\n    : scale.tickFormat\n    ? scale.tickFormat(typeof ticks === \"number\" ? ticks : null, tickFormat)\n    : tickFormat === undefined\n    ? formatDefault\n    : typeof tickFormat === \"string\"\n    ? (isTemporal(scale.domain()) ? utcFormat : format)(tickFormat)\n    : constant(tickFormat);\n}\n\nfunction inclusiveRange(interval, min, max) {\n  return interval.range(min, interval.offset(interval.floor(max)));\n}\n\nconst shapeTickBottom = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, l);\n  }\n};\n\nconst shapeTickTop = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(0, -l);\n  }\n};\n\nconst shapeTickLeft = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(-l, 0);\n  }\n};\n\nconst shapeTickRight = {\n  draw(context, l) {\n    context.moveTo(0, 0);\n    context.lineTo(l, 0);\n  }\n};\n\n// TODO Unify this with the other inferFontVariant; here we only have a scale\n// function rather than a scale descriptor.\nfunction inferFontVariant(scale) {\n  return scale.bandwidth && !scale.interval ? undefined : \"tabular-nums\";\n}\n\n// Takes the scale label, and if this is not an ordinal scale and the label was\n// inferred from an associated channel, adds an orientation-appropriate arrow.\nfunction formatAxisLabel(k, scale, {anchor, label = scale.label, labelAnchor, labelArrow} = {}) {\n  if (label == null || (label.inferred && hasTemporalDomain(scale) && /^(date|time|year)$/i.test(label))) return;\n  label = String(label); // coerce to a string after checking if inferred\n  if (labelArrow === \"auto\") labelArrow = (!scale.bandwidth || scale.interval) && !/[↑↓→←]/.test(label);\n  if (!labelArrow) return label;\n  if (labelArrow === true) {\n    const order = inferScaleOrder(scale);\n    if (order)\n      labelArrow =\n        /x$/.test(k) || labelAnchor === \"center\"\n          ? /x$/.test(k) === order < 0\n            ? \"left\"\n            : \"right\"\n          : order < 0\n          ? \"up\"\n          : \"down\";\n  }\n  switch (labelArrow) {\n    case \"left\":\n      return `← ${label}`;\n    case \"right\":\n      return `${label} →`;\n    case \"up\":\n      return anchor === \"right\" ? `${label} ↑` : `↑ ${label}`;\n    case \"down\":\n      return anchor === \"right\" ? `${label} ↓` : `↓ ${label}`;\n  }\n  return label;\n}\n\nfunction maybeLabelArrow(labelArrow = \"auto\") {\n  return isNoneish(labelArrow)\n    ? false\n    : typeof labelArrow === \"boolean\"\n    ? labelArrow\n    : keyword(labelArrow, \"labelArrow\", [\"auto\", \"up\", \"right\", \"down\", \"left\"]);\n}\n\nfunction hasTemporalDomain(scale) {\n  return isTemporal(scale.domain());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}