{"ast":null,"code":"import { isOrdinal, isTemporal, isTemporalString, isNumericString, isScaleOptions, map, slice, coerceNumbers, coerceDates } from \"./options.js\";\nimport { orderof } from \"./order.js\";\nimport { registry, color, position, radius, opacity, symbol, length } from \"./scales/index.js\";\nimport { createScaleLinear, createScaleSqrt, createScalePow, createScaleLog, createScaleSymlog, createScaleQuantile, createScaleQuantize, createScaleThreshold, createScaleIdentity } from \"./scales/quantitative.js\";\nimport { createScaleDiverging, createScaleDivergingSqrt, createScaleDivergingPow, createScaleDivergingLog, createScaleDivergingSymlog } from \"./scales/diverging.js\";\nimport { isCategoricalScheme, isDivergingScheme } from \"./scales/schemes.js\";\nimport { createScaleTime, createScaleUtc } from \"./scales/temporal.js\";\nimport { createScaleOrdinal, createScalePoint, createScaleBand, ordinalImplicit } from \"./scales/ordinal.js\";\nimport { maybeSymbol } from \"./symbol.js\";\nimport { warn } from \"./warnings.js\";\nexport function createScales(channelsByScale, {\n  label: globalLabel,\n  inset: globalInset = 0,\n  insetTop: globalInsetTop = globalInset,\n  insetRight: globalInsetRight = globalInset,\n  insetBottom: globalInsetBottom = globalInset,\n  insetLeft: globalInsetLeft = globalInset,\n  round,\n  nice,\n  clamp,\n  zero,\n  align,\n  padding,\n  projection,\n  facet: {\n    label: facetLabel = globalLabel\n  } = {},\n  ...options\n} = {}) {\n  const scales = {};\n  for (const [key, channels] of channelsByScale) {\n    const scaleOptions = options[key];\n    const scale = createScale(key, channels, {\n      round: registry.get(key) === position ? round : undefined,\n      // only for position\n      nice,\n      clamp,\n      zero,\n      align,\n      padding,\n      projection,\n      ...scaleOptions\n    });\n    if (scale) {\n      // populate generic scale options (percent, transform, insets)\n      let {\n        label = key === \"fx\" || key === \"fy\" ? facetLabel : globalLabel,\n        percent,\n        transform,\n        inset,\n        insetTop = inset !== undefined ? inset : key === \"y\" ? globalInsetTop : 0,\n        // not fy\n        insetRight = inset !== undefined ? inset : key === \"x\" ? globalInsetRight : 0,\n        // not fx\n        insetBottom = inset !== undefined ? inset : key === \"y\" ? globalInsetBottom : 0,\n        // not fy\n        insetLeft = inset !== undefined ? inset : key === \"x\" ? globalInsetLeft : 0 // not fx\n      } = scaleOptions || {};\n      if (transform == null) transform = undefined;else if (typeof transform !== \"function\") throw new Error(\"invalid scale transform; not a function\");\n      scale.percent = !!percent;\n      scale.label = label === undefined ? inferScaleLabel(channels, scale) : label;\n      scale.transform = transform;\n      if (key === \"x\" || key === \"fx\") {\n        scale.insetLeft = +insetLeft;\n        scale.insetRight = +insetRight;\n      } else if (key === \"y\" || key === \"fy\") {\n        scale.insetTop = +insetTop;\n        scale.insetBottom = +insetBottom;\n      }\n      scales[key] = scale;\n    }\n  }\n  return scales;\n}\nexport function createScaleFunctions(descriptors) {\n  const scales = {};\n  const scaleFunctions = {\n    scales\n  };\n  for (const [key, descriptor] of Object.entries(descriptors)) {\n    const {\n      scale,\n      type,\n      interval,\n      label\n    } = descriptor;\n    scales[key] = exposeScale(descriptor);\n    scaleFunctions[key] = scale;\n    // TODO: pass these properties, which are needed for axes, in the descriptor.\n    scale.type = type;\n    if (interval != null) scale.interval = interval;\n    if (label != null) scale.label = label;\n  }\n  return scaleFunctions;\n}\n\n// Mutates scale.range!\nexport function autoScaleRange(scales, dimensions) {\n  const {\n    x,\n    y,\n    fx,\n    fy\n  } = scales;\n  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;\n  if (fx) autoScaleRangeX(fx, superdimensions);\n  if (fy) autoScaleRangeY(fy, superdimensions);\n  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;\n  if (x) autoScaleRangeX(x, subdimensions);\n  if (y) autoScaleRangeY(y, subdimensions);\n}\n\n// Channels can have labels; if all the channels for a given scale are\n// consistently labeled (i.e., have the same value if not undefined), and the\n// corresponding scale doesn’t already have an explicit label, then the\n// channels’ label is promoted to the scale. This inferred label should have an\n// orientation-appropriate arrow added when used as an axis, but we don’t want\n// to add the arrow when the label is set explicitly as an option; so, the\n// inferred label is distinguished as an object with an “inferred” property.\nfunction inferScaleLabel(channels = [], scale) {\n  let label;\n  for (const {\n    label: l\n  } of channels) {\n    if (l === undefined) continue;\n    if (label === undefined) label = l;else if (label !== l) return;\n  }\n  if (label === undefined) return;\n  if (!isOrdinalScale(scale) && scale.percent) label = `${label} (%)`;\n  return {\n    inferred: true,\n    toString: () => label\n  };\n}\n\n// Determines whether the scale points in the “positive” (right or down) or\n// “negative” (left or up) direction; if the scale order cannot be determined,\n// returns NaN; used to assign an appropriate label arrow.\nexport function inferScaleOrder(scale) {\n  return Math.sign(orderof(scale.domain())) * Math.sign(orderof(scale.range()));\n}\n\n// Returns the dimensions of the outer frame; this is subdivided into facets\n// with the margins of each facet collapsing into the outer margins.\nexport function outerDimensions(dimensions) {\n  const {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width,\n    height,\n    facet: {\n      marginTop: facetMarginTop,\n      marginRight: facetMarginRight,\n      marginBottom: facetMarginBottom,\n      marginLeft: facetMarginLeft\n    }\n  } = dimensions;\n  return {\n    marginTop: Math.max(marginTop, facetMarginTop),\n    marginRight: Math.max(marginRight, facetMarginRight),\n    marginBottom: Math.max(marginBottom, facetMarginBottom),\n    marginLeft: Math.max(marginLeft, facetMarginLeft),\n    width,\n    height\n  };\n}\n\n// Returns the dimensions of each facet.\nexport function innerDimensions({\n  fx,\n  fy\n}, dimensions) {\n  const {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width,\n    height\n  } = outerDimensions(dimensions);\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,\n    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,\n    facet: {\n      width,\n      height\n    }\n  };\n}\nfunction autoScaleRangeX(scale, dimensions) {\n  if (scale.range === undefined) {\n    const {\n      insetLeft,\n      insetRight\n    } = scale;\n    const {\n      width,\n      marginLeft = 0,\n      marginRight = 0\n    } = dimensions;\n    const left = marginLeft + insetLeft;\n    const right = width - marginRight - insetRight;\n    scale.range = [left, Math.max(left, right)];\n    if (!isOrdinalScale(scale)) scale.range = piecewiseRange(scale);\n    scale.scale.range(scale.range);\n  }\n  autoScaleRound(scale);\n}\nfunction autoScaleRangeY(scale, dimensions) {\n  if (scale.range === undefined) {\n    const {\n      insetTop,\n      insetBottom\n    } = scale;\n    const {\n      height,\n      marginTop = 0,\n      marginBottom = 0\n    } = dimensions;\n    const top = marginTop + insetTop;\n    const bottom = height - marginBottom - insetBottom;\n    scale.range = [Math.max(top, bottom), top];\n    if (!isOrdinalScale(scale)) scale.range = piecewiseRange(scale);else scale.range.reverse();\n    scale.scale.range(scale.range);\n  }\n  autoScaleRound(scale);\n}\nfunction autoScaleRound(scale) {\n  if (scale.round === undefined && isBandScale(scale) && roundError(scale) <= 30) {\n    scale.scale.round(true);\n  }\n}\n\n// If we were to turn on rounding for this band or point scale, how much wasted\n// space would it introduce (on both ends of the range)? This must match\n// d3.scaleBand’s rounding behavior:\n// https://github.com/d3/d3-scale/blob/83555bd759c7314420bd4240642beda5e258db9e/src/band.js#L20-L32\nfunction roundError({\n  scale\n}) {\n  const n = scale.domain().length;\n  const [start, stop] = scale.range();\n  const paddingInner = scale.paddingInner ? scale.paddingInner() : 1;\n  const paddingOuter = scale.paddingOuter ? scale.paddingOuter() : scale.padding();\n  const m = n - paddingInner;\n  const step = Math.abs(stop - start) / Math.max(1, m + paddingOuter * 2);\n  return (step - Math.floor(step)) * m;\n}\nfunction piecewiseRange(scale) {\n  const length = scale.scale.domain().length + isThresholdScale(scale);\n  if (!(length > 2)) return scale.range;\n  const [start, end] = scale.range;\n  return Array.from({\n    length\n  }, (_, i) => start + i / (length - 1) * (end - start));\n}\nexport function normalizeScale(key, scale, hint) {\n  return createScale(key, hint === undefined ? undefined : [{\n    hint\n  }], {\n    ...scale\n  });\n}\nfunction createScale(key, channels = [], options = {}) {\n  const type = inferScaleType(key, channels, options);\n\n  // Warn for common misuses of implicit ordinal scales. We disable this test if\n  // you specify a scale interval or if you set the domain or range explicitly,\n  // since setting the domain or range (typically with a cardinality of more than\n  // two) is another indication that you intended for the scale to be ordinal; we\n  // also disable it for facet scales since these are always band scales.\n  if (options.type === undefined && options.domain === undefined && options.range === undefined && options.interval == null && key !== \"fx\" && key !== \"fy\" && isOrdinalScale({\n    type\n  })) {\n    const values = channels.map(({\n      value\n    }) => value).filter(value => value !== undefined);\n    if (values.some(isTemporal)) warn(`Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type)}\".`);else if (values.some(isTemporalString)) warn(`Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(type)}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type)}\".`);else if (values.some(isNumericString)) warn(`Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a \"linear\" scale rather than a \"${formatScaleType(type)}\" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(type)}\".`);\n  }\n  options.type = type; // Mutates input!\n\n  // Once the scale type is known, coerce the associated channel values and any\n  // explicitly-specified domain to the expected type.\n  switch (type) {\n    case \"diverging\":\n    case \"diverging-sqrt\":\n    case \"diverging-pow\":\n    case \"diverging-log\":\n    case \"diverging-symlog\":\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n    case \"sqrt\":\n    case \"threshold\":\n    case \"quantile\":\n    case \"pow\":\n    case \"log\":\n    case \"symlog\":\n      options = coerceType(channels, options, coerceNumbers);\n      break;\n    case \"identity\":\n      switch (registry.get(key)) {\n        case position:\n          options = coerceType(channels, options, coerceNumbers);\n          break;\n        case symbol:\n          options = coerceType(channels, options, coerceSymbols);\n          break;\n      }\n      break;\n    case \"utc\":\n    case \"time\":\n      options = coerceType(channels, options, coerceDates);\n      break;\n  }\n  switch (type) {\n    case \"diverging\":\n      return createScaleDiverging(key, channels, options);\n    case \"diverging-sqrt\":\n      return createScaleDivergingSqrt(key, channels, options);\n    case \"diverging-pow\":\n      return createScaleDivergingPow(key, channels, options);\n    case \"diverging-log\":\n      return createScaleDivergingLog(key, channels, options);\n    case \"diverging-symlog\":\n      return createScaleDivergingSymlog(key, channels, options);\n    case \"categorical\":\n    case \"ordinal\":\n    case ordinalImplicit:\n      return createScaleOrdinal(key, channels, options);\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n      return createScaleLinear(key, channels, options);\n    case \"sqrt\":\n      return createScaleSqrt(key, channels, options);\n    case \"threshold\":\n      return createScaleThreshold(key, channels, options);\n    case \"quantile\":\n      return createScaleQuantile(key, channels, options);\n    case \"quantize\":\n      return createScaleQuantize(key, channels, options);\n    case \"pow\":\n      return createScalePow(key, channels, options);\n    case \"log\":\n      return createScaleLog(key, channels, options);\n    case \"symlog\":\n      return createScaleSymlog(key, channels, options);\n    case \"utc\":\n      return createScaleUtc(key, channels, options);\n    case \"time\":\n      return createScaleTime(key, channels, options);\n    case \"point\":\n      return createScalePoint(key, channels, options);\n    case \"band\":\n      return createScaleBand(key, channels, options);\n    case \"identity\":\n      return createScaleIdentity(key);\n    case undefined:\n      return;\n    default:\n      throw new Error(`unknown scale type: ${type}`);\n  }\n}\nfunction formatScaleType(type) {\n  return typeof type === \"symbol\" ? type.description : type;\n}\nfunction maybeScaleType(type) {\n  return typeof type === \"string\" ? `${type}`.toLowerCase() : type;\n}\n\n// A special type symbol when the x and y scales are replaced with a projection.\nconst typeProjection = {\n  toString: () => \"projection\"\n};\nfunction inferScaleType(key, channels, {\n  type,\n  domain,\n  range,\n  scheme,\n  pivot,\n  projection\n}) {\n  type = maybeScaleType(type);\n\n  // The facet scales are always band scales; this cannot be changed.\n  if (key === \"fx\" || key === \"fy\") return \"band\";\n\n  // If a projection is specified, the x- and y-scales are disabled; these\n  // channels will be projected rather than scaled. (But still check that none\n  // of the associated channels are incompatible with a projection.)\n  if ((key === \"x\" || key === \"y\") && projection != null) type = typeProjection;\n\n  // If a channel dictates a scale type, make sure that it is consistent with\n  // the user-specified scale type (if any) and all other channels. For example,\n  // barY requires x to be a band scale and disallows any other scale type.\n  for (const channel of channels) {\n    const t = maybeScaleType(channel.type);\n    if (t === undefined) continue;else if (type === undefined) type = t;else if (type !== t) throw new Error(`scale incompatible with channel: ${type} !== ${t}`);\n  }\n\n  // If the scale, a channel, or user specified a (consistent) type, return it.\n  if (type === typeProjection) return;\n  if (type !== undefined) return type;\n\n  // If there’s no data (and no type) associated with this scale, don’t create a scale.\n  if (domain === undefined && !channels.some(({\n    value\n  }) => value !== undefined)) return;\n\n  // Some scales have default types.\n  const kind = registry.get(key);\n  if (kind === radius) return \"sqrt\";\n  if (kind === opacity || kind === length) return \"linear\";\n  if (kind === symbol) return \"ordinal\";\n\n  // If the domain or range has more than two values, assume it’s ordinal. You\n  // can still use a “piecewise” (or “polylinear”) scale, but you must set the\n  // type explicitly.\n  if ((domain || range || []).length > 2) return asOrdinalType(kind);\n\n  // Otherwise, infer the scale type from the data! Prefer the domain, if\n  // present, over channels. (The domain and channels should be consistently\n  // typed, and the domain is more explicit and typically much smaller.) We only\n  // check the first defined value for expedience and simplicity; we expect\n  // that the types are consistent.\n  if (domain !== undefined) {\n    if (isOrdinal(domain)) return asOrdinalType(kind);\n    if (isTemporal(domain)) return \"utc\";\n  } else {\n    const values = channels.map(({\n      value\n    }) => value).filter(value => value !== undefined);\n    if (values.some(isOrdinal)) return asOrdinalType(kind);\n    if (values.some(isTemporal)) return \"utc\";\n  }\n\n  // For color scales, take a hint from the color scheme and pivot option.\n  if (kind === color) {\n    if (pivot != null || isDivergingScheme(scheme)) return \"diverging\";\n    if (isCategoricalScheme(scheme)) return \"categorical\";\n  }\n  return \"linear\";\n}\n\n// Positional scales default to a point scale instead of an ordinal scale.\nfunction asOrdinalType(kind) {\n  switch (kind) {\n    case position:\n      return \"point\";\n    case color:\n      return ordinalImplicit;\n    default:\n      return \"ordinal\";\n  }\n}\nexport function isTemporalScale({\n  type\n}) {\n  return type === \"time\" || type === \"utc\";\n}\nexport function isOrdinalScale({\n  type\n}) {\n  return type === \"ordinal\" || type === \"point\" || type === \"band\" || type === ordinalImplicit;\n}\nexport function isThresholdScale({\n  type\n}) {\n  return type === \"threshold\";\n}\nfunction isBandScale({\n  type\n}) {\n  return type === \"point\" || type === \"band\";\n}\nexport function isDivergingScale({\n  type\n}) {\n  return /^diverging($|-)/.test(type);\n}\n\n// Certain marks have special behavior if a scale is collapsed, i.e. if the\n// domain is degenerate and represents only a single value such as [3, 3]; for\n// example, a rect will span the full extent of the chart along a collapsed\n// dimension (whereas a dot will simply be drawn in the center).\nexport function isCollapsed(scale) {\n  if (scale === undefined) return true; // treat missing scale as collapsed\n  const domain = scale.domain();\n  const value = scale(domain[0]);\n  for (let i = 1, n = domain.length; i < n; ++i) {\n    if (scale(domain[i]) - value) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Mutates channel.value!\nfunction coerceType(channels, {\n  domain,\n  ...options\n}, coerceValues) {\n  for (const c of channels) {\n    if (c.value !== undefined) {\n      if (domain === undefined) domain = c.value?.domain; // promote channel domain\n      c.value = coerceValues(c.value);\n    }\n  }\n  return {\n    domain: domain === undefined ? domain : coerceValues(domain),\n    ...options\n  };\n}\nfunction coerceSymbols(values) {\n  return map(values, maybeSymbol);\n}\nexport function scale(options = {}) {\n  let scale;\n  for (const key in options) {\n    if (!registry.has(key)) continue; // ignore unknown properties\n    if (!isScaleOptions(options[key])) continue; // e.g., ignore {color: \"red\"}\n    if (scale !== undefined) throw new Error(\"ambiguous scale definition; multiple scales found\");\n    scale = exposeScale(normalizeScale(key, options[key]));\n  }\n  if (scale === undefined) throw new Error(\"invalid scale definition; no scale found\");\n  return scale;\n}\nexport function exposeScales(scales) {\n  return key => {\n    if (!registry.has(key = `${key}`)) throw new Error(`unknown scale: ${key}`);\n    return scales[key];\n  };\n}\n\n// Note: axis- and legend-related properties (such as label, ticks and\n// tickFormat) are not included here as they do not affect the scale’s behavior.\nfunction exposeScale({\n  scale,\n  type,\n  domain,\n  range,\n  interpolate,\n  interval,\n  transform,\n  percent,\n  pivot\n}) {\n  if (type === \"identity\") return {\n    type: \"identity\",\n    apply: d => d,\n    invert: d => d\n  };\n  const unknown = scale.unknown ? scale.unknown() : undefined;\n  return {\n    type,\n    domain: slice(domain),\n    // defensive copy\n    ...(range !== undefined && {\n      range: slice(range)\n    }),\n    // defensive copy\n    ...(transform !== undefined && {\n      transform\n    }),\n    ...(percent && {\n      percent\n    }),\n    // only exposed if truthy\n    ...(unknown !== undefined && {\n      unknown\n    }),\n    ...(interval !== undefined && {\n      interval\n    }),\n    // quantitative\n    ...(interpolate !== undefined && {\n      interpolate\n    }),\n    ...(scale.clamp && {\n      clamp: scale.clamp()\n    }),\n    // diverging (always asymmetric; we never want to apply the symmetric transform twice)\n    ...(pivot !== undefined && {\n      pivot,\n      symmetric: false\n    }),\n    // log, diverging-log\n    ...(scale.base && {\n      base: scale.base()\n    }),\n    // pow, diverging-pow\n    ...(scale.exponent && {\n      exponent: scale.exponent()\n    }),\n    // symlog, diverging-symlog\n    ...(scale.constant && {\n      constant: scale.constant()\n    }),\n    // band, point\n    ...(scale.align && {\n      align: scale.align(),\n      round: scale.round()\n    }),\n    ...(scale.padding && (scale.paddingInner ? {\n      paddingInner: scale.paddingInner(),\n      paddingOuter: scale.paddingOuter()\n    } : {\n      padding: scale.padding()\n    })),\n    ...(scale.bandwidth && {\n      bandwidth: scale.bandwidth(),\n      step: scale.step()\n    }),\n    // utilities\n    apply: t => scale(t),\n    ...(scale.invert && {\n      invert: t => scale.invert(t)\n    })\n  };\n}","map":{"version":3,"names":["isOrdinal","isTemporal","isTemporalString","isNumericString","isScaleOptions","map","slice","coerceNumbers","coerceDates","orderof","registry","color","position","radius","opacity","symbol","length","createScaleLinear","createScaleSqrt","createScalePow","createScaleLog","createScaleSymlog","createScaleQuantile","createScaleQuantize","createScaleThreshold","createScaleIdentity","createScaleDiverging","createScaleDivergingSqrt","createScaleDivergingPow","createScaleDivergingLog","createScaleDivergingSymlog","isCategoricalScheme","isDivergingScheme","createScaleTime","createScaleUtc","createScaleOrdinal","createScalePoint","createScaleBand","ordinalImplicit","maybeSymbol","warn","createScales","channelsByScale","label","globalLabel","inset","globalInset","insetTop","globalInsetTop","insetRight","globalInsetRight","insetBottom","globalInsetBottom","insetLeft","globalInsetLeft","round","nice","clamp","zero","align","padding","projection","facet","facetLabel","options","scales","key","channels","scaleOptions","scale","createScale","get","undefined","percent","transform","Error","inferScaleLabel","createScaleFunctions","descriptors","scaleFunctions","descriptor","Object","entries","type","interval","exposeScale","autoScaleRange","dimensions","x","y","fx","fy","superdimensions","outerDimensions","autoScaleRangeX","autoScaleRangeY","subdimensions","innerDimensions","l","isOrdinalScale","inferred","toString","inferScaleOrder","Math","sign","domain","range","marginTop","marginRight","marginBottom","marginLeft","width","height","facetMarginTop","facetMarginRight","facetMarginBottom","facetMarginLeft","max","bandwidth","left","right","piecewiseRange","autoScaleRound","top","bottom","reverse","isBandScale","roundError","n","start","stop","paddingInner","paddingOuter","m","step","abs","floor","isThresholdScale","end","Array","from","_","i","normalizeScale","hint","inferScaleType","values","value","filter","some","formatScaleType","coerceType","coerceSymbols","description","maybeScaleType","toLowerCase","typeProjection","scheme","pivot","channel","t","kind","asOrdinalType","isTemporalScale","isDivergingScale","test","isCollapsed","coerceValues","c","has","exposeScales","interpolate","apply","d","invert","unknown","symmetric","base","exponent","constant"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/scales.js"],"sourcesContent":["import {\n  isOrdinal,\n  isTemporal,\n  isTemporalString,\n  isNumericString,\n  isScaleOptions,\n  map,\n  slice,\n  coerceNumbers,\n  coerceDates\n} from \"./options.js\";\nimport {orderof} from \"./order.js\";\nimport {registry, color, position, radius, opacity, symbol, length} from \"./scales/index.js\";\nimport {\n  createScaleLinear,\n  createScaleSqrt,\n  createScalePow,\n  createScaleLog,\n  createScaleSymlog,\n  createScaleQuantile,\n  createScaleQuantize,\n  createScaleThreshold,\n  createScaleIdentity\n} from \"./scales/quantitative.js\";\nimport {\n  createScaleDiverging,\n  createScaleDivergingSqrt,\n  createScaleDivergingPow,\n  createScaleDivergingLog,\n  createScaleDivergingSymlog\n} from \"./scales/diverging.js\";\nimport {isCategoricalScheme, isDivergingScheme} from \"./scales/schemes.js\";\nimport {createScaleTime, createScaleUtc} from \"./scales/temporal.js\";\nimport {createScaleOrdinal, createScalePoint, createScaleBand, ordinalImplicit} from \"./scales/ordinal.js\";\nimport {maybeSymbol} from \"./symbol.js\";\nimport {warn} from \"./warnings.js\";\n\nexport function createScales(\n  channelsByScale,\n  {\n    label: globalLabel,\n    inset: globalInset = 0,\n    insetTop: globalInsetTop = globalInset,\n    insetRight: globalInsetRight = globalInset,\n    insetBottom: globalInsetBottom = globalInset,\n    insetLeft: globalInsetLeft = globalInset,\n    round,\n    nice,\n    clamp,\n    zero,\n    align,\n    padding,\n    projection,\n    facet: {label: facetLabel = globalLabel} = {},\n    ...options\n  } = {}\n) {\n  const scales = {};\n  for (const [key, channels] of channelsByScale) {\n    const scaleOptions = options[key];\n    const scale = createScale(key, channels, {\n      round: registry.get(key) === position ? round : undefined, // only for position\n      nice,\n      clamp,\n      zero,\n      align,\n      padding,\n      projection,\n      ...scaleOptions\n    });\n    if (scale) {\n      // populate generic scale options (percent, transform, insets)\n      let {\n        label = key === \"fx\" || key === \"fy\" ? facetLabel : globalLabel,\n        percent,\n        transform,\n        inset,\n        insetTop = inset !== undefined ? inset : key === \"y\" ? globalInsetTop : 0, // not fy\n        insetRight = inset !== undefined ? inset : key === \"x\" ? globalInsetRight : 0, // not fx\n        insetBottom = inset !== undefined ? inset : key === \"y\" ? globalInsetBottom : 0, // not fy\n        insetLeft = inset !== undefined ? inset : key === \"x\" ? globalInsetLeft : 0 // not fx\n      } = scaleOptions || {};\n      if (transform == null) transform = undefined;\n      else if (typeof transform !== \"function\") throw new Error(\"invalid scale transform; not a function\");\n      scale.percent = !!percent;\n      scale.label = label === undefined ? inferScaleLabel(channels, scale) : label;\n      scale.transform = transform;\n      if (key === \"x\" || key === \"fx\") {\n        scale.insetLeft = +insetLeft;\n        scale.insetRight = +insetRight;\n      } else if (key === \"y\" || key === \"fy\") {\n        scale.insetTop = +insetTop;\n        scale.insetBottom = +insetBottom;\n      }\n      scales[key] = scale;\n    }\n  }\n  return scales;\n}\n\nexport function createScaleFunctions(descriptors) {\n  const scales = {};\n  const scaleFunctions = {scales};\n  for (const [key, descriptor] of Object.entries(descriptors)) {\n    const {scale, type, interval, label} = descriptor;\n    scales[key] = exposeScale(descriptor);\n    scaleFunctions[key] = scale;\n    // TODO: pass these properties, which are needed for axes, in the descriptor.\n    scale.type = type;\n    if (interval != null) scale.interval = interval;\n    if (label != null) scale.label = label;\n  }\n  return scaleFunctions;\n}\n\n// Mutates scale.range!\nexport function autoScaleRange(scales, dimensions) {\n  const {x, y, fx, fy} = scales;\n  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;\n  if (fx) autoScaleRangeX(fx, superdimensions);\n  if (fy) autoScaleRangeY(fy, superdimensions);\n  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;\n  if (x) autoScaleRangeX(x, subdimensions);\n  if (y) autoScaleRangeY(y, subdimensions);\n}\n\n// Channels can have labels; if all the channels for a given scale are\n// consistently labeled (i.e., have the same value if not undefined), and the\n// corresponding scale doesn’t already have an explicit label, then the\n// channels’ label is promoted to the scale. This inferred label should have an\n// orientation-appropriate arrow added when used as an axis, but we don’t want\n// to add the arrow when the label is set explicitly as an option; so, the\n// inferred label is distinguished as an object with an “inferred” property.\nfunction inferScaleLabel(channels = [], scale) {\n  let label;\n  for (const {label: l} of channels) {\n    if (l === undefined) continue;\n    if (label === undefined) label = l;\n    else if (label !== l) return;\n  }\n  if (label === undefined) return;\n  if (!isOrdinalScale(scale) && scale.percent) label = `${label} (%)`;\n  return {inferred: true, toString: () => label};\n}\n\n// Determines whether the scale points in the “positive” (right or down) or\n// “negative” (left or up) direction; if the scale order cannot be determined,\n// returns NaN; used to assign an appropriate label arrow.\nexport function inferScaleOrder(scale) {\n  return Math.sign(orderof(scale.domain())) * Math.sign(orderof(scale.range()));\n}\n\n// Returns the dimensions of the outer frame; this is subdivided into facets\n// with the margins of each facet collapsing into the outer margins.\nexport function outerDimensions(dimensions) {\n  const {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width,\n    height,\n    facet: {\n      marginTop: facetMarginTop,\n      marginRight: facetMarginRight,\n      marginBottom: facetMarginBottom,\n      marginLeft: facetMarginLeft\n    }\n  } = dimensions;\n  return {\n    marginTop: Math.max(marginTop, facetMarginTop),\n    marginRight: Math.max(marginRight, facetMarginRight),\n    marginBottom: Math.max(marginBottom, facetMarginBottom),\n    marginLeft: Math.max(marginLeft, facetMarginLeft),\n    width,\n    height\n  };\n}\n\n// Returns the dimensions of each facet.\nexport function innerDimensions({fx, fy}, dimensions) {\n  const {marginTop, marginRight, marginBottom, marginLeft, width, height} = outerDimensions(dimensions);\n  return {\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,\n    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,\n    facet: {width, height}\n  };\n}\n\nfunction autoScaleRangeX(scale, dimensions) {\n  if (scale.range === undefined) {\n    const {insetLeft, insetRight} = scale;\n    const {width, marginLeft = 0, marginRight = 0} = dimensions;\n    const left = marginLeft + insetLeft;\n    const right = width - marginRight - insetRight;\n    scale.range = [left, Math.max(left, right)];\n    if (!isOrdinalScale(scale)) scale.range = piecewiseRange(scale);\n    scale.scale.range(scale.range);\n  }\n  autoScaleRound(scale);\n}\n\nfunction autoScaleRangeY(scale, dimensions) {\n  if (scale.range === undefined) {\n    const {insetTop, insetBottom} = scale;\n    const {height, marginTop = 0, marginBottom = 0} = dimensions;\n    const top = marginTop + insetTop;\n    const bottom = height - marginBottom - insetBottom;\n    scale.range = [Math.max(top, bottom), top];\n    if (!isOrdinalScale(scale)) scale.range = piecewiseRange(scale);\n    else scale.range.reverse();\n    scale.scale.range(scale.range);\n  }\n  autoScaleRound(scale);\n}\n\nfunction autoScaleRound(scale) {\n  if (scale.round === undefined && isBandScale(scale) && roundError(scale) <= 30) {\n    scale.scale.round(true);\n  }\n}\n\n// If we were to turn on rounding for this band or point scale, how much wasted\n// space would it introduce (on both ends of the range)? This must match\n// d3.scaleBand’s rounding behavior:\n// https://github.com/d3/d3-scale/blob/83555bd759c7314420bd4240642beda5e258db9e/src/band.js#L20-L32\nfunction roundError({scale}) {\n  const n = scale.domain().length;\n  const [start, stop] = scale.range();\n  const paddingInner = scale.paddingInner ? scale.paddingInner() : 1;\n  const paddingOuter = scale.paddingOuter ? scale.paddingOuter() : scale.padding();\n  const m = n - paddingInner;\n  const step = Math.abs(stop - start) / Math.max(1, m + paddingOuter * 2);\n  return (step - Math.floor(step)) * m;\n}\n\nfunction piecewiseRange(scale) {\n  const length = scale.scale.domain().length + isThresholdScale(scale);\n  if (!(length > 2)) return scale.range;\n  const [start, end] = scale.range;\n  return Array.from({length}, (_, i) => start + (i / (length - 1)) * (end - start));\n}\n\nexport function normalizeScale(key, scale, hint) {\n  return createScale(key, hint === undefined ? undefined : [{hint}], {...scale});\n}\n\nfunction createScale(key, channels = [], options = {}) {\n  const type = inferScaleType(key, channels, options);\n\n  // Warn for common misuses of implicit ordinal scales. We disable this test if\n  // you specify a scale interval or if you set the domain or range explicitly,\n  // since setting the domain or range (typically with a cardinality of more than\n  // two) is another indication that you intended for the scale to be ordinal; we\n  // also disable it for facet scales since these are always band scales.\n  if (\n    options.type === undefined &&\n    options.domain === undefined &&\n    options.range === undefined &&\n    options.interval == null &&\n    key !== \"fx\" &&\n    key !== \"fy\" &&\n    isOrdinalScale({type})\n  ) {\n    const values = channels.map(({value}) => value).filter((value) => value !== undefined);\n    if (values.some(isTemporal))\n      warn(\n        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(\n          type\n        )}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(\n          type\n        )}\".`\n      );\n    else if (values.some(isTemporalString))\n      warn(\n        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a \"utc\" or \"time\" scale rather than a \"${formatScaleType(\n          type\n        )}\" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(\n          type\n        )}\".`\n      );\n    else if (values.some(isNumericString))\n      warn(\n        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a \"linear\" scale rather than a \"${formatScaleType(\n          type\n        )}\" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to \"${formatScaleType(\n          type\n        )}\".`\n      );\n  }\n\n  options.type = type; // Mutates input!\n\n  // Once the scale type is known, coerce the associated channel values and any\n  // explicitly-specified domain to the expected type.\n  switch (type) {\n    case \"diverging\":\n    case \"diverging-sqrt\":\n    case \"diverging-pow\":\n    case \"diverging-log\":\n    case \"diverging-symlog\":\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n    case \"sqrt\":\n    case \"threshold\":\n    case \"quantile\":\n    case \"pow\":\n    case \"log\":\n    case \"symlog\":\n      options = coerceType(channels, options, coerceNumbers);\n      break;\n    case \"identity\":\n      switch (registry.get(key)) {\n        case position:\n          options = coerceType(channels, options, coerceNumbers);\n          break;\n        case symbol:\n          options = coerceType(channels, options, coerceSymbols);\n          break;\n      }\n      break;\n    case \"utc\":\n    case \"time\":\n      options = coerceType(channels, options, coerceDates);\n      break;\n  }\n\n  switch (type) {\n    case \"diverging\":\n      return createScaleDiverging(key, channels, options);\n    case \"diverging-sqrt\":\n      return createScaleDivergingSqrt(key, channels, options);\n    case \"diverging-pow\":\n      return createScaleDivergingPow(key, channels, options);\n    case \"diverging-log\":\n      return createScaleDivergingLog(key, channels, options);\n    case \"diverging-symlog\":\n      return createScaleDivergingSymlog(key, channels, options);\n    case \"categorical\":\n    case \"ordinal\":\n    case ordinalImplicit:\n      return createScaleOrdinal(key, channels, options);\n    case \"cyclical\":\n    case \"sequential\":\n    case \"linear\":\n      return createScaleLinear(key, channels, options);\n    case \"sqrt\":\n      return createScaleSqrt(key, channels, options);\n    case \"threshold\":\n      return createScaleThreshold(key, channels, options);\n    case \"quantile\":\n      return createScaleQuantile(key, channels, options);\n    case \"quantize\":\n      return createScaleQuantize(key, channels, options);\n    case \"pow\":\n      return createScalePow(key, channels, options);\n    case \"log\":\n      return createScaleLog(key, channels, options);\n    case \"symlog\":\n      return createScaleSymlog(key, channels, options);\n    case \"utc\":\n      return createScaleUtc(key, channels, options);\n    case \"time\":\n      return createScaleTime(key, channels, options);\n    case \"point\":\n      return createScalePoint(key, channels, options);\n    case \"band\":\n      return createScaleBand(key, channels, options);\n    case \"identity\":\n      return createScaleIdentity(key);\n    case undefined:\n      return;\n    default:\n      throw new Error(`unknown scale type: ${type}`);\n  }\n}\n\nfunction formatScaleType(type) {\n  return typeof type === \"symbol\" ? type.description : type;\n}\n\nfunction maybeScaleType(type) {\n  return typeof type === \"string\" ? `${type}`.toLowerCase() : type;\n}\n\n// A special type symbol when the x and y scales are replaced with a projection.\nconst typeProjection = {toString: () => \"projection\"};\n\nfunction inferScaleType(key, channels, {type, domain, range, scheme, pivot, projection}) {\n  type = maybeScaleType(type);\n\n  // The facet scales are always band scales; this cannot be changed.\n  if (key === \"fx\" || key === \"fy\") return \"band\";\n\n  // If a projection is specified, the x- and y-scales are disabled; these\n  // channels will be projected rather than scaled. (But still check that none\n  // of the associated channels are incompatible with a projection.)\n  if ((key === \"x\" || key === \"y\") && projection != null) type = typeProjection;\n\n  // If a channel dictates a scale type, make sure that it is consistent with\n  // the user-specified scale type (if any) and all other channels. For example,\n  // barY requires x to be a band scale and disallows any other scale type.\n  for (const channel of channels) {\n    const t = maybeScaleType(channel.type);\n    if (t === undefined) continue;\n    else if (type === undefined) type = t;\n    else if (type !== t) throw new Error(`scale incompatible with channel: ${type} !== ${t}`);\n  }\n\n  // If the scale, a channel, or user specified a (consistent) type, return it.\n  if (type === typeProjection) return;\n  if (type !== undefined) return type;\n\n  // If there’s no data (and no type) associated with this scale, don’t create a scale.\n  if (domain === undefined && !channels.some(({value}) => value !== undefined)) return;\n\n  // Some scales have default types.\n  const kind = registry.get(key);\n  if (kind === radius) return \"sqrt\";\n  if (kind === opacity || kind === length) return \"linear\";\n  if (kind === symbol) return \"ordinal\";\n\n  // If the domain or range has more than two values, assume it’s ordinal. You\n  // can still use a “piecewise” (or “polylinear”) scale, but you must set the\n  // type explicitly.\n  if ((domain || range || []).length > 2) return asOrdinalType(kind);\n\n  // Otherwise, infer the scale type from the data! Prefer the domain, if\n  // present, over channels. (The domain and channels should be consistently\n  // typed, and the domain is more explicit and typically much smaller.) We only\n  // check the first defined value for expedience and simplicity; we expect\n  // that the types are consistent.\n  if (domain !== undefined) {\n    if (isOrdinal(domain)) return asOrdinalType(kind);\n    if (isTemporal(domain)) return \"utc\";\n  } else {\n    const values = channels.map(({value}) => value).filter((value) => value !== undefined);\n    if (values.some(isOrdinal)) return asOrdinalType(kind);\n    if (values.some(isTemporal)) return \"utc\";\n  }\n\n  // For color scales, take a hint from the color scheme and pivot option.\n  if (kind === color) {\n    if (pivot != null || isDivergingScheme(scheme)) return \"diverging\";\n    if (isCategoricalScheme(scheme)) return \"categorical\";\n  }\n\n  return \"linear\";\n}\n\n// Positional scales default to a point scale instead of an ordinal scale.\nfunction asOrdinalType(kind) {\n  switch (kind) {\n    case position:\n      return \"point\";\n    case color:\n      return ordinalImplicit;\n    default:\n      return \"ordinal\";\n  }\n}\n\nexport function isTemporalScale({type}) {\n  return type === \"time\" || type === \"utc\";\n}\n\nexport function isOrdinalScale({type}) {\n  return type === \"ordinal\" || type === \"point\" || type === \"band\" || type === ordinalImplicit;\n}\n\nexport function isThresholdScale({type}) {\n  return type === \"threshold\";\n}\n\nfunction isBandScale({type}) {\n  return type === \"point\" || type === \"band\";\n}\n\nexport function isDivergingScale({type}) {\n  return /^diverging($|-)/.test(type);\n}\n\n// Certain marks have special behavior if a scale is collapsed, i.e. if the\n// domain is degenerate and represents only a single value such as [3, 3]; for\n// example, a rect will span the full extent of the chart along a collapsed\n// dimension (whereas a dot will simply be drawn in the center).\nexport function isCollapsed(scale) {\n  if (scale === undefined) return true; // treat missing scale as collapsed\n  const domain = scale.domain();\n  const value = scale(domain[0]);\n  for (let i = 1, n = domain.length; i < n; ++i) {\n    if (scale(domain[i]) - value) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Mutates channel.value!\nfunction coerceType(channels, {domain, ...options}, coerceValues) {\n  for (const c of channels) {\n    if (c.value !== undefined) {\n      if (domain === undefined) domain = c.value?.domain; // promote channel domain\n      c.value = coerceValues(c.value);\n    }\n  }\n  return {\n    domain: domain === undefined ? domain : coerceValues(domain),\n    ...options\n  };\n}\n\nfunction coerceSymbols(values) {\n  return map(values, maybeSymbol);\n}\n\nexport function scale(options = {}) {\n  let scale;\n  for (const key in options) {\n    if (!registry.has(key)) continue; // ignore unknown properties\n    if (!isScaleOptions(options[key])) continue; // e.g., ignore {color: \"red\"}\n    if (scale !== undefined) throw new Error(\"ambiguous scale definition; multiple scales found\");\n    scale = exposeScale(normalizeScale(key, options[key]));\n  }\n  if (scale === undefined) throw new Error(\"invalid scale definition; no scale found\");\n  return scale;\n}\n\nexport function exposeScales(scales) {\n  return (key) => {\n    if (!registry.has((key = `${key}`))) throw new Error(`unknown scale: ${key}`);\n    return scales[key];\n  };\n}\n\n// Note: axis- and legend-related properties (such as label, ticks and\n// tickFormat) are not included here as they do not affect the scale’s behavior.\nfunction exposeScale({scale, type, domain, range, interpolate, interval, transform, percent, pivot}) {\n  if (type === \"identity\") return {type: \"identity\", apply: (d) => d, invert: (d) => d};\n  const unknown = scale.unknown ? scale.unknown() : undefined;\n  return {\n    type,\n    domain: slice(domain), // defensive copy\n    ...(range !== undefined && {range: slice(range)}), // defensive copy\n    ...(transform !== undefined && {transform}),\n    ...(percent && {percent}), // only exposed if truthy\n    ...(unknown !== undefined && {unknown}),\n    ...(interval !== undefined && {interval}),\n\n    // quantitative\n    ...(interpolate !== undefined && {interpolate}),\n    ...(scale.clamp && {clamp: scale.clamp()}),\n\n    // diverging (always asymmetric; we never want to apply the symmetric transform twice)\n    ...(pivot !== undefined && {pivot, symmetric: false}),\n\n    // log, diverging-log\n    ...(scale.base && {base: scale.base()}),\n\n    // pow, diverging-pow\n    ...(scale.exponent && {exponent: scale.exponent()}),\n\n    // symlog, diverging-symlog\n    ...(scale.constant && {constant: scale.constant()}),\n\n    // band, point\n    ...(scale.align && {align: scale.align(), round: scale.round()}),\n    ...(scale.padding &&\n      (scale.paddingInner\n        ? {paddingInner: scale.paddingInner(), paddingOuter: scale.paddingOuter()}\n        : {padding: scale.padding()})),\n    ...(scale.bandwidth && {bandwidth: scale.bandwidth(), step: scale.step()}),\n\n    // utilities\n    apply: (t) => scale(t),\n    ...(scale.invert && {invert: (t) => scale.invert(t)})\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}