{"ast":null,"code":"import { extent, deviation, max, mean, median, min, sum } from \"d3\";\nimport { defined } from \"../defined.js\";\nimport { percentile, taker } from \"../options.js\";\nimport { mapX, mapY } from \"./map.js\";\nexport function normalizeX(basis, options) {\n  if (arguments.length === 1) ({\n    basis,\n    ...options\n  } = basis);\n  return mapX(normalize(basis), options);\n}\nexport function normalizeY(basis, options) {\n  if (arguments.length === 1) ({\n    basis,\n    ...options\n  } = basis);\n  return mapY(normalize(basis), options);\n}\nexport function normalize(basis) {\n  if (basis === undefined) return normalizeFirst;\n  if (typeof basis === \"function\") return normalizeBasis(taker(basis));\n  if (/^p\\d{2}$/i.test(basis)) return normalizeAccessor(percentile(basis));\n  switch (`${basis}`.toLowerCase()) {\n    case \"deviation\":\n      return normalizeDeviation;\n    case \"first\":\n      return normalizeFirst;\n    case \"last\":\n      return normalizeLast;\n    case \"max\":\n      return normalizeMax;\n    case \"mean\":\n      return normalizeMean;\n    case \"median\":\n      return normalizeMedian;\n    case \"min\":\n      return normalizeMin;\n    case \"sum\":\n      return normalizeSum;\n    case \"extent\":\n      return normalizeExtent;\n  }\n  throw new Error(`invalid basis: ${basis}`);\n}\nfunction normalizeBasis(basis) {\n  return {\n    mapIndex(I, S, T) {\n      const b = +basis(I, S);\n      for (const i of I) {\n        T[i] = S[i] === null ? NaN : S[i] / b;\n      }\n    }\n  };\n}\nfunction normalizeAccessor(f) {\n  return normalizeBasis((I, S) => f(I, i => S[i]));\n}\nconst normalizeExtent = {\n  mapIndex(I, S, T) {\n    const [s1, s2] = extent(I, i => S[i]);\n    const d = s2 - s1;\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;\n    }\n  }\n};\nconst normalizeFirst = normalizeBasis((I, S) => {\n  for (let i = 0; i < I.length; ++i) {\n    const s = S[I[i]];\n    if (defined(s)) return s;\n  }\n});\nconst normalizeLast = normalizeBasis((I, S) => {\n  for (let i = I.length - 1; i >= 0; --i) {\n    const s = S[I[i]];\n    if (defined(s)) return s;\n  }\n});\nconst normalizeDeviation = {\n  mapIndex(I, S, T) {\n    const m = mean(I, i => S[i]);\n    const d = deviation(I, i => S[i]);\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : d ? (S[i] - m) / d : 0;\n    }\n  }\n};\nconst normalizeMax = normalizeAccessor(max);\nconst normalizeMean = normalizeAccessor(mean);\nconst normalizeMedian = normalizeAccessor(median);\nconst normalizeMin = normalizeAccessor(min);\nconst normalizeSum = normalizeAccessor(sum);","map":{"version":3,"names":["extent","deviation","max","mean","median","min","sum","defined","percentile","taker","mapX","mapY","normalizeX","basis","options","arguments","length","normalize","normalizeY","undefined","normalizeFirst","normalizeBasis","test","normalizeAccessor","toLowerCase","normalizeDeviation","normalizeLast","normalizeMax","normalizeMean","normalizeMedian","normalizeMin","normalizeSum","normalizeExtent","Error","mapIndex","I","S","T","b","i","NaN","f","s1","s2","d","s","m"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/normalize.js"],"sourcesContent":["import {extent, deviation, max, mean, median, min, sum} from \"d3\";\nimport {defined} from \"../defined.js\";\nimport {percentile, taker} from \"../options.js\";\nimport {mapX, mapY} from \"./map.js\";\n\nexport function normalizeX(basis, options) {\n  if (arguments.length === 1) ({basis, ...options} = basis);\n  return mapX(normalize(basis), options);\n}\n\nexport function normalizeY(basis, options) {\n  if (arguments.length === 1) ({basis, ...options} = basis);\n  return mapY(normalize(basis), options);\n}\n\nexport function normalize(basis) {\n  if (basis === undefined) return normalizeFirst;\n  if (typeof basis === \"function\") return normalizeBasis(taker(basis));\n  if (/^p\\d{2}$/i.test(basis)) return normalizeAccessor(percentile(basis));\n  switch (`${basis}`.toLowerCase()) {\n    case \"deviation\":\n      return normalizeDeviation;\n    case \"first\":\n      return normalizeFirst;\n    case \"last\":\n      return normalizeLast;\n    case \"max\":\n      return normalizeMax;\n    case \"mean\":\n      return normalizeMean;\n    case \"median\":\n      return normalizeMedian;\n    case \"min\":\n      return normalizeMin;\n    case \"sum\":\n      return normalizeSum;\n    case \"extent\":\n      return normalizeExtent;\n  }\n  throw new Error(`invalid basis: ${basis}`);\n}\n\nfunction normalizeBasis(basis) {\n  return {\n    mapIndex(I, S, T) {\n      const b = +basis(I, S);\n      for (const i of I) {\n        T[i] = S[i] === null ? NaN : S[i] / b;\n      }\n    }\n  };\n}\n\nfunction normalizeAccessor(f) {\n  return normalizeBasis((I, S) => f(I, (i) => S[i]));\n}\n\nconst normalizeExtent = {\n  mapIndex(I, S, T) {\n    const [s1, s2] = extent(I, (i) => S[i]);\n    const d = s2 - s1;\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : (S[i] - s1) / d;\n    }\n  }\n};\n\nconst normalizeFirst = normalizeBasis((I, S) => {\n  for (let i = 0; i < I.length; ++i) {\n    const s = S[I[i]];\n    if (defined(s)) return s;\n  }\n});\n\nconst normalizeLast = normalizeBasis((I, S) => {\n  for (let i = I.length - 1; i >= 0; --i) {\n    const s = S[I[i]];\n    if (defined(s)) return s;\n  }\n});\n\nconst normalizeDeviation = {\n  mapIndex(I, S, T) {\n    const m = mean(I, (i) => S[i]);\n    const d = deviation(I, (i) => S[i]);\n    for (const i of I) {\n      T[i] = S[i] === null ? NaN : d ? (S[i] - m) / d : 0;\n    }\n  }\n};\n\nconst normalizeMax = normalizeAccessor(max);\nconst normalizeMean = normalizeAccessor(mean);\nconst normalizeMedian = normalizeAccessor(median);\nconst normalizeMin = normalizeAccessor(min);\nconst normalizeSum = normalizeAccessor(sum);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}