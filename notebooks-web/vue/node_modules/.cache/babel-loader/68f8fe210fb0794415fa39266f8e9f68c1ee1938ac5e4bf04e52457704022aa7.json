{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { blurImage, Delaunay, randomLcg, rgb } from \"d3\";\nimport { valueObject } from \"../channel.js\";\nimport { create } from \"../context.js\";\nimport { map, first, second, third, isTuples, isNumeric, isTemporal, identity } from \"../options.js\";\nimport { maybeColorChannel, maybeNumberChannel } from \"../options.js\";\nimport { Mark } from \"../mark.js\";\nimport { applyAttr, applyDirectStyles, applyIndirectStyles, applyTransform, impliedString } from \"../style.js\";\nimport { initializer } from \"../transforms/basic.js\";\nconst defaults = {\n  ariaLabel: \"raster\",\n  stroke: null,\n  pixelSize: 1\n};\nfunction number(input, name) {\n  const x = +input;\n  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);\n  return x;\n}\nfunction integer(input, name) {\n  const x = Math.floor(input);\n  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);\n  return x;\n}\nexport class AbstractRaster extends Mark {\n  constructor(data, channels, options = {}, defaults) {\n    let {\n      width,\n      height,\n      x,\n      y,\n      x1 = x == null ? 0 : undefined,\n      y1 = y == null ? 0 : undefined,\n      x2 = x == null ? width : undefined,\n      y2 = y == null ? height : undefined,\n      pixelSize = defaults.pixelSize,\n      blur = 0,\n      interpolate\n    } = options;\n    if (width != null) width = integer(width, \"width\");\n    if (height != null) height = integer(height, \"height\");\n    // These represent the (minimum) bounds of the raster; they are not\n    // evaluated for each datum. Also, if x and y are not specified explicitly,\n    // then these bounds are used to compute the dense linear grid.\n    if (x1 != null) x1 = number(x1, \"x1\");\n    if (y1 != null) y1 = number(y1, \"y1\");\n    if (x2 != null) x2 = number(x2, \"x2\");\n    if (y2 != null) y2 = number(y2, \"y2\");\n    if (x == null && (x1 == null || x2 == null)) throw new Error(\"missing x\");\n    if (y == null && (y1 == null || y2 == null)) throw new Error(\"missing y\");\n    if (data != null && width != null && height != null) {\n      // If x and y are not given, assume the data is a dense array of samples\n      // covering the entire grid in row-major order. These defaults allow\n      // further shorthand where x and y represent grid column and row index.\n      // TODO If we know that the x and y scales are linear, then we could avoid\n      // materializing these columns to improve performance.\n      if (x === undefined && x1 != null && x2 != null) x = denseX(x1, x2, width, height);\n      if (y === undefined && y1 != null && y2 != null) y = denseY(y1, y2, width, height);\n    }\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: y,\n        scale: \"y\",\n        optional: true\n      },\n      x1: {\n        value: x1 == null ? null : [x1],\n        scale: \"x\",\n        optional: true,\n        filter: null\n      },\n      y1: {\n        value: y1 == null ? null : [y1],\n        scale: \"y\",\n        optional: true,\n        filter: null\n      },\n      x2: {\n        value: x2 == null ? null : [x2],\n        scale: \"x\",\n        optional: true,\n        filter: null\n      },\n      y2: {\n        value: y2 == null ? null : [y2],\n        scale: \"y\",\n        optional: true,\n        filter: null\n      },\n      ...channels\n    }, options, defaults);\n    this.width = width;\n    this.height = height;\n    this.pixelSize = number(pixelSize, \"pixelSize\");\n    this.blur = number(blur, \"blur\");\n    this.interpolate = x == null || y == null ? null : maybeInterpolate(interpolate); // interpolation requires x & y\n  }\n}\n\nexport class Raster extends AbstractRaster {\n  constructor(data, options = {}) {\n    const {\n      imageRendering\n    } = options;\n    if (data == null) {\n      const {\n        fill,\n        fillOpacity\n      } = options;\n      if (maybeNumberChannel(fillOpacity)[0] !== undefined) options = sampler(\"fillOpacity\", options);\n      if (maybeColorChannel(fill)[0] !== undefined) options = sampler(\"fill\", options);\n    }\n    super(data, undefined, options, defaults);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  // Ignore the color scale, so the fill channel is returned unscaled.\n  scale(channels, {\n    color,\n    ...scales\n  }, context) {\n    return super.scale(channels, scales, context);\n  }\n  render(index, scales, values, dimensions, context) {\n    const color = scales[values.channels.fill?.scale] ?? (x => x);\n    const {\n      x: X,\n      y: Y\n    } = values;\n    const {\n      document\n    } = context;\n    const [x1, y1, x2, y2] = renderBounds(values, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {\n      pixelSize: k,\n      width: w = Math.round(Math.abs(dx) / k),\n      height: h = Math.round(Math.abs(dy) / k)\n    } = this;\n    const n = w * h;\n\n    // Interpolate the samples to fill the raster grid. If interpolate is null,\n    // then a continuous function is being sampled, and the raster grid is\n    // already aligned with the canvas.\n    let {\n      fill: F,\n      fillOpacity: FO\n    } = values;\n    let offset = 0;\n    if (this.interpolate) {\n      const kx = w / dx;\n      const ky = h / dy;\n      const IX = map(X, x => (x - x1) * kx, Float64Array);\n      const IY = map(Y, y => (y - y1) * ky, Float64Array);\n      if (F) F = this.interpolate(index, w, h, IX, IY, F);\n      if (FO) FO = this.interpolate(index, w, h, IX, IY, FO);\n    }\n\n    // When faceting without interpolation, as when sampling a continuous\n    // function, offset into the dense grid based on the current facet index.\n    else if (this.data == null && index) offset = index.fi * n;\n\n    // Render the raster grid to the canvas, blurring if needed.\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = w;\n    canvas.height = h;\n    const context2d = canvas.getContext(\"2d\");\n    const image = context2d.createImageData(w, h);\n    const imageData = image.data;\n    let {\n      r,\n      g,\n      b\n    } = rgb(this.fill) ?? {\n      r: 0,\n      g: 0,\n      b: 0\n    };\n    let a = (this.fillOpacity ?? 1) * 255;\n    for (let i = 0; i < n; ++i) {\n      const j = i << 2;\n      if (F) {\n        const fi = color(F[i + offset]);\n        if (fi == null) {\n          imageData[j + 3] = 0;\n          continue;\n        }\n        ({\n          r,\n          g,\n          b\n        } = rgb(fi));\n      }\n      if (FO) a = FO[i + offset] * 255;\n      imageData[j + 0] = r;\n      imageData[j + 1] = g;\n      imageData[j + 2] = b;\n      imageData[j + 3] = a;\n    }\n    if (this.blur > 0) blurImage(image, this.blur);\n    context2d.putImageData(image, 0, 0);\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(g => g.append(\"image\").attr(\"transform\", `translate(${x1},${y1}) scale(${Math.sign(x2 - x1)},${Math.sign(y2 - y1)})`).attr(\"width\", Math.abs(dx)).attr(\"height\", Math.abs(dy)).attr(\"preserveAspectRatio\", \"none\").call(applyAttr, \"image-rendering\", this.imageRendering).call(applyDirectStyles, this).attr(\"xlink:href\", canvas.toDataURL())).node();\n  }\n}\nexport function maybeTuples(k, data, options) {\n  if (arguments.length < 3) options = data, data = null;\n  let {\n    x,\n    y,\n    [k]: z,\n    ...rest\n  } = options;\n  // Because we use implicit x and y when z is a function of (x, y), and when\n  // data is a dense grid, we must further disambiguate by testing whether data\n  // contains [x, y, z?] tuples. Hence you can’t use this shorthand with a\n  // transform that lazily generates tuples, but that seems reasonable since\n  // this is just for convenience anyway.\n  if (x === undefined && y === undefined && isTuples(data)) {\n    x = first, y = second;\n    if (z === undefined) z = third;\n  }\n  return [data, {\n    ...rest,\n    x,\n    y,\n    [k]: z\n  }];\n}\nexport function raster() {\n  const [data, options] = maybeTuples(\"fill\", ...arguments);\n  return new Raster(data, data == null || options.fill !== undefined || options.fillOpacity !== undefined ? options : {\n    ...options,\n    fill: identity\n  });\n}\n\n// See rasterBounds; this version is called during render.\nfunction renderBounds({\n  x1,\n  y1,\n  x2,\n  y2\n}, dimensions, {\n  projection\n}) {\n  const {\n    width,\n    height,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  } = dimensions;\n  return [x1 && projection == null ? x1[0] : marginLeft, y1 && projection == null ? y1[0] : marginTop, x2 && projection == null ? x2[0] : width - marginRight, y2 && projection == null ? y2[0] : height - marginBottom];\n}\n\n// If x1, y1, x2, y2 were specified, and no projection is in use (and thus the\n// raster grid is necessarily an axis-aligned rectangle), then we can compute\n// tighter bounds for the image, improving resolution.\nexport function rasterBounds({\n  x1,\n  y1,\n  x2,\n  y2\n}, scales, dimensions, context) {\n  const channels = {};\n  if (x1) channels.x1 = x1;\n  if (y1) channels.y1 = y1;\n  if (x2) channels.x2 = x2;\n  if (y2) channels.y2 = y2;\n  return renderBounds(valueObject(channels, scales), dimensions, context);\n}\n\n// Evaluates the function with the given name, if it exists, on the raster grid,\n// generating a channel of the same name.\nexport function sampler(name, options = {}) {\n  const {\n    [name]: value\n  } = options;\n  if (typeof value !== \"function\") throw new Error(`invalid ${name}: not a function`);\n  return initializer({\n    ...options,\n    [name]: undefined\n  }, function (data, facets, channels, scales, dimensions, context) {\n    const {\n      x,\n      y\n    } = scales;\n    // TODO Allow projections, if invertible.\n    if (!x) throw new Error(\"missing scale: x\");\n    if (!y) throw new Error(\"missing scale: y\");\n    const [x1, y1, x2, y2] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {\n      pixelSize: k\n    } = this;\n    // Note: this must exactly match the defaults in render above!\n    const {\n      width: w = Math.round(Math.abs(dx) / k),\n      height: h = Math.round(Math.abs(dy) / k)\n    } = options;\n    // TODO Hint to use a typed array when possible?\n    const V = new Array(w * h * (facets ? facets.length : 1));\n    const kx = dx / w;\n    const ky = dy / h;\n    let i = 0;\n    for (const facet of facets ?? [undefined]) {\n      for (let yi = 0.5; yi < h; ++yi) {\n        for (let xi = 0.5; xi < w; ++xi, ++i) {\n          V[i] = value(x.invert(x1 + xi * kx), y.invert(y1 + yi * ky), facet);\n        }\n      }\n    }\n    return {\n      data: V,\n      facets,\n      channels: {\n        [name]: {\n          value: V,\n          scale: \"auto\"\n        }\n      }\n    };\n  });\n}\nfunction maybeInterpolate(interpolate) {\n  if (typeof interpolate === \"function\") return interpolate;\n  if (interpolate == null) return interpolateNone;\n  switch (`${interpolate}`.toLowerCase()) {\n    case \"none\":\n      return interpolateNone;\n    case \"nearest\":\n      return interpolateNearest;\n    case \"barycentric\":\n      return interpolatorBarycentric();\n    case \"random-walk\":\n      return interpolatorRandomWalk();\n  }\n  throw new Error(`invalid interpolate: ${interpolate}`);\n}\n\n// Applies a simple forward mapping of samples, binning them into pixels without\n// any blending or interpolation. Note: if multiple samples map to the same\n// pixel, the last one wins; this can introduce bias if the points are not in\n// random order, so use Plot.shuffle to randomize the input if needed.\nexport function interpolateNone(index, width, height, X, Y, V) {\n  const W = new Array(width * height);\n  for (const i of index) {\n    if (X[i] < 0 || X[i] >= width || Y[i] < 0 || Y[i] >= height) continue;\n    W[Math.floor(Y[i]) * width + Math.floor(X[i])] = V[i];\n  }\n  return W;\n}\nexport function interpolatorBarycentric({\n  random = randomLcg(42)\n} = {}) {\n  return (index, width, height, X, Y, V) => {\n    // Interpolate the interior of all triangles with barycentric coordinates\n    const {\n      points,\n      triangles,\n      hull\n    } = Delaunay.from(index, i => X[i], i => Y[i]);\n    const W = new V.constructor(width * height).fill(NaN);\n    const S = new Uint8Array(width * height); // 1 if pixel has been seen.\n    const mix = mixer(V, random);\n    for (let i = 0; i < triangles.length; i += 3) {\n      const ta = triangles[i];\n      const tb = triangles[i + 1];\n      const tc = triangles[i + 2];\n      const Ax = points[2 * ta];\n      const Bx = points[2 * tb];\n      const Cx = points[2 * tc];\n      const Ay = points[2 * ta + 1];\n      const By = points[2 * tb + 1];\n      const Cy = points[2 * tc + 1];\n      const x1 = Math.min(Ax, Bx, Cx);\n      const x2 = Math.max(Ax, Bx, Cx);\n      const y1 = Math.min(Ay, By, Cy);\n      const y2 = Math.max(Ay, By, Cy);\n      const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);\n      if (!z) continue;\n      const va = V[index[ta]];\n      const vb = V[index[tb]];\n      const vc = V[index[tc]];\n      for (let x = Math.floor(x1); x < x2; ++x) {\n        for (let y = Math.floor(y1); y < y2; ++y) {\n          if (x < 0 || x >= width || y < 0 || y >= height) continue;\n          const xp = x + 0.5; // sample pixel centroids\n          const yp = y + 0.5;\n          const s = Math.sign(z);\n          const ga = (By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx);\n          if (ga * s < 0) continue;\n          const gb = (Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx);\n          if (gb * s < 0) continue;\n          const gc = z - (ga + gb);\n          if (gc * s < 0) continue;\n          const i = x + width * y;\n          W[i] = mix(va, ga / z, vb, gb / z, vc, gc / z, x, y);\n          S[i] = 1;\n        }\n      }\n    }\n    extrapolateBarycentric(W, S, X, Y, V, width, height, hull, index, mix);\n    return W;\n  };\n}\n\n// Extrapolate by finding the closest point on the hull.\nfunction extrapolateBarycentric(W, S, X, Y, V, width, height, hull, index, mix) {\n  X = Float64Array.from(hull, i => X[index[i]]);\n  Y = Float64Array.from(hull, i => Y[index[i]]);\n  V = Array.from(hull, i => V[index[i]]);\n  const n = X.length;\n  const rays = Array.from({\n    length: n\n  }, (_, j) => ray(j, X, Y));\n  let k = 0;\n  for (let y = 0; y < height; ++y) {\n    const yp = y + 0.5;\n    for (let x = 0; x < width; ++x) {\n      const i = x + width * y;\n      if (!S[i]) {\n        const xp = x + 0.5;\n        for (let l = 0; l < n; ++l) {\n          const j = (n + k + (l % 2 ? (l + 1) / 2 : -l / 2)) % n;\n          if (rays[j](xp, yp)) {\n            const t = segmentProject(X.at(j - 1), Y.at(j - 1), X[j], Y[j], xp, yp);\n            W[i] = mix(V.at(j - 1), t, V[j], 1 - t, V[j], 0, x, y);\n            k = j;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\n// Projects a point p = [x, y] onto the line segment [p1, p2], returning the\n// projected coordinates p’ as t in [0, 1] with p’ = t p1 + (1 - t) p2.\nfunction segmentProject(x1, y1, x2, y2, x, y) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const a = dx * (x2 - x) + dy * (y2 - y);\n  const b = dx * (x - x1) + dy * (y - y1);\n  return a > 0 && b > 0 ? a / (a + b) : +(a > b);\n}\nfunction cross(xa, ya, xb, yb) {\n  return xa * yb - xb * ya;\n}\nfunction ray(j, X, Y) {\n  const n = X.length;\n  const xc = X.at(j - 2);\n  const yc = Y.at(j - 2);\n  const xa = X.at(j - 1);\n  const ya = Y.at(j - 1);\n  const xb = X[j];\n  const yb = Y[j];\n  const xd = X.at(j + 1 - n);\n  const yd = Y.at(j + 1 - n);\n  const dxab = xa - xb;\n  const dyab = ya - yb;\n  const dxca = xc - xa;\n  const dyca = yc - ya;\n  const dxbd = xb - xd;\n  const dybd = yb - yd;\n  const hab = Math.hypot(dxab, dyab);\n  const hca = Math.hypot(dxca, dyca);\n  const hbd = Math.hypot(dxbd, dybd);\n  return (x, y) => {\n    const dxa = x - xa;\n    const dya = y - ya;\n    const dxb = x - xb;\n    const dyb = y - yb;\n    return cross(dxa, dya, dxb, dyb) > -1e-6 && cross(dxa, dya, dxab, dyab) * hca - cross(dxa, dya, dxca, dyca) * hab > -1e-6 && cross(dxb, dyb, dxbd, dybd) * hab - cross(dxb, dyb, dxab, dyab) * hbd <= 0;\n  };\n}\nexport function interpolateNearest(index, width, height, X, Y, V) {\n  const W = new V.constructor(width * height);\n  const delaunay = Delaunay.from(index, i => X[i], i => Y[i]);\n  // memoization of delaunay.find for the line start (iy) and pixel (ix)\n  let iy, ix;\n  for (let y = 0.5, k = 0; y < height; ++y) {\n    ix = iy;\n    for (let x = 0.5; x < width; ++x, ++k) {\n      ix = delaunay.find(x, y, ix);\n      if (x === 0.5) iy = ix;\n      W[k] = V[index[ix]];\n    }\n  }\n  return W;\n}\n\n// https://observablehq.com/@observablehq/walk-on-spheres-precision\nexport function interpolatorRandomWalk({\n  random = randomLcg(42),\n  minDistance = 0.5,\n  maxSteps = 2\n} = {}) {\n  return (index, width, height, X, Y, V) => {\n    const W = new V.constructor(width * height);\n    const delaunay = Delaunay.from(index, i => X[i], i => Y[i]);\n    // memoization of delaunay.find for the line start (iy), pixel (ix), and wos step (iw)\n    let iy, ix, iw;\n    for (let y = 0.5, k = 0; y < height; ++y) {\n      ix = iy;\n      for (let x = 0.5; x < width; ++x, ++k) {\n        let cx = x;\n        let cy = y;\n        iw = ix = delaunay.find(cx, cy, ix);\n        if (x === 0.5) iy = ix;\n        let distance; // distance to closest sample\n        let step = 0; // count of steps for this walk\n        while ((distance = Math.hypot(X[index[iw]] - cx, Y[index[iw]] - cy)) > minDistance && step < maxSteps) {\n          const angle = random(x, y, step) * 2 * Math.PI;\n          cx += Math.cos(angle) * distance;\n          cy += Math.sin(angle) * distance;\n          iw = delaunay.find(cx, cy, iw);\n          ++step;\n        }\n        W[k] = V[index[iw]];\n      }\n    }\n    return W;\n  };\n}\nfunction blend(a, ca, b, cb, c, cc) {\n  return ca * a + cb * b + cc * c;\n}\nfunction pick(random) {\n  return (a, ca, b, cb, c, cc, x, y) => {\n    const u = random(x, y);\n    return u < ca ? a : u < ca + cb ? b : c;\n  };\n}\nfunction mixer(F, random) {\n  return isNumeric(F) || isTemporal(F) ? blend : pick(random);\n}\nfunction denseX(x1, x2, width) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const X = new Float64Array(n);\n      const kx = (x2 - x1) / width;\n      const x0 = x1 + kx / 2;\n      for (let i = 0; i < n; ++i) X[i] = i % width * kx + x0;\n      return X;\n    }\n  };\n}\nfunction denseY(y1, y2, width, height) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const Y = new Float64Array(n);\n      const ky = (y2 - y1) / height;\n      const y0 = y1 + ky / 2;\n      for (let i = 0; i < n; ++i) Y[i] = Math.floor(i / width) % height * ky + y0;\n      return Y;\n    }\n  };\n}","map":{"version":3,"names":["blurImage","Delaunay","randomLcg","rgb","valueObject","create","map","first","second","third","isTuples","isNumeric","isTemporal","identity","maybeColorChannel","maybeNumberChannel","Mark","applyAttr","applyDirectStyles","applyIndirectStyles","applyTransform","impliedString","initializer","defaults","ariaLabel","stroke","pixelSize","number","input","name","x","isNaN","Error","integer","Math","floor","AbstractRaster","constructor","data","channels","options","width","height","y","x1","undefined","y1","x2","y2","blur","interpolate","denseX","denseY","value","scale","optional","filter","maybeInterpolate","Raster","imageRendering","fill","fillOpacity","sampler","color","scales","context","render","index","values","dimensions","X","Y","document","renderBounds","dx","dy","k","w","round","abs","h","n","F","FO","offset","kx","ky","IX","Float64Array","IY","fi","canvas","createElement","context2d","getContext","image","createImageData","imageData","r","g","b","a","i","j","putImageData","call","append","attr","sign","toDataURL","node","maybeTuples","arguments","length","z","rest","raster","projection","marginTop","marginRight","marginBottom","marginLeft","rasterBounds","facets","V","Array","facet","yi","xi","invert","interpolateNone","toLowerCase","interpolateNearest","interpolatorBarycentric","interpolatorRandomWalk","W","random","points","triangles","hull","from","NaN","S","Uint8Array","mix","mixer","ta","tb","tc","Ax","Bx","Cx","Ay","By","Cy","min","max","va","vb","vc","xp","yp","s","ga","gb","gc","extrapolateBarycentric","rays","_","ray","l","t","segmentProject","at","cross","xa","ya","xb","yb","xc","yc","xd","yd","dxab","dyab","dxca","dyca","dxbd","dybd","hab","hypot","hca","hbd","dxa","dya","dxb","dyb","delaunay","iy","ix","find","minDistance","maxSteps","iw","cx","cy","distance","step","angle","PI","cos","sin","blend","ca","cb","c","cc","pick","u","transform","x0","y0"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/raster.js"],"sourcesContent":["import {blurImage, Delaunay, randomLcg, rgb} from \"d3\";\nimport {valueObject} from \"../channel.js\";\nimport {create} from \"../context.js\";\nimport {map, first, second, third, isTuples, isNumeric, isTemporal, identity} from \"../options.js\";\nimport {maybeColorChannel, maybeNumberChannel} from \"../options.js\";\nimport {Mark} from \"../mark.js\";\nimport {applyAttr, applyDirectStyles, applyIndirectStyles, applyTransform, impliedString} from \"../style.js\";\nimport {initializer} from \"../transforms/basic.js\";\n\nconst defaults = {\n  ariaLabel: \"raster\",\n  stroke: null,\n  pixelSize: 1\n};\n\nfunction number(input, name) {\n  const x = +input;\n  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);\n  return x;\n}\n\nfunction integer(input, name) {\n  const x = Math.floor(input);\n  if (isNaN(x)) throw new Error(`invalid ${name}: ${input}`);\n  return x;\n}\n\nexport class AbstractRaster extends Mark {\n  constructor(data, channels, options = {}, defaults) {\n    let {\n      width,\n      height,\n      x,\n      y,\n      x1 = x == null ? 0 : undefined,\n      y1 = y == null ? 0 : undefined,\n      x2 = x == null ? width : undefined,\n      y2 = y == null ? height : undefined,\n      pixelSize = defaults.pixelSize,\n      blur = 0,\n      interpolate\n    } = options;\n    if (width != null) width = integer(width, \"width\");\n    if (height != null) height = integer(height, \"height\");\n    // These represent the (minimum) bounds of the raster; they are not\n    // evaluated for each datum. Also, if x and y are not specified explicitly,\n    // then these bounds are used to compute the dense linear grid.\n    if (x1 != null) x1 = number(x1, \"x1\");\n    if (y1 != null) y1 = number(y1, \"y1\");\n    if (x2 != null) x2 = number(x2, \"x2\");\n    if (y2 != null) y2 = number(y2, \"y2\");\n    if (x == null && (x1 == null || x2 == null)) throw new Error(\"missing x\");\n    if (y == null && (y1 == null || y2 == null)) throw new Error(\"missing y\");\n    if (data != null && width != null && height != null) {\n      // If x and y are not given, assume the data is a dense array of samples\n      // covering the entire grid in row-major order. These defaults allow\n      // further shorthand where x and y represent grid column and row index.\n      // TODO If we know that the x and y scales are linear, then we could avoid\n      // materializing these columns to improve performance.\n      if (x === undefined && x1 != null && x2 != null) x = denseX(x1, x2, width, height);\n      if (y === undefined && y1 != null && y2 != null) y = denseY(y1, y2, width, height);\n    }\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        x1: {value: x1 == null ? null : [x1], scale: \"x\", optional: true, filter: null},\n        y1: {value: y1 == null ? null : [y1], scale: \"y\", optional: true, filter: null},\n        x2: {value: x2 == null ? null : [x2], scale: \"x\", optional: true, filter: null},\n        y2: {value: y2 == null ? null : [y2], scale: \"y\", optional: true, filter: null},\n        ...channels\n      },\n      options,\n      defaults\n    );\n    this.width = width;\n    this.height = height;\n    this.pixelSize = number(pixelSize, \"pixelSize\");\n    this.blur = number(blur, \"blur\");\n    this.interpolate = x == null || y == null ? null : maybeInterpolate(interpolate); // interpolation requires x & y\n  }\n}\n\nexport class Raster extends AbstractRaster {\n  constructor(data, options = {}) {\n    const {imageRendering} = options;\n    if (data == null) {\n      const {fill, fillOpacity} = options;\n      if (maybeNumberChannel(fillOpacity)[0] !== undefined) options = sampler(\"fillOpacity\", options);\n      if (maybeColorChannel(fill)[0] !== undefined) options = sampler(\"fill\", options);\n    }\n    super(data, undefined, options, defaults);\n    this.imageRendering = impliedString(imageRendering, \"auto\");\n  }\n  // Ignore the color scale, so the fill channel is returned unscaled.\n  scale(channels, {color, ...scales}, context) {\n    return super.scale(channels, scales, context);\n  }\n  render(index, scales, values, dimensions, context) {\n    const color = scales[values.channels.fill?.scale] ?? ((x) => x);\n    const {x: X, y: Y} = values;\n    const {document} = context;\n    const [x1, y1, x2, y2] = renderBounds(values, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {pixelSize: k, width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k)} = this;\n    const n = w * h;\n\n    // Interpolate the samples to fill the raster grid. If interpolate is null,\n    // then a continuous function is being sampled, and the raster grid is\n    // already aligned with the canvas.\n    let {fill: F, fillOpacity: FO} = values;\n    let offset = 0;\n    if (this.interpolate) {\n      const kx = w / dx;\n      const ky = h / dy;\n      const IX = map(X, (x) => (x - x1) * kx, Float64Array);\n      const IY = map(Y, (y) => (y - y1) * ky, Float64Array);\n      if (F) F = this.interpolate(index, w, h, IX, IY, F);\n      if (FO) FO = this.interpolate(index, w, h, IX, IY, FO);\n    }\n\n    // When faceting without interpolation, as when sampling a continuous\n    // function, offset into the dense grid based on the current facet index.\n    else if (this.data == null && index) offset = index.fi * n;\n\n    // Render the raster grid to the canvas, blurring if needed.\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = w;\n    canvas.height = h;\n    const context2d = canvas.getContext(\"2d\");\n    const image = context2d.createImageData(w, h);\n    const imageData = image.data;\n    let {r, g, b} = rgb(this.fill) ?? {r: 0, g: 0, b: 0};\n    let a = (this.fillOpacity ?? 1) * 255;\n    for (let i = 0; i < n; ++i) {\n      const j = i << 2;\n      if (F) {\n        const fi = color(F[i + offset]);\n        if (fi == null) {\n          imageData[j + 3] = 0;\n          continue;\n        }\n        ({r, g, b} = rgb(fi));\n      }\n      if (FO) a = FO[i + offset] * 255;\n      imageData[j + 0] = r;\n      imageData[j + 1] = g;\n      imageData[j + 2] = b;\n      imageData[j + 3] = a;\n    }\n    if (this.blur > 0) blurImage(image, this.blur);\n    context2d.putImageData(image, 0, 0);\n\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, scales)\n      .call((g) =>\n        g\n          .append(\"image\")\n          .attr(\"transform\", `translate(${x1},${y1}) scale(${Math.sign(x2 - x1)},${Math.sign(y2 - y1)})`)\n          .attr(\"width\", Math.abs(dx))\n          .attr(\"height\", Math.abs(dy))\n          .attr(\"preserveAspectRatio\", \"none\")\n          .call(applyAttr, \"image-rendering\", this.imageRendering)\n          .call(applyDirectStyles, this)\n          .attr(\"xlink:href\", canvas.toDataURL())\n      )\n      .node();\n  }\n}\n\nexport function maybeTuples(k, data, options) {\n  if (arguments.length < 3) (options = data), (data = null);\n  let {x, y, [k]: z, ...rest} = options;\n  // Because we use implicit x and y when z is a function of (x, y), and when\n  // data is a dense grid, we must further disambiguate by testing whether data\n  // contains [x, y, z?] tuples. Hence you can’t use this shorthand with a\n  // transform that lazily generates tuples, but that seems reasonable since\n  // this is just for convenience anyway.\n  if (x === undefined && y === undefined && isTuples(data)) {\n    (x = first), (y = second);\n    if (z === undefined) z = third;\n  }\n  return [data, {...rest, x, y, [k]: z}];\n}\n\nexport function raster() {\n  const [data, options] = maybeTuples(\"fill\", ...arguments);\n  return new Raster(\n    data,\n    data == null || options.fill !== undefined || options.fillOpacity !== undefined\n      ? options\n      : {...options, fill: identity}\n  );\n}\n\n// See rasterBounds; this version is called during render.\nfunction renderBounds({x1, y1, x2, y2}, dimensions, {projection}) {\n  const {width, height, marginTop, marginRight, marginBottom, marginLeft} = dimensions;\n  return [\n    x1 && projection == null ? x1[0] : marginLeft,\n    y1 && projection == null ? y1[0] : marginTop,\n    x2 && projection == null ? x2[0] : width - marginRight,\n    y2 && projection == null ? y2[0] : height - marginBottom\n  ];\n}\n\n// If x1, y1, x2, y2 were specified, and no projection is in use (and thus the\n// raster grid is necessarily an axis-aligned rectangle), then we can compute\n// tighter bounds for the image, improving resolution.\nexport function rasterBounds({x1, y1, x2, y2}, scales, dimensions, context) {\n  const channels = {};\n  if (x1) channels.x1 = x1;\n  if (y1) channels.y1 = y1;\n  if (x2) channels.x2 = x2;\n  if (y2) channels.y2 = y2;\n  return renderBounds(valueObject(channels, scales), dimensions, context);\n}\n\n// Evaluates the function with the given name, if it exists, on the raster grid,\n// generating a channel of the same name.\nexport function sampler(name, options = {}) {\n  const {[name]: value} = options;\n  if (typeof value !== \"function\") throw new Error(`invalid ${name}: not a function`);\n  return initializer({...options, [name]: undefined}, function (data, facets, channels, scales, dimensions, context) {\n    const {x, y} = scales;\n    // TODO Allow projections, if invertible.\n    if (!x) throw new Error(\"missing scale: x\");\n    if (!y) throw new Error(\"missing scale: y\");\n    const [x1, y1, x2, y2] = rasterBounds(channels, scales, dimensions, context);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const {pixelSize: k} = this;\n    // Note: this must exactly match the defaults in render above!\n    const {width: w = Math.round(Math.abs(dx) / k), height: h = Math.round(Math.abs(dy) / k)} = options;\n    // TODO Hint to use a typed array when possible?\n    const V = new Array(w * h * (facets ? facets.length : 1));\n    const kx = dx / w;\n    const ky = dy / h;\n    let i = 0;\n    for (const facet of facets ?? [undefined]) {\n      for (let yi = 0.5; yi < h; ++yi) {\n        for (let xi = 0.5; xi < w; ++xi, ++i) {\n          V[i] = value(x.invert(x1 + xi * kx), y.invert(y1 + yi * ky), facet);\n        }\n      }\n    }\n    return {data: V, facets, channels: {[name]: {value: V, scale: \"auto\"}}};\n  });\n}\n\nfunction maybeInterpolate(interpolate) {\n  if (typeof interpolate === \"function\") return interpolate;\n  if (interpolate == null) return interpolateNone;\n  switch (`${interpolate}`.toLowerCase()) {\n    case \"none\":\n      return interpolateNone;\n    case \"nearest\":\n      return interpolateNearest;\n    case \"barycentric\":\n      return interpolatorBarycentric();\n    case \"random-walk\":\n      return interpolatorRandomWalk();\n  }\n  throw new Error(`invalid interpolate: ${interpolate}`);\n}\n\n// Applies a simple forward mapping of samples, binning them into pixels without\n// any blending or interpolation. Note: if multiple samples map to the same\n// pixel, the last one wins; this can introduce bias if the points are not in\n// random order, so use Plot.shuffle to randomize the input if needed.\nexport function interpolateNone(index, width, height, X, Y, V) {\n  const W = new Array(width * height);\n  for (const i of index) {\n    if (X[i] < 0 || X[i] >= width || Y[i] < 0 || Y[i] >= height) continue;\n    W[Math.floor(Y[i]) * width + Math.floor(X[i])] = V[i];\n  }\n  return W;\n}\n\nexport function interpolatorBarycentric({random = randomLcg(42)} = {}) {\n  return (index, width, height, X, Y, V) => {\n    // Interpolate the interior of all triangles with barycentric coordinates\n    const {points, triangles, hull} = Delaunay.from(\n      index,\n      (i) => X[i],\n      (i) => Y[i]\n    );\n    const W = new V.constructor(width * height).fill(NaN);\n    const S = new Uint8Array(width * height); // 1 if pixel has been seen.\n    const mix = mixer(V, random);\n\n    for (let i = 0; i < triangles.length; i += 3) {\n      const ta = triangles[i];\n      const tb = triangles[i + 1];\n      const tc = triangles[i + 2];\n      const Ax = points[2 * ta];\n      const Bx = points[2 * tb];\n      const Cx = points[2 * tc];\n      const Ay = points[2 * ta + 1];\n      const By = points[2 * tb + 1];\n      const Cy = points[2 * tc + 1];\n      const x1 = Math.min(Ax, Bx, Cx);\n      const x2 = Math.max(Ax, Bx, Cx);\n      const y1 = Math.min(Ay, By, Cy);\n      const y2 = Math.max(Ay, By, Cy);\n      const z = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);\n      if (!z) continue;\n      const va = V[index[ta]];\n      const vb = V[index[tb]];\n      const vc = V[index[tc]];\n      for (let x = Math.floor(x1); x < x2; ++x) {\n        for (let y = Math.floor(y1); y < y2; ++y) {\n          if (x < 0 || x >= width || y < 0 || y >= height) continue;\n          const xp = x + 0.5; // sample pixel centroids\n          const yp = y + 0.5;\n          const s = Math.sign(z);\n          const ga = (By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx);\n          if (ga * s < 0) continue;\n          const gb = (Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx);\n          if (gb * s < 0) continue;\n          const gc = z - (ga + gb);\n          if (gc * s < 0) continue;\n          const i = x + width * y;\n          W[i] = mix(va, ga / z, vb, gb / z, vc, gc / z, x, y);\n          S[i] = 1;\n        }\n      }\n    }\n    extrapolateBarycentric(W, S, X, Y, V, width, height, hull, index, mix);\n    return W;\n  };\n}\n\n// Extrapolate by finding the closest point on the hull.\nfunction extrapolateBarycentric(W, S, X, Y, V, width, height, hull, index, mix) {\n  X = Float64Array.from(hull, (i) => X[index[i]]);\n  Y = Float64Array.from(hull, (i) => Y[index[i]]);\n  V = Array.from(hull, (i) => V[index[i]]);\n  const n = X.length;\n  const rays = Array.from({length: n}, (_, j) => ray(j, X, Y));\n  let k = 0;\n  for (let y = 0; y < height; ++y) {\n    const yp = y + 0.5;\n    for (let x = 0; x < width; ++x) {\n      const i = x + width * y;\n      if (!S[i]) {\n        const xp = x + 0.5;\n        for (let l = 0; l < n; ++l) {\n          const j = (n + k + (l % 2 ? (l + 1) / 2 : -l / 2)) % n;\n          if (rays[j](xp, yp)) {\n            const t = segmentProject(X.at(j - 1), Y.at(j - 1), X[j], Y[j], xp, yp);\n            W[i] = mix(V.at(j - 1), t, V[j], 1 - t, V[j], 0, x, y);\n            k = j;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\n// Projects a point p = [x, y] onto the line segment [p1, p2], returning the\n// projected coordinates p’ as t in [0, 1] with p’ = t p1 + (1 - t) p2.\nfunction segmentProject(x1, y1, x2, y2, x, y) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const a = dx * (x2 - x) + dy * (y2 - y);\n  const b = dx * (x - x1) + dy * (y - y1);\n  return a > 0 && b > 0 ? a / (a + b) : +(a > b);\n}\n\nfunction cross(xa, ya, xb, yb) {\n  return xa * yb - xb * ya;\n}\n\nfunction ray(j, X, Y) {\n  const n = X.length;\n  const xc = X.at(j - 2);\n  const yc = Y.at(j - 2);\n  const xa = X.at(j - 1);\n  const ya = Y.at(j - 1);\n  const xb = X[j];\n  const yb = Y[j];\n  const xd = X.at(j + 1 - n);\n  const yd = Y.at(j + 1 - n);\n  const dxab = xa - xb;\n  const dyab = ya - yb;\n  const dxca = xc - xa;\n  const dyca = yc - ya;\n  const dxbd = xb - xd;\n  const dybd = yb - yd;\n  const hab = Math.hypot(dxab, dyab);\n  const hca = Math.hypot(dxca, dyca);\n  const hbd = Math.hypot(dxbd, dybd);\n  return (x, y) => {\n    const dxa = x - xa;\n    const dya = y - ya;\n    const dxb = x - xb;\n    const dyb = y - yb;\n    return (\n      cross(dxa, dya, dxb, dyb) > -1e-6 &&\n      cross(dxa, dya, dxab, dyab) * hca - cross(dxa, dya, dxca, dyca) * hab > -1e-6 &&\n      cross(dxb, dyb, dxbd, dybd) * hab - cross(dxb, dyb, dxab, dyab) * hbd <= 0\n    );\n  };\n}\n\nexport function interpolateNearest(index, width, height, X, Y, V) {\n  const W = new V.constructor(width * height);\n  const delaunay = Delaunay.from(\n    index,\n    (i) => X[i],\n    (i) => Y[i]\n  );\n  // memoization of delaunay.find for the line start (iy) and pixel (ix)\n  let iy, ix;\n  for (let y = 0.5, k = 0; y < height; ++y) {\n    ix = iy;\n    for (let x = 0.5; x < width; ++x, ++k) {\n      ix = delaunay.find(x, y, ix);\n      if (x === 0.5) iy = ix;\n      W[k] = V[index[ix]];\n    }\n  }\n  return W;\n}\n\n// https://observablehq.com/@observablehq/walk-on-spheres-precision\nexport function interpolatorRandomWalk({random = randomLcg(42), minDistance = 0.5, maxSteps = 2} = {}) {\n  return (index, width, height, X, Y, V) => {\n    const W = new V.constructor(width * height);\n    const delaunay = Delaunay.from(\n      index,\n      (i) => X[i],\n      (i) => Y[i]\n    );\n    // memoization of delaunay.find for the line start (iy), pixel (ix), and wos step (iw)\n    let iy, ix, iw;\n    for (let y = 0.5, k = 0; y < height; ++y) {\n      ix = iy;\n      for (let x = 0.5; x < width; ++x, ++k) {\n        let cx = x;\n        let cy = y;\n        iw = ix = delaunay.find(cx, cy, ix);\n        if (x === 0.5) iy = ix;\n        let distance; // distance to closest sample\n        let step = 0; // count of steps for this walk\n        while ((distance = Math.hypot(X[index[iw]] - cx, Y[index[iw]] - cy)) > minDistance && step < maxSteps) {\n          const angle = random(x, y, step) * 2 * Math.PI;\n          cx += Math.cos(angle) * distance;\n          cy += Math.sin(angle) * distance;\n          iw = delaunay.find(cx, cy, iw);\n          ++step;\n        }\n        W[k] = V[index[iw]];\n      }\n    }\n    return W;\n  };\n}\n\nfunction blend(a, ca, b, cb, c, cc) {\n  return ca * a + cb * b + cc * c;\n}\n\nfunction pick(random) {\n  return (a, ca, b, cb, c, cc, x, y) => {\n    const u = random(x, y);\n    return u < ca ? a : u < ca + cb ? b : c;\n  };\n}\n\nfunction mixer(F, random) {\n  return isNumeric(F) || isTemporal(F) ? blend : pick(random);\n}\n\nfunction denseX(x1, x2, width) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const X = new Float64Array(n);\n      const kx = (x2 - x1) / width;\n      const x0 = x1 + kx / 2;\n      for (let i = 0; i < n; ++i) X[i] = (i % width) * kx + x0;\n      return X;\n    }\n  };\n}\n\nfunction denseY(y1, y2, width, height) {\n  return {\n    transform(data) {\n      const n = data.length;\n      const Y = new Float64Array(n);\n      const ky = (y2 - y1) / height;\n      const y0 = y1 + ky / 2;\n      for (let i = 0; i < n; ++i) Y[i] = (Math.floor(i / width) % height) * ky + y0;\n      return Y;\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}