{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { contourDensity, geoPath } from \"d3\";\nimport { create } from \"../context.js\";\nimport { Mark } from \"../mark.js\";\nimport { TypedArray, coerceNumbers, maybeTuple, maybeZ } from \"../options.js\";\nimport { applyPosition } from \"../projection.js\";\nimport { applyChannelStyles, applyDirectStyles, applyFrameAnchor, applyIndirectStyles, applyTransform, groupZ } from \"../style.js\";\nimport { initializer } from \"../transforms/basic.js\";\nconst defaults = {\n  ariaLabel: \"density\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nexport class Density extends Mark {\n  constructor(data, {\n    x,\n    y,\n    z,\n    weight,\n    fill,\n    stroke,\n    ...options\n  } = {}) {\n    // If fill or stroke is specified as “density”, then temporarily treat these\n    // as a literal color when computing defaults and maybeZ; below, we’ll unset\n    // these constant colors back to undefined since they will instead be\n    // populated by a channel generated by the initializer.\n    const fillDensity = isDensity(fill) && (fill = \"currentColor\", true);\n    const strokeDensity = isDensity(stroke) && (stroke = \"currentColor\", true);\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: y,\n        scale: \"y\",\n        optional: true\n      },\n      z: {\n        value: maybeZ({\n          z,\n          fill,\n          stroke\n        }),\n        optional: true\n      },\n      weight: {\n        value: weight,\n        optional: true\n      }\n    }, densityInitializer({\n      ...options,\n      fill,\n      stroke\n    }, fillDensity, strokeDensity), defaults);\n    if (fillDensity) this.fill = undefined;\n    if (strokeDensity) this.stroke = undefined;\n    this.z = z;\n  }\n  filter(index) {\n    return index; // don’t filter contours constructed by initializer\n  }\n\n  render(index, scales, channels, dimensions, context) {\n    const {\n      contours\n    } = channels;\n    const path = geoPath();\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call(g => g.selectAll().data(index).enter().append(\"path\").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr(\"d\", i => path(contours[i]))).node();\n  }\n}\nexport function density(data, {\n  x,\n  y,\n  ...options\n} = {}) {\n  [x, y] = maybeTuple(x, y);\n  return new Density(data, {\n    ...options,\n    x,\n    y\n  });\n}\nconst dropChannels = new Set([\"x\", \"y\", \"z\", \"weight\"]);\nfunction densityInitializer(options, fillDensity, strokeDensity) {\n  const k = 100; // arbitrary scale factor for readability\n  let {\n    bandwidth,\n    thresholds\n  } = options;\n  bandwidth = bandwidth === undefined ? 20 : +bandwidth;\n  thresholds = thresholds === undefined ? 20 : typeof thresholds?.[Symbol.iterator] === \"function\" ? coerceNumbers(thresholds) : +thresholds;\n  return initializer(options, function (data, facets, channels, scales, dimensions, context) {\n    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;\n    const Z = channels.z?.value;\n    const {\n      z\n    } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const {\n      width,\n      height\n    } = dimensions;\n\n    // Get the (either scaled or projected) xy channels.\n    const {\n      x: X,\n      y: Y\n    } = applyPosition(channels, scales, context);\n\n    // Group any of the input channels according to the first index associated\n    // with each z-series or facet. Drop any channels not be needed for\n    // rendering after the contours are computed.\n    const newChannels = Object.fromEntries(Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, {\n      ...channel,\n      value: []\n    }]));\n\n    // If the fill or stroke encodes density, construct new output channels.\n    const FD = fillDensity && [];\n    const SD = strokeDensity && [];\n    const density = contourDensity().x(X ? i => X[i] : cx).y(Y ? i => Y[i] : cy).weight(W ? i => W[i] : 1).size([width, height]).bandwidth(bandwidth);\n\n    // Compute the grid for each facet-series.\n    const facetsContours = [];\n    for (const facet of facets) {\n      const facetContours = [];\n      facetsContours.push(facetContours);\n      for (const index of Z ? groupZ(facet, Z, z) : [facet]) {\n        const contour = density.contours(index);\n        facetContours.push([index, contour]);\n      }\n    }\n\n    // If explicit thresholds were not specified, find the maximum density of\n    // all grids and use this to compute thresholds.\n    let T = thresholds;\n    if (!(T instanceof TypedArray)) {\n      let maxValue = 0;\n      for (const facetContours of facetsContours) {\n        for (const [, contour] of facetContours) {\n          const max = contour.max;\n          if (max > maxValue) maxValue = max;\n        }\n      }\n      T = Float64Array.from({\n        length: thresholds - 1\n      }, (_, i) => maxValue * k * (i + 1) / thresholds);\n    }\n\n    // Generate contours for each facet-series.\n    const newFacets = [];\n    const contours = [];\n    for (const facetContours of facetsContours) {\n      const newFacet = [];\n      newFacets.push(newFacet);\n      for (const [index, contour] of facetContours) {\n        for (const t of T) {\n          newFacet.push(contours.length);\n          contours.push(contour(t / k));\n          if (FD) FD.push(t);\n          if (SD) SD.push(t);\n          for (const key in newChannels) {\n            newChannels[key].value.push(channels[key].value[index[0]]);\n          }\n        }\n      }\n    }\n\n    // If the fill or stroke encodes density, ensure that a zero value is\n    // included so that the default color scale domain starts at zero. Otherwise\n    // if the starting range value is the same as the background color, the\n    // first contour might not be visible.\n    if (FD) FD.push(0);\n    if (SD) SD.push(0);\n    return {\n      data,\n      facets: newFacets,\n      channels: {\n        ...newChannels,\n        ...(FD && {\n          fill: {\n            value: FD,\n            scale: \"color\"\n          }\n        }),\n        ...(SD && {\n          stroke: {\n            value: SD,\n            scale: \"color\"\n          }\n        }),\n        contours: {\n          value: contours\n        }\n      }\n    };\n  });\n}\nfunction isDensity(value) {\n  return /^density$/i.test(value);\n}","map":{"version":3,"names":["contourDensity","geoPath","create","Mark","TypedArray","coerceNumbers","maybeTuple","maybeZ","applyPosition","applyChannelStyles","applyDirectStyles","applyFrameAnchor","applyIndirectStyles","applyTransform","groupZ","initializer","defaults","ariaLabel","fill","stroke","strokeMiterlimit","Density","constructor","data","x","y","z","weight","options","fillDensity","isDensity","strokeDensity","value","scale","optional","densityInitializer","undefined","filter","index","render","scales","channels","dimensions","context","contours","path","call","g","selectAll","enter","append","attr","i","node","density","dropChannels","Set","k","bandwidth","thresholds","Symbol","iterator","facets","W","Z","cx","cy","width","height","X","Y","newChannels","Object","fromEntries","entries","key","has","map","channel","FD","SD","size","facetsContours","facet","facetContours","push","contour","T","maxValue","max","Float64Array","from","length","_","newFacets","newFacet","t","test"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/density.js"],"sourcesContent":["import {contourDensity, geoPath} from \"d3\";\nimport {create} from \"../context.js\";\nimport {Mark} from \"../mark.js\";\nimport {TypedArray, coerceNumbers, maybeTuple, maybeZ} from \"../options.js\";\nimport {applyPosition} from \"../projection.js\";\nimport {\n  applyChannelStyles,\n  applyDirectStyles,\n  applyFrameAnchor,\n  applyIndirectStyles,\n  applyTransform,\n  groupZ\n} from \"../style.js\";\nimport {initializer} from \"../transforms/basic.js\";\n\nconst defaults = {\n  ariaLabel: \"density\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nexport class Density extends Mark {\n  constructor(data, {x, y, z, weight, fill, stroke, ...options} = {}) {\n    // If fill or stroke is specified as “density”, then temporarily treat these\n    // as a literal color when computing defaults and maybeZ; below, we’ll unset\n    // these constant colors back to undefined since they will instead be\n    // populated by a channel generated by the initializer.\n    const fillDensity = isDensity(fill) && ((fill = \"currentColor\"), true);\n    const strokeDensity = isDensity(stroke) && ((stroke = \"currentColor\"), true);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: maybeZ({z, fill, stroke}), optional: true},\n        weight: {value: weight, optional: true}\n      },\n      densityInitializer({...options, fill, stroke}, fillDensity, strokeDensity),\n      defaults\n    );\n    if (fillDensity) this.fill = undefined;\n    if (strokeDensity) this.stroke = undefined;\n    this.z = z;\n  }\n  filter(index) {\n    return index; // don’t filter contours constructed by initializer\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {contours} = channels;\n    const path = geoPath();\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .call(applyChannelStyles, this, channels)\n          .attr(\"d\", (i) => path(contours[i]))\n      )\n      .node();\n  }\n}\n\nexport function density(data, {x, y, ...options} = {}) {\n  [x, y] = maybeTuple(x, y);\n  return new Density(data, {...options, x, y});\n}\n\nconst dropChannels = new Set([\"x\", \"y\", \"z\", \"weight\"]);\n\nfunction densityInitializer(options, fillDensity, strokeDensity) {\n  const k = 100; // arbitrary scale factor for readability\n  let {bandwidth, thresholds} = options;\n  bandwidth = bandwidth === undefined ? 20 : +bandwidth;\n  thresholds =\n    thresholds === undefined\n      ? 20\n      : typeof thresholds?.[Symbol.iterator] === \"function\"\n      ? coerceNumbers(thresholds)\n      : +thresholds;\n  return initializer(options, function (data, facets, channels, scales, dimensions, context) {\n    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;\n    const Z = channels.z?.value;\n    const {z} = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const {width, height} = dimensions;\n\n    // Get the (either scaled or projected) xy channels.\n    const {x: X, y: Y} = applyPosition(channels, scales, context);\n\n    // Group any of the input channels according to the first index associated\n    // with each z-series or facet. Drop any channels not be needed for\n    // rendering after the contours are computed.\n    const newChannels = Object.fromEntries(\n      Object.entries(channels)\n        .filter(([key]) => !dropChannels.has(key))\n        .map(([key, channel]) => [key, {...channel, value: []}])\n    );\n\n    // If the fill or stroke encodes density, construct new output channels.\n    const FD = fillDensity && [];\n    const SD = strokeDensity && [];\n\n    const density = contourDensity()\n      .x(X ? (i) => X[i] : cx)\n      .y(Y ? (i) => Y[i] : cy)\n      .weight(W ? (i) => W[i] : 1)\n      .size([width, height])\n      .bandwidth(bandwidth);\n\n    // Compute the grid for each facet-series.\n    const facetsContours = [];\n    for (const facet of facets) {\n      const facetContours = [];\n      facetsContours.push(facetContours);\n      for (const index of Z ? groupZ(facet, Z, z) : [facet]) {\n        const contour = density.contours(index);\n        facetContours.push([index, contour]);\n      }\n    }\n\n    // If explicit thresholds were not specified, find the maximum density of\n    // all grids and use this to compute thresholds.\n    let T = thresholds;\n    if (!(T instanceof TypedArray)) {\n      let maxValue = 0;\n      for (const facetContours of facetsContours) {\n        for (const [, contour] of facetContours) {\n          const max = contour.max;\n          if (max > maxValue) maxValue = max;\n        }\n      }\n      T = Float64Array.from({length: thresholds - 1}, (_, i) => (maxValue * k * (i + 1)) / thresholds);\n    }\n\n    // Generate contours for each facet-series.\n    const newFacets = [];\n    const contours = [];\n    for (const facetContours of facetsContours) {\n      const newFacet = [];\n      newFacets.push(newFacet);\n      for (const [index, contour] of facetContours) {\n        for (const t of T) {\n          newFacet.push(contours.length);\n          contours.push(contour(t / k));\n          if (FD) FD.push(t);\n          if (SD) SD.push(t);\n          for (const key in newChannels) {\n            newChannels[key].value.push(channels[key].value[index[0]]);\n          }\n        }\n      }\n    }\n\n    // If the fill or stroke encodes density, ensure that a zero value is\n    // included so that the default color scale domain starts at zero. Otherwise\n    // if the starting range value is the same as the background color, the\n    // first contour might not be visible.\n    if (FD) FD.push(0);\n    if (SD) SD.push(0);\n\n    return {\n      data,\n      facets: newFacets,\n      channels: {\n        ...newChannels,\n        ...(FD && {fill: {value: FD, scale: \"color\"}}),\n        ...(SD && {stroke: {value: SD, scale: \"color\"}}),\n        contours: {value: contours}\n      }\n    };\n  });\n}\n\nfunction isDensity(value) {\n  return /^density$/i.test(value);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}