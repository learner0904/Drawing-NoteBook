{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { geoCentroid as GeoCentroid, geoPath } from \"d3\";\nimport { memoize1 } from \"../memoize.js\";\nimport { identity, valueof } from \"../options.js\";\nimport { initializer } from \"./basic.js\";\nexport function centroid({\n  geometry = identity,\n  ...options\n} = {}) {\n  const getG = memoize1(data => valueof(data, geometry));\n  return initializer(\n  // Suppress defaults for x and y since they will be computed by the initializer.\n  // Propagate the (memoized) geometry channel in case it’s still needed.\n  {\n    ...options,\n    x: null,\n    y: null,\n    geometry: {\n      transform: getG\n    }\n  }, (data, facets, channels, scales, dimensions, {\n    projection\n  }) => {\n    const G = getG(data);\n    const n = G.length;\n    const X = new Float64Array(n);\n    const Y = new Float64Array(n);\n    const path = geoPath(projection);\n    for (let i = 0; i < n; ++i) [X[i], Y[i]] = path.centroid(G[i]);\n    return {\n      data,\n      facets,\n      channels: {\n        x: {\n          value: X,\n          scale: projection == null ? \"x\" : null,\n          source: null\n        },\n        y: {\n          value: Y,\n          scale: projection == null ? \"y\" : null,\n          source: null\n        }\n      }\n    };\n  });\n}\nexport function geoCentroid({\n  geometry = identity,\n  ...options\n} = {}) {\n  const getG = memoize1(data => valueof(data, geometry));\n  const getC = memoize1(data => valueof(getG(data), GeoCentroid));\n  return {\n    ...options,\n    x: {\n      transform: data => Float64Array.from(getC(data), ([x]) => x)\n    },\n    y: {\n      transform: data => Float64Array.from(getC(data), ([, y]) => y)\n    },\n    geometry: {\n      transform: getG\n    }\n  };\n}","map":{"version":3,"names":["geoCentroid","GeoCentroid","geoPath","memoize1","identity","valueof","initializer","centroid","geometry","options","getG","data","x","y","transform","facets","channels","scales","dimensions","projection","G","n","length","X","Float64Array","Y","path","i","value","scale","source","getC","from"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/centroid.js"],"sourcesContent":["import {geoCentroid as GeoCentroid, geoPath} from \"d3\";\nimport {memoize1} from \"../memoize.js\";\nimport {identity, valueof} from \"../options.js\";\nimport {initializer} from \"./basic.js\";\n\nexport function centroid({geometry = identity, ...options} = {}) {\n  const getG = memoize1((data) => valueof(data, geometry));\n  return initializer(\n    // Suppress defaults for x and y since they will be computed by the initializer.\n    // Propagate the (memoized) geometry channel in case it’s still needed.\n    {...options, x: null, y: null, geometry: {transform: getG}},\n    (data, facets, channels, scales, dimensions, {projection}) => {\n      const G = getG(data);\n      const n = G.length;\n      const X = new Float64Array(n);\n      const Y = new Float64Array(n);\n      const path = geoPath(projection);\n      for (let i = 0; i < n; ++i) [X[i], Y[i]] = path.centroid(G[i]);\n      return {\n        data,\n        facets,\n        channels: {\n          x: {value: X, scale: projection == null ? \"x\" : null, source: null},\n          y: {value: Y, scale: projection == null ? \"y\" : null, source: null}\n        }\n      };\n    }\n  );\n}\n\nexport function geoCentroid({geometry = identity, ...options} = {}) {\n  const getG = memoize1((data) => valueof(data, geometry));\n  const getC = memoize1((data) => valueof(getG(data), GeoCentroid));\n  return {\n    ...options,\n    x: {transform: (data) => Float64Array.from(getC(data), ([x]) => x)},\n    y: {transform: (data) => Float64Array.from(getC(data), ([, y]) => y)},\n    geometry: {transform: getG}\n  };\n}\n"],"mappings":";;;AAAA,SAAQA,WAAW,IAAIC,WAAW,EAAEC,OAAO,QAAO,IAAI;AACtD,SAAQC,QAAQ,QAAO,eAAe;AACtC,SAAQC,QAAQ,EAAEC,OAAO,QAAO,eAAe;AAC/C,SAAQC,WAAW,QAAO,YAAY;AAEtC,OAAO,SAASC,QAAQA,CAAC;EAACC,QAAQ,GAAGJ,QAAQ;EAAE,GAAGK;AAAO,CAAC,GAAG,CAAC,CAAC,EAAE;EAC/D,MAAMC,IAAI,GAAGP,QAAQ,CAAEQ,IAAI,IAAKN,OAAO,CAACM,IAAI,EAAEH,QAAQ,CAAC,CAAC;EACxD,OAAOF,WAAW;EAChB;EACA;EACA;IAAC,GAAGG,OAAO;IAAEG,CAAC,EAAE,IAAI;IAAEC,CAAC,EAAE,IAAI;IAAEL,QAAQ,EAAE;MAACM,SAAS,EAAEJ;IAAI;EAAC,CAAC,EAC3D,CAACC,IAAI,EAAEI,MAAM,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,UAAU,EAAE;IAACC;EAAU,CAAC,KAAK;IAC5D,MAAMC,CAAC,GAAGV,IAAI,CAACC,IAAI,CAAC;IACpB,MAAMU,CAAC,GAAGD,CAAC,CAACE,MAAM;IAClB,MAAMC,CAAC,GAAG,IAAIC,YAAY,CAACH,CAAC,CAAC;IAC7B,MAAMI,CAAC,GAAG,IAAID,YAAY,CAACH,CAAC,CAAC;IAC7B,MAAMK,IAAI,GAAGxB,OAAO,CAACiB,UAAU,CAAC;IAChC,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,EAAE,EAAEM,CAAC,EAAE,CAACJ,CAAC,CAACI,CAAC,CAAC,EAAEF,CAAC,CAACE,CAAC,CAAC,CAAC,GAAGD,IAAI,CAACnB,QAAQ,CAACa,CAAC,CAACO,CAAC,CAAC,CAAC;IAC9D,OAAO;MACLhB,IAAI;MACJI,MAAM;MACNC,QAAQ,EAAE;QACRJ,CAAC,EAAE;UAACgB,KAAK,EAAEL,CAAC;UAAEM,KAAK,EAAEV,UAAU,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI;UAAEW,MAAM,EAAE;QAAI,CAAC;QACnEjB,CAAC,EAAE;UAACe,KAAK,EAAEH,CAAC;UAAEI,KAAK,EAAEV,UAAU,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI;UAAEW,MAAM,EAAE;QAAI;MACpE;IACF,CAAC;EACH,CACF,CAAC;AACH;AAEA,OAAO,SAAS9B,WAAWA,CAAC;EAACQ,QAAQ,GAAGJ,QAAQ;EAAE,GAAGK;AAAO,CAAC,GAAG,CAAC,CAAC,EAAE;EAClE,MAAMC,IAAI,GAAGP,QAAQ,CAAEQ,IAAI,IAAKN,OAAO,CAACM,IAAI,EAAEH,QAAQ,CAAC,CAAC;EACxD,MAAMuB,IAAI,GAAG5B,QAAQ,CAAEQ,IAAI,IAAKN,OAAO,CAACK,IAAI,CAACC,IAAI,CAAC,EAAEV,WAAW,CAAC,CAAC;EACjE,OAAO;IACL,GAAGQ,OAAO;IACVG,CAAC,EAAE;MAACE,SAAS,EAAGH,IAAI,IAAKa,YAAY,CAACQ,IAAI,CAACD,IAAI,CAACpB,IAAI,CAAC,EAAE,CAAC,CAACC,CAAC,CAAC,KAAKA,CAAC;IAAC,CAAC;IACnEC,CAAC,EAAE;MAACC,SAAS,EAAGH,IAAI,IAAKa,YAAY,CAACQ,IAAI,CAACD,IAAI,CAACpB,IAAI,CAAC,EAAE,CAAC,GAAGE,CAAC,CAAC,KAAKA,CAAC;IAAC,CAAC;IACrEL,QAAQ,EAAE;MAACM,SAAS,EAAEJ;IAAI;EAC5B,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}