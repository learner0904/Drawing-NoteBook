{"ast":null,"code":"import { descending, interpolateNumber, interpolateRgb, piecewise, scaleDiverging, scaleDivergingLog, scaleDivergingPow, scaleDivergingSymlog } from \"d3\";\nimport { negative, positive } from \"../defined.js\";\nimport { arrayify } from \"../options.js\";\nimport { warn } from \"../warnings.js\";\nimport { color, registry } from \"./index.js\";\nimport { flip, inferDomain, interpolatePiecewise, maybeInterpolator } from \"./quantitative.js\";\nimport { quantitativeScheme } from \"./schemes.js\";\nfunction createScaleD(key, scale, transform, channels, {\n  type,\n  nice,\n  clamp,\n  domain = inferDomain(channels),\n  unknown,\n  pivot = 0,\n  scheme,\n  range,\n  symmetric = true,\n  interpolate = registry.get(key) === color ? scheme == null && range !== undefined ? interpolateRgb : quantitativeScheme(scheme !== undefined ? scheme : \"rdbu\") : interpolateNumber,\n  reverse\n}) {\n  pivot = +pivot;\n  domain = arrayify(domain);\n  let [min, max] = domain;\n  if (domain.length > 2) warn(`Warning: the diverging ${key} scale domain contains extra elements.`);\n  if (descending(min, max) < 0) [min, max] = [max, min], reverse = !reverse;\n  min = Math.min(min, pivot);\n  max = Math.max(max, pivot);\n\n  // Sometimes interpolate is a named interpolator, such as \"lab\" for Lab color\n  // space. Other times interpolate is a function that takes two arguments and\n  // is used in conjunction with the range. And other times the interpolate\n  // function is a “fixed” interpolator on the [0, 1] interval, as when a\n  // color scheme such as interpolateRdBu is used.\n  if (typeof interpolate !== \"function\") {\n    interpolate = maybeInterpolator(interpolate);\n  }\n\n  // If an explicit range is specified, promote it to a piecewise interpolator.\n  if (range !== undefined) {\n    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range) : piecewise(interpolate, range);\n  }\n\n  // Reverse before normalization.\n  if (reverse) interpolate = flip(interpolate);\n\n  // Normalize the interpolator for symmetric difference around the pivot.\n  if (symmetric) {\n    const mid = transform.apply(pivot);\n    const mindelta = mid - transform.apply(min);\n    const maxdelta = transform.apply(max) - mid;\n    if (mindelta < maxdelta) min = transform.invert(mid - maxdelta);else if (mindelta > maxdelta) max = transform.invert(mid + mindelta);\n  }\n  scale.domain([min, pivot, max]).unknown(unknown).interpolator(interpolate);\n  if (clamp) scale.clamp(clamp);\n  if (nice) scale.nice(nice);\n  return {\n    type,\n    domain: [min, max],\n    pivot,\n    interpolate,\n    scale\n  };\n}\nexport function createScaleDiverging(key, channels, options) {\n  return createScaleD(key, scaleDiverging(), transformIdentity, channels, options);\n}\nexport function createScaleDivergingSqrt(key, channels, options) {\n  return createScaleDivergingPow(key, channels, {\n    ...options,\n    exponent: 0.5\n  });\n}\nexport function createScaleDivergingPow(key, channels, {\n  exponent = 1,\n  ...options\n}) {\n  return createScaleD(key, scaleDivergingPow().exponent(exponent = +exponent), transformPow(exponent), channels, {\n    ...options,\n    type: \"diverging-pow\"\n  });\n}\nexport function createScaleDivergingLog(key, channels, {\n  base = 10,\n  pivot = 1,\n  domain = inferDomain(channels, pivot < 0 ? negative : positive),\n  ...options\n}) {\n  return createScaleD(key, scaleDivergingLog().base(base = +base), transformLog, channels, {\n    domain,\n    pivot,\n    ...options\n  });\n}\nexport function createScaleDivergingSymlog(key, channels, {\n  constant = 1,\n  ...options\n}) {\n  return createScaleD(key, scaleDivergingSymlog().constant(constant = +constant), transformSymlog(constant), channels, options);\n}\nconst transformIdentity = {\n  apply(x) {\n    return x;\n  },\n  invert(x) {\n    return x;\n  }\n};\nconst transformLog = {\n  apply: Math.log,\n  invert: Math.exp\n};\nconst transformSqrt = {\n  apply(x) {\n    return Math.sign(x) * Math.sqrt(Math.abs(x));\n  },\n  invert(x) {\n    return Math.sign(x) * (x * x);\n  }\n};\nfunction transformPow(exponent) {\n  return exponent === 0.5 ? transformSqrt : {\n    apply(x) {\n      return Math.sign(x) * Math.pow(Math.abs(x), exponent);\n    },\n    invert(x) {\n      return Math.sign(x) * Math.pow(Math.abs(x), 1 / exponent);\n    }\n  };\n}\nfunction transformSymlog(constant) {\n  return {\n    apply(x) {\n      return Math.sign(x) * Math.log1p(Math.abs(x / constant));\n    },\n    invert(x) {\n      return Math.sign(x) * Math.expm1(Math.abs(x)) * constant;\n    }\n  };\n}","map":{"version":3,"names":["descending","interpolateNumber","interpolateRgb","piecewise","scaleDiverging","scaleDivergingLog","scaleDivergingPow","scaleDivergingSymlog","negative","positive","arrayify","warn","color","registry","flip","inferDomain","interpolatePiecewise","maybeInterpolator","quantitativeScheme","createScaleD","key","scale","transform","channels","type","nice","clamp","domain","unknown","pivot","scheme","range","symmetric","interpolate","get","undefined","reverse","min","max","length","Math","mid","apply","mindelta","maxdelta","invert","interpolator","createScaleDiverging","options","transformIdentity","createScaleDivergingSqrt","createScaleDivergingPow","exponent","transformPow","createScaleDivergingLog","base","transformLog","createScaleDivergingSymlog","constant","transformSymlog","x","log","exp","transformSqrt","sign","sqrt","abs","pow","log1p","expm1"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/scales/diverging.js"],"sourcesContent":["import {\n  descending,\n  interpolateNumber,\n  interpolateRgb,\n  piecewise,\n  scaleDiverging,\n  scaleDivergingLog,\n  scaleDivergingPow,\n  scaleDivergingSymlog\n} from \"d3\";\nimport {negative, positive} from \"../defined.js\";\nimport {arrayify} from \"../options.js\";\nimport {warn} from \"../warnings.js\";\nimport {color, registry} from \"./index.js\";\nimport {flip, inferDomain, interpolatePiecewise, maybeInterpolator} from \"./quantitative.js\";\nimport {quantitativeScheme} from \"./schemes.js\";\n\nfunction createScaleD(\n  key,\n  scale,\n  transform,\n  channels,\n  {\n    type,\n    nice,\n    clamp,\n    domain = inferDomain(channels),\n    unknown,\n    pivot = 0,\n    scheme,\n    range,\n    symmetric = true,\n    interpolate = registry.get(key) === color\n      ? scheme == null && range !== undefined\n        ? interpolateRgb\n        : quantitativeScheme(scheme !== undefined ? scheme : \"rdbu\")\n      : interpolateNumber,\n    reverse\n  }\n) {\n  pivot = +pivot;\n  domain = arrayify(domain);\n  let [min, max] = domain;\n  if (domain.length > 2) warn(`Warning: the diverging ${key} scale domain contains extra elements.`);\n\n  if (descending(min, max) < 0) ([min, max] = [max, min]), (reverse = !reverse);\n  min = Math.min(min, pivot);\n  max = Math.max(max, pivot);\n\n  // Sometimes interpolate is a named interpolator, such as \"lab\" for Lab color\n  // space. Other times interpolate is a function that takes two arguments and\n  // is used in conjunction with the range. And other times the interpolate\n  // function is a “fixed” interpolator on the [0, 1] interval, as when a\n  // color scheme such as interpolateRdBu is used.\n  if (typeof interpolate !== \"function\") {\n    interpolate = maybeInterpolator(interpolate);\n  }\n\n  // If an explicit range is specified, promote it to a piecewise interpolator.\n  if (range !== undefined) {\n    interpolate =\n      interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range) : piecewise(interpolate, range);\n  }\n\n  // Reverse before normalization.\n  if (reverse) interpolate = flip(interpolate);\n\n  // Normalize the interpolator for symmetric difference around the pivot.\n  if (symmetric) {\n    const mid = transform.apply(pivot);\n    const mindelta = mid - transform.apply(min);\n    const maxdelta = transform.apply(max) - mid;\n    if (mindelta < maxdelta) min = transform.invert(mid - maxdelta);\n    else if (mindelta > maxdelta) max = transform.invert(mid + mindelta);\n  }\n\n  scale.domain([min, pivot, max]).unknown(unknown).interpolator(interpolate);\n  if (clamp) scale.clamp(clamp);\n  if (nice) scale.nice(nice);\n  return {type, domain: [min, max], pivot, interpolate, scale};\n}\n\nexport function createScaleDiverging(key, channels, options) {\n  return createScaleD(key, scaleDiverging(), transformIdentity, channels, options);\n}\n\nexport function createScaleDivergingSqrt(key, channels, options) {\n  return createScaleDivergingPow(key, channels, {...options, exponent: 0.5});\n}\n\nexport function createScaleDivergingPow(key, channels, {exponent = 1, ...options}) {\n  return createScaleD(key, scaleDivergingPow().exponent((exponent = +exponent)), transformPow(exponent), channels, {\n    ...options,\n    type: \"diverging-pow\"\n  });\n}\n\nexport function createScaleDivergingLog(\n  key,\n  channels,\n  {base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options}\n) {\n  return createScaleD(key, scaleDivergingLog().base((base = +base)), transformLog, channels, {\n    domain,\n    pivot,\n    ...options\n  });\n}\n\nexport function createScaleDivergingSymlog(key, channels, {constant = 1, ...options}) {\n  return createScaleD(\n    key,\n    scaleDivergingSymlog().constant((constant = +constant)),\n    transformSymlog(constant),\n    channels,\n    options\n  );\n}\n\nconst transformIdentity = {\n  apply(x) {\n    return x;\n  },\n  invert(x) {\n    return x;\n  }\n};\n\nconst transformLog = {\n  apply: Math.log,\n  invert: Math.exp\n};\n\nconst transformSqrt = {\n  apply(x) {\n    return Math.sign(x) * Math.sqrt(Math.abs(x));\n  },\n  invert(x) {\n    return Math.sign(x) * (x * x);\n  }\n};\n\nfunction transformPow(exponent) {\n  return exponent === 0.5\n    ? transformSqrt\n    : {\n        apply(x) {\n          return Math.sign(x) * Math.pow(Math.abs(x), exponent);\n        },\n        invert(x) {\n          return Math.sign(x) * Math.pow(Math.abs(x), 1 / exponent);\n        }\n      };\n}\n\nfunction transformSymlog(constant) {\n  return {\n    apply(x) {\n      return Math.sign(x) * Math.log1p(Math.abs(x / constant));\n    },\n    invert(x) {\n      return Math.sign(x) * Math.expm1(Math.abs(x)) * constant;\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}