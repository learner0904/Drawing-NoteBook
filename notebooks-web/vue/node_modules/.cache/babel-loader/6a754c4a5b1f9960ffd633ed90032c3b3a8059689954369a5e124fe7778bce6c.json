{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { quantile, range as rangei } from \"d3\";\nimport { parse as isoParse } from \"isoformat\";\nimport { defined } from \"./defined.js\";\nimport { timeInterval, utcInterval } from \"./time.js\";\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\nexport const TypedArray = Object.getPrototypeOf(Uint8Array);\nconst objectToString = Object.prototype.toString;\nexport function isArray(value) {\n  return value instanceof Array || value instanceof TypedArray;\n}\nfunction isNumberArray(value) {\n  return value instanceof TypedArray && !isBigIntArray(value);\n}\nfunction isNumberType(type) {\n  return type?.prototype instanceof TypedArray && !isBigIntType(type);\n}\nfunction isBigIntArray(value) {\n  return value instanceof BigInt64Array || value instanceof BigUint64Array;\n}\nfunction isBigIntType(type) {\n  return type === BigInt64Array || type === BigUint64Array;\n}\n\n// If a reindex is attached to the data, channel values expressed as arrays will\n// be reindexed when the channels are instantiated. See exclusiveFacets.\nexport const reindex = Symbol(\"reindex\");\nexport function valueof(data, value, type) {\n  const valueType = typeof value;\n  return valueType === \"string\" ? isArrowTable(data) ? maybeTypedArrowify(data.getChild(value), type) : maybeTypedMap(data, field(value), type) : valueType === \"function\" ? maybeTypedMap(data, value, type) : valueType === \"number\" || value instanceof Date || valueType === \"boolean\" ? map(data, constant(value), type) : typeof value?.transform === \"function\" ? maybeTypedArrayify(value.transform(data), type) : maybeTake(maybeTypedArrayify(value, type), data?.[reindex]);\n}\nfunction maybeTake(values, index) {\n  return values != null && index ? take(values, index) : values;\n}\nfunction maybeTypedMap(data, f, type) {\n  return map(data, isNumberType(type) ? (d, i) => coerceNumber(f(d, i)) : f, type); // allow conversion from BigInt\n}\n\nfunction maybeTypedArrayify(data, type) {\n  return type === undefined ? arrayify(data) // preserve undefined type\n  : isArrowVector(data) ? maybeTypedArrowify(data, type) : data instanceof type ? data : type.from(data, isNumberType(type) && !isNumberArray(data) ? coerceNumber : undefined);\n}\nfunction maybeTypedArrowify(vector, type) {\n  return vector == null ? vector : (type === undefined || type === Array) && isArrowDateType(vector.type) ? coerceDates(vector.toArray()) : maybeTypedArrayify(vector.toArray(), type);\n}\nexport const singleton = [null]; // for data-less decoration marks, e.g. frame\nexport const field = name => d => {\n  const v = d[name];\n  return v === undefined && d.type === \"Feature\" ? d.properties?.[name] : v;\n}; // prettier-ignore\nexport const indexOf = {\n  transform: range\n};\nexport const identity = {\n  transform: d => d\n};\nexport const zero = () => 0;\nexport const one = () => 1;\nexport const yes = () => true;\nexport const string = x => x == null ? x : `${x}`;\nexport const number = x => x == null ? x : +x;\nexport const boolean = x => x == null ? x : !!x;\nexport const first = x => x ? x[0] : undefined;\nexport const second = x => x ? x[1] : undefined;\nexport const third = x => x ? x[2] : undefined;\nexport const constant = x => () => x;\n\n// Converts a string like “p25” into a function that takes an index I and an\n// accessor function f, returning the corresponding percentile value.\nexport function percentile(reduce) {\n  const p = +`${reduce}`.slice(1) / 100;\n  return (I, f) => quantile(I, p, f);\n}\n\n// If the values are specified as a typed array, no coercion is required.\nexport function coerceNumbers(values) {\n  return isNumberArray(values) ? values : map(values, coerceNumber, Float64Array);\n}\n\n// Unlike Mark’s number, here we want to convert null and undefined to NaN since\n// the result will be stored in a Float64Array and we don’t want null to be\n// coerced to zero. We use Number instead of unary + to allow BigInt coercion.\nfunction coerceNumber(x) {\n  return x == null ? NaN : Number(x);\n}\nexport function coerceDates(values) {\n  return map(values, coerceDate);\n}\n\n// When coercing strings to dates, we only want to allow the ISO 8601 format\n// since the built-in string parsing of the Date constructor varies across\n// browsers. (In the future, this could be made more liberal if desired, though\n// it is still generally preferable to do date parsing yourself explicitly,\n// rather than rely on Plot.) Any non-string values are coerced to number first\n// and treated as milliseconds since UNIX epoch.\nexport function coerceDate(x) {\n  return x instanceof Date && !isNaN(x) ? x : typeof x === \"string\" ? isoParse(x) : x == null || isNaN(x = Number(x)) // allow conversion from BigInt\n  ? undefined : new Date(x);\n}\n\n// Some channels may allow a string constant to be specified; to differentiate\n// string constants (e.g., \"red\") from named fields (e.g., \"date\"), this\n// function tests whether the given value is a CSS color string and returns a\n// tuple [channel, constant] where one of the two is undefined, and the other is\n// the given value. If you wish to reference a named field that is also a valid\n// CSS color, use an accessor (d => d.red) instead.\nexport function maybeColorChannel(value, defaultValue) {\n  if (value === undefined) value = defaultValue;\n  return value === null ? [undefined, \"none\"] : isColor(value) ? [undefined, value] : [value, undefined];\n}\n\n// Similar to maybeColorChannel, this tests whether the given value is a number\n// indicating a constant, and otherwise assumes that it’s a channel value.\nexport function maybeNumberChannel(value, defaultValue) {\n  if (value === undefined) value = defaultValue;\n  return value === null || typeof value === \"number\" ? [undefined, value] : [value, undefined];\n}\n\n// Validates the specified optional string against the allowed list of keywords.\nexport function maybeKeyword(input, name, allowed) {\n  if (input != null) return keyword(input, name, allowed);\n}\n\n// Validates the specified required string against the allowed list of keywords.\nexport function keyword(input, name, allowed) {\n  const i = `${input}`.toLowerCase();\n  if (!allowed.includes(i)) throw new Error(`invalid ${name}: ${input}`);\n  return i;\n}\n\n// Like arrayify, but also allows data to be an Apache Arrow Table.\nexport function dataify(data) {\n  return isArrowTable(data) ? data : arrayify(data);\n}\n\n// Promotes the specified data to an array as needed.\nexport function arrayify(values) {\n  if (values == null || isArray(values)) return values;\n  if (isArrowVector(values)) return maybeTypedArrowify(values);\n  switch (values.type) {\n    case \"FeatureCollection\":\n      return values.features;\n    case \"GeometryCollection\":\n      return values.geometries;\n    case \"Feature\":\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"MultiPoint\":\n    case \"MultiPolygon\":\n    case \"Point\":\n    case \"Polygon\":\n    case \"Sphere\":\n      return [values];\n  }\n  return Array.from(values);\n}\n\n// An optimization of type.from(values, f): if the given values are already an\n// instanceof the desired array type, the faster values.map method is used.\nexport function map(values, f, type = Array) {\n  return values == null ? values : values instanceof type ? values.map(f) : type.from(values, f);\n}\n\n// An optimization of type.from(values): if the given values are already an\n// instanceof the desired array type, the faster values.slice method is used.\nexport function slice(values, type = Array) {\n  return values instanceof type ? values.slice() : type.from(values);\n}\n\n// Returns true if any of x, x1, or x2 is not (strictly) undefined.\nexport function hasX({\n  x,\n  x1,\n  x2\n}) {\n  return x !== undefined || x1 !== undefined || x2 !== undefined;\n}\n\n// Returns true if any of y, y1, or y2 is not (strictly) undefined.\nexport function hasY({\n  y,\n  y1,\n  y2\n}) {\n  return y !== undefined || y1 !== undefined || y2 !== undefined;\n}\n\n// Returns true if has x or y, or if interval is not (strictly) undefined.\nexport function hasXY(options) {\n  return hasX(options) || hasY(options) || options.interval !== undefined;\n}\n\n// Disambiguates an options object (e.g., {y: \"x2\"}) from a primitive value.\nexport function isObject(option) {\n  return option?.toString === objectToString;\n}\n\n// Disambiguates a scale options object (e.g., {color: {type: \"linear\"}}) from\n// some other option (e.g., {color: \"red\"}). When creating standalone legends,\n// this is used to test whether a scale is defined; this should be consistent\n// with inferScaleType when there are no channels associated with the scale, and\n// if this returns true, then normalizeScale must return non-null.\nexport function isScaleOptions(option) {\n  return isObject(option) && (option.type !== undefined || option.domain !== undefined);\n}\n\n// Disambiguates an options object (e.g., {y: \"x2\"}) from a channel value\n// definition expressed as a channel transform (e.g., {transform: …}).\n// TODO Check typeof option[Symbol.iterator] !== \"function\"?\nexport function isOptions(option) {\n  return isObject(option) && typeof option.transform !== \"function\";\n}\n\n// Disambiguates a sort transform (e.g., {sort: \"date\"}) from a channel domain\n// sort definition (e.g., {sort: {y: \"x\"}}).\nexport function isDomainSort(sort) {\n  return isOptions(sort) && sort.value === undefined && sort.channel === undefined;\n}\n\n// For marks specified either as [0, x] or [x1, x2], such as areas and bars.\nexport function maybeZero(x, x1, x2, x3 = identity) {\n  if (x1 === undefined && x2 === undefined) {\n    // {x} or {}\n    x1 = 0, x2 = x === undefined ? x3 : x;\n  } else if (x1 === undefined) {\n    // {x, x2} or {x2}\n    x1 = x === undefined ? 0 : x;\n  } else if (x2 === undefined) {\n    // {x, x1} or {x1}\n    x2 = x === undefined ? 0 : x;\n  }\n  return [x1, x2];\n}\n\n// For marks that have x and y channels (e.g., cell, dot, line, text).\nexport function maybeTuple(x, y) {\n  return x === undefined && y === undefined ? [first, second] : [x, y];\n}\n\n// A helper for extracting the z channel, if it is variable. Used by transforms\n// that require series, such as moving average and normalize.\nexport function maybeZ({\n  z,\n  fill,\n  stroke\n} = {}) {\n  if (z === undefined) [z] = maybeColorChannel(fill);\n  if (z === undefined) [z] = maybeColorChannel(stroke);\n  return z;\n}\nexport function lengthof(data) {\n  return isArray(data) ? data.length : data?.numRows;\n}\n\n// Returns a Uint32Array with elements [0, 1, 2, … data.length - 1].\nexport function range(data) {\n  const n = lengthof(data);\n  const r = new Uint32Array(n);\n  for (let i = 0; i < n; ++i) r[i] = i;\n  return r;\n}\n\n// Returns an array [values[index[0]], values[index[1]], …].\nexport function take(values, index) {\n  return isArray(values) ? map(index, i => values[i], values.constructor) : map(index, i => values.at(i));\n}\n\n// If f does not take exactly one argument, wraps it in a function that uses take.\nexport function taker(f) {\n  return f.length === 1 ? (index, values) => f(take(values, index)) : f;\n}\n\n// Uses subarray if available, and otherwise slice.\nexport function subarray(I, i, j) {\n  return I.subarray ? I.subarray(i, j) : I.slice(i, j);\n}\n\n// Based on InternMap (d3.group).\nexport function keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\nexport function maybeInput(key, options) {\n  if (options[key] !== undefined) return options[key];\n  switch (key) {\n    case \"x1\":\n    case \"x2\":\n      key = \"x\";\n      break;\n    case \"y1\":\n    case \"y2\":\n      key = \"y\";\n      break;\n  }\n  return options[key];\n}\nexport function column(source) {\n  // Defines a column whose values are lazily populated by calling the returned\n  // setter. If the given source is labeled, the label is propagated to the\n  // returned column definition.\n  let value;\n  return [{\n    transform: () => value,\n    label: labelof(source)\n  }, v => value = v];\n}\n\n// Like column, but allows the source to be null.\nexport function maybeColumn(source) {\n  return source == null ? [source] : column(source);\n}\nexport function labelof(value, defaultValue) {\n  return typeof value === \"string\" ? value : value && value.label !== undefined ? value.label : defaultValue;\n}\n\n// Assuming that both x1 and x2 and lazy columns (per above), this derives a new\n// a column that’s the average of the two, and which inherits the column label\n// (if any). Both input columns are assumed to be quantitative. If either column\n// is temporal, the returned column is also temporal.\nexport function mid(x1, x2) {\n  return {\n    transform(data) {\n      const X1 = x1.transform(data);\n      const X2 = x2.transform(data);\n      return isTemporal(X1) || isTemporal(X2) ? map(X1, (_, i) => new Date((+X1[i] + +X2[i]) / 2)) : map(X1, (_, i) => (+X1[i] + +X2[i]) / 2, Float64Array);\n    },\n    label: x1.label\n  };\n}\n\n// If the scale options declare an interval, applies it to the values V.\nexport function maybeApplyInterval(V, scale) {\n  const t = maybeIntervalTransform(scale?.interval, scale?.type);\n  return t ? map(V, t) : V;\n}\n\n// Returns the equivalent scale transform for the specified interval option.\nexport function maybeIntervalTransform(interval, type) {\n  const i = maybeInterval(interval, type);\n  return i && (v => defined(v) ? i.floor(v) : v);\n}\n\n// If interval is not nullish, converts interval shorthand such as a number (for\n// multiples) or a time interval name (such as “day”) to a {floor, offset,\n// range} object similar to a D3 time interval.\nexport function maybeInterval(interval, type) {\n  if (interval == null) return;\n  if (typeof interval === \"number\") return numberInterval(interval);\n  if (typeof interval === \"string\") return (type === \"time\" ? timeInterval : utcInterval)(interval);\n  if (typeof interval.floor !== \"function\") throw new Error(\"invalid interval; missing floor method\");\n  if (typeof interval.offset !== \"function\") throw new Error(\"invalid interval; missing offset method\");\n  return interval;\n}\nexport function numberInterval(interval) {\n  interval = +interval;\n  if (0 < interval && interval < 1 && Number.isInteger(1 / interval)) interval = -1 / interval;\n  const n = Math.abs(interval);\n  return interval < 0 ? {\n    floor: d => Math.floor(d * n) / n,\n    offset: (d, s = 1) => (d * n + Math.floor(s)) / n,\n    range: (lo, hi) => rangei(Math.ceil(lo * n), hi * n).map(x => x / n)\n  } : {\n    floor: d => Math.floor(d / n) * n,\n    offset: (d, s = 1) => d + n * Math.floor(s),\n    range: (lo, hi) => rangei(Math.ceil(lo / n), hi / n).map(x => x * n)\n  };\n}\n\n// Like maybeInterval, but requires a range method too.\nexport function maybeRangeInterval(interval, type) {\n  interval = maybeInterval(interval, type);\n  if (interval && typeof interval.range !== \"function\") throw new Error(\"invalid interval: missing range method\");\n  return interval;\n}\n\n// Like maybeRangeInterval, but requires a ceil method too.\nexport function maybeNiceInterval(interval, type) {\n  interval = maybeRangeInterval(interval, type);\n  if (interval && typeof interval.ceil !== \"function\") throw new Error(\"invalid interval: missing ceil method\");\n  return interval;\n}\nexport function isTimeInterval(t) {\n  return isInterval(t) && typeof t?.floor === \"function\" && t.floor() instanceof Date;\n}\nexport function isInterval(t) {\n  return typeof t?.range === \"function\";\n}\n\n// This distinguishes between per-dimension options and a standalone value.\nexport function maybeValue(value) {\n  return value === undefined || isOptions(value) ? value : {\n    value\n  };\n}\n\n// Coerces the given channel values (if any) to numbers. This is useful when\n// values will be interpolated into other code, such as an SVG transform, and\n// where we don’t wish to allow unexpected behavior for weird input.\nexport function numberChannel(source) {\n  return source == null ? null : {\n    transform: data => valueof(data, source, Float64Array),\n    label: labelof(source)\n  };\n}\nexport function isTuples(data) {\n  if (!isIterable(data)) return false;\n  for (const d of data) {\n    if (d == null) continue;\n    return typeof d === \"object\" && \"0\" in d && \"1\" in d;\n  }\n}\nexport function isIterable(value) {\n  return value && typeof value[Symbol.iterator] === \"function\";\n}\nexport function isTextual(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value !== \"object\" || value instanceof Date;\n  }\n}\nexport function isOrdinal(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    const type = typeof value;\n    return type === \"string\" || type === \"boolean\";\n  }\n}\nexport function isTemporal(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return value instanceof Date;\n  }\n}\n\n// Are these strings that might represent dates? This is stricter than ISO 8601\n// because we want to ignore false positives on numbers; for example, the string\n// \"1192\" is more likely to represent a number than a date even though it is\n// valid ISO 8601 representing 1192-01-01.\nexport function isTemporalString(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value === \"string\" && isNaN(value) && isoParse(value);\n  }\n}\n\n// Are these strings that might represent numbers? This is stricter than\n// coercion because we want to ignore false positives on e.g. empty strings.\nexport function isNumericString(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    if (typeof value !== \"string\") return false;\n    if (!value.trim()) continue;\n    return !isNaN(value);\n  }\n}\nexport function isNumeric(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value === \"number\";\n  }\n}\n\n// Returns true if every non-null value in the specified iterable of values\n// passes the specified predicate, and there is at least one non-null value;\n// returns false if at least one non-null value does not pass the specified\n// predicate; otherwise returns undefined (as if all values are null).\nexport function isEvery(values, is) {\n  let every;\n  for (const value of values) {\n    if (value == null) continue;\n    if (!is(value)) return false;\n    every = true;\n  }\n  return every;\n}\nconst namedColors = new Set(\"none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow\".split(\",\")); // prettier-ignore\n\n// Returns true if value is a valid CSS color string. This is intentionally lax\n// because the CSS color spec keeps growing, and we don’t need to parse these\n// colors—we just need to disambiguate them from column names.\n// https://www.w3.org/TR/SVG11/painting.html#SpecifyingPaint\n// https://www.w3.org/TR/css-color-5/\nexport function isColor(value) {\n  if (typeof value !== \"string\") return false;\n  value = value.toLowerCase().trim();\n  return /^#[0-9a-f]{3,8}$/.test(value) ||\n  // hex rgb, rgba, rrggbb, rrggbbaa\n  /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\\(.*\\)$/.test(value) ||\n  // <funciri>, CSS variable, color, etc.\n  namedColors.has(value) // currentColor, red, etc.\n  ;\n}\n\nexport function isOpacity(value) {\n  return typeof value === \"number\" && (0 <= value && value <= 1 || isNaN(value));\n}\nexport function isNoneish(value) {\n  return value == null || isNone(value);\n}\nexport function isNone(value) {\n  return /^\\s*none\\s*$/i.test(value);\n}\nexport function isRound(value) {\n  return /^\\s*round\\s*$/i.test(value);\n}\nexport function maybeAnchor(value, name) {\n  return maybeKeyword(value, name, [\"middle\", \"top-left\", \"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\"]);\n}\nexport function maybeFrameAnchor(value = \"middle\") {\n  return maybeAnchor(value, \"frameAnchor\");\n}\n\n// Unlike {...defaults, ...options}, this ensures that any undefined (but\n// present) properties in options inherit the given default value.\nexport function inherit(options = {}, ...rest) {\n  let o = options;\n  for (const defaults of rest) {\n    for (const key in defaults) {\n      if (o[key] === undefined) {\n        const value = defaults[key];\n        if (o === options) o = {\n          ...o,\n          [key]: value\n        };else o[key] = value;\n      }\n    }\n  }\n  return o;\n}\n\n// Given an iterable of named things (objects with a name property), returns a\n// corresponding object with properties associated with the given name.\nexport function named(things) {\n  console.warn(\"named iterables are deprecated; please use an object instead\");\n  const names = new Set();\n  return Object.fromEntries(Array.from(things, thing => {\n    const {\n      name\n    } = thing;\n    if (name == null) throw new Error(\"missing name\");\n    const key = `${name}`;\n    if (key === \"__proto__\") throw new Error(`illegal name: ${key}`);\n    if (names.has(key)) throw new Error(`duplicate name: ${key}`);\n    names.add(key);\n    return [name, thing];\n  }));\n}\nexport function maybeNamed(things) {\n  return isIterable(things) ? named(things) : things;\n}\n\n// TODO Accept other types of clips (paths, urls, x, y, other marks…)?\n// https://github.com/observablehq/plot/issues/181\nexport function maybeClip(clip) {\n  if (clip === true) clip = \"frame\";else if (clip === false) clip = null;else if (clip != null) clip = keyword(clip, \"clip\", [\"frame\", \"sphere\"]);\n  return clip;\n}\n\n// https://github.com/observablehq/stdlib/blob/746ca2e69135df6178e4f3a17244def35d8d6b20/src/arrow.js#L4C1-L17C1\nfunction isArrowTable(value) {\n  return value && typeof value.getChild === \"function\" && typeof value.toArray === \"function\" && value.schema && Array.isArray(value.schema.fields);\n}\nfunction isArrowVector(value) {\n  return value && typeof value.toArray === \"function\" && value.type;\n}\n\n// Apache Arrow now represents dates as numbers. We currently only support\n// implicit coercion to JavaScript Date objects when the numbers represent\n// milliseconds since Unix epoch.\nfunction isArrowDateType(type) {\n  return type && (type.typeId === 8 ||\n  // date\n  type.typeId === 10) &&\n  // timestamp\n  type.unit === 1 // millisecond\n  ;\n}","map":{"version":3,"names":["quantile","range","rangei","parse","isoParse","defined","timeInterval","utcInterval","TypedArray","Object","getPrototypeOf","Uint8Array","objectToString","prototype","toString","isArray","value","Array","isNumberArray","isBigIntArray","isNumberType","type","isBigIntType","BigInt64Array","BigUint64Array","reindex","Symbol","valueof","data","valueType","isArrowTable","maybeTypedArrowify","getChild","maybeTypedMap","field","Date","map","constant","transform","maybeTypedArrayify","maybeTake","values","index","take","f","d","i","coerceNumber","undefined","arrayify","isArrowVector","from","vector","isArrowDateType","coerceDates","toArray","singleton","name","v","properties","indexOf","identity","zero","one","yes","string","x","number","boolean","first","second","third","percentile","reduce","p","slice","I","coerceNumbers","Float64Array","NaN","Number","coerceDate","isNaN","maybeColorChannel","defaultValue","isColor","maybeNumberChannel","maybeKeyword","input","allowed","keyword","toLowerCase","includes","Error","dataify","features","geometries","hasX","x1","x2","hasY","y","y1","y2","hasXY","options","interval","isObject","option","isScaleOptions","domain","isOptions","isDomainSort","sort","channel","maybeZero","x3","maybeTuple","maybeZ","z","fill","stroke","lengthof","length","numRows","n","r","Uint32Array","constructor","at","taker","subarray","j","keyof","valueOf","maybeInput","key","column","source","label","labelof","maybeColumn","mid","X1","X2","isTemporal","_","maybeApplyInterval","V","scale","t","maybeIntervalTransform","maybeInterval","floor","numberInterval","offset","isInteger","Math","abs","s","lo","hi","ceil","maybeRangeInterval","maybeNiceInterval","isTimeInterval","isInterval","maybeValue","numberChannel","isTuples","isIterable","iterator","isTextual","isOrdinal","isTemporalString","isNumericString","trim","isNumeric","isEvery","is","every","namedColors","Set","split","test","has","isOpacity","isNoneish","isNone","isRound","maybeAnchor","maybeFrameAnchor","inherit","rest","o","defaults","named","things","console","warn","names","fromEntries","thing","add","maybeNamed","maybeClip","clip","schema","fields","typeId","unit"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/options.js"],"sourcesContent":["import {quantile, range as rangei} from \"d3\";\nimport {parse as isoParse} from \"isoformat\";\nimport {defined} from \"./defined.js\";\nimport {timeInterval, utcInterval} from \"./time.js\";\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\nexport const TypedArray = Object.getPrototypeOf(Uint8Array);\nconst objectToString = Object.prototype.toString;\n\nexport function isArray(value) {\n  return value instanceof Array || value instanceof TypedArray;\n}\n\nfunction isNumberArray(value) {\n  return value instanceof TypedArray && !isBigIntArray(value);\n}\n\nfunction isNumberType(type) {\n  return type?.prototype instanceof TypedArray && !isBigIntType(type);\n}\n\nfunction isBigIntArray(value) {\n  return value instanceof BigInt64Array || value instanceof BigUint64Array;\n}\n\nfunction isBigIntType(type) {\n  return type === BigInt64Array || type === BigUint64Array;\n}\n\n// If a reindex is attached to the data, channel values expressed as arrays will\n// be reindexed when the channels are instantiated. See exclusiveFacets.\nexport const reindex = Symbol(\"reindex\");\n\nexport function valueof(data, value, type) {\n  const valueType = typeof value;\n  return valueType === \"string\"\n    ? isArrowTable(data)\n      ? maybeTypedArrowify(data.getChild(value), type)\n      : maybeTypedMap(data, field(value), type)\n    : valueType === \"function\"\n    ? maybeTypedMap(data, value, type)\n    : valueType === \"number\" || value instanceof Date || valueType === \"boolean\"\n    ? map(data, constant(value), type)\n    : typeof value?.transform === \"function\"\n    ? maybeTypedArrayify(value.transform(data), type)\n    : maybeTake(maybeTypedArrayify(value, type), data?.[reindex]);\n}\n\nfunction maybeTake(values, index) {\n  return values != null && index ? take(values, index) : values;\n}\n\nfunction maybeTypedMap(data, f, type) {\n  return map(data, isNumberType(type) ? (d, i) => coerceNumber(f(d, i)) : f, type); // allow conversion from BigInt\n}\n\nfunction maybeTypedArrayify(data, type) {\n  return type === undefined\n    ? arrayify(data) // preserve undefined type\n    : isArrowVector(data)\n    ? maybeTypedArrowify(data, type)\n    : data instanceof type\n    ? data\n    : type.from(data, isNumberType(type) && !isNumberArray(data) ? coerceNumber : undefined);\n}\n\nfunction maybeTypedArrowify(vector, type) {\n  return vector == null\n    ? vector\n    : (type === undefined || type === Array) && isArrowDateType(vector.type)\n    ? coerceDates(vector.toArray())\n    : maybeTypedArrayify(vector.toArray(), type);\n}\n\nexport const singleton = [null]; // for data-less decoration marks, e.g. frame\nexport const field = (name) => (d) => { const v = d[name]; return v === undefined && d.type === \"Feature\" ? d.properties?.[name] : v; }; // prettier-ignore\nexport const indexOf = {transform: range};\nexport const identity = {transform: (d) => d};\nexport const zero = () => 0;\nexport const one = () => 1;\nexport const yes = () => true;\nexport const string = (x) => (x == null ? x : `${x}`);\nexport const number = (x) => (x == null ? x : +x);\nexport const boolean = (x) => (x == null ? x : !!x);\nexport const first = (x) => (x ? x[0] : undefined);\nexport const second = (x) => (x ? x[1] : undefined);\nexport const third = (x) => (x ? x[2] : undefined);\nexport const constant = (x) => () => x;\n\n// Converts a string like “p25” into a function that takes an index I and an\n// accessor function f, returning the corresponding percentile value.\nexport function percentile(reduce) {\n  const p = +`${reduce}`.slice(1) / 100;\n  return (I, f) => quantile(I, p, f);\n}\n\n// If the values are specified as a typed array, no coercion is required.\nexport function coerceNumbers(values) {\n  return isNumberArray(values) ? values : map(values, coerceNumber, Float64Array);\n}\n\n// Unlike Mark’s number, here we want to convert null and undefined to NaN since\n// the result will be stored in a Float64Array and we don’t want null to be\n// coerced to zero. We use Number instead of unary + to allow BigInt coercion.\nfunction coerceNumber(x) {\n  return x == null ? NaN : Number(x);\n}\n\nexport function coerceDates(values) {\n  return map(values, coerceDate);\n}\n\n// When coercing strings to dates, we only want to allow the ISO 8601 format\n// since the built-in string parsing of the Date constructor varies across\n// browsers. (In the future, this could be made more liberal if desired, though\n// it is still generally preferable to do date parsing yourself explicitly,\n// rather than rely on Plot.) Any non-string values are coerced to number first\n// and treated as milliseconds since UNIX epoch.\nexport function coerceDate(x) {\n  return x instanceof Date && !isNaN(x)\n    ? x\n    : typeof x === \"string\"\n    ? isoParse(x)\n    : x == null || isNaN((x = Number(x))) // allow conversion from BigInt\n    ? undefined\n    : new Date(x);\n}\n\n// Some channels may allow a string constant to be specified; to differentiate\n// string constants (e.g., \"red\") from named fields (e.g., \"date\"), this\n// function tests whether the given value is a CSS color string and returns a\n// tuple [channel, constant] where one of the two is undefined, and the other is\n// the given value. If you wish to reference a named field that is also a valid\n// CSS color, use an accessor (d => d.red) instead.\nexport function maybeColorChannel(value, defaultValue) {\n  if (value === undefined) value = defaultValue;\n  return value === null ? [undefined, \"none\"] : isColor(value) ? [undefined, value] : [value, undefined];\n}\n\n// Similar to maybeColorChannel, this tests whether the given value is a number\n// indicating a constant, and otherwise assumes that it’s a channel value.\nexport function maybeNumberChannel(value, defaultValue) {\n  if (value === undefined) value = defaultValue;\n  return value === null || typeof value === \"number\" ? [undefined, value] : [value, undefined];\n}\n\n// Validates the specified optional string against the allowed list of keywords.\nexport function maybeKeyword(input, name, allowed) {\n  if (input != null) return keyword(input, name, allowed);\n}\n\n// Validates the specified required string against the allowed list of keywords.\nexport function keyword(input, name, allowed) {\n  const i = `${input}`.toLowerCase();\n  if (!allowed.includes(i)) throw new Error(`invalid ${name}: ${input}`);\n  return i;\n}\n\n// Like arrayify, but also allows data to be an Apache Arrow Table.\nexport function dataify(data) {\n  return isArrowTable(data) ? data : arrayify(data);\n}\n\n// Promotes the specified data to an array as needed.\nexport function arrayify(values) {\n  if (values == null || isArray(values)) return values;\n  if (isArrowVector(values)) return maybeTypedArrowify(values);\n  switch (values.type) {\n    case \"FeatureCollection\":\n      return values.features;\n    case \"GeometryCollection\":\n      return values.geometries;\n    case \"Feature\":\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"MultiPoint\":\n    case \"MultiPolygon\":\n    case \"Point\":\n    case \"Polygon\":\n    case \"Sphere\":\n      return [values];\n  }\n  return Array.from(values);\n}\n\n// An optimization of type.from(values, f): if the given values are already an\n// instanceof the desired array type, the faster values.map method is used.\nexport function map(values, f, type = Array) {\n  return values == null ? values : values instanceof type ? values.map(f) : type.from(values, f);\n}\n\n// An optimization of type.from(values): if the given values are already an\n// instanceof the desired array type, the faster values.slice method is used.\nexport function slice(values, type = Array) {\n  return values instanceof type ? values.slice() : type.from(values);\n}\n\n// Returns true if any of x, x1, or x2 is not (strictly) undefined.\nexport function hasX({x, x1, x2}) {\n  return x !== undefined || x1 !== undefined || x2 !== undefined;\n}\n\n// Returns true if any of y, y1, or y2 is not (strictly) undefined.\nexport function hasY({y, y1, y2}) {\n  return y !== undefined || y1 !== undefined || y2 !== undefined;\n}\n\n// Returns true if has x or y, or if interval is not (strictly) undefined.\nexport function hasXY(options) {\n  return hasX(options) || hasY(options) || options.interval !== undefined;\n}\n\n// Disambiguates an options object (e.g., {y: \"x2\"}) from a primitive value.\nexport function isObject(option) {\n  return option?.toString === objectToString;\n}\n\n// Disambiguates a scale options object (e.g., {color: {type: \"linear\"}}) from\n// some other option (e.g., {color: \"red\"}). When creating standalone legends,\n// this is used to test whether a scale is defined; this should be consistent\n// with inferScaleType when there are no channels associated with the scale, and\n// if this returns true, then normalizeScale must return non-null.\nexport function isScaleOptions(option) {\n  return isObject(option) && (option.type !== undefined || option.domain !== undefined);\n}\n\n// Disambiguates an options object (e.g., {y: \"x2\"}) from a channel value\n// definition expressed as a channel transform (e.g., {transform: …}).\n// TODO Check typeof option[Symbol.iterator] !== \"function\"?\nexport function isOptions(option) {\n  return isObject(option) && typeof option.transform !== \"function\";\n}\n\n// Disambiguates a sort transform (e.g., {sort: \"date\"}) from a channel domain\n// sort definition (e.g., {sort: {y: \"x\"}}).\nexport function isDomainSort(sort) {\n  return isOptions(sort) && sort.value === undefined && sort.channel === undefined;\n}\n\n// For marks specified either as [0, x] or [x1, x2], such as areas and bars.\nexport function maybeZero(x, x1, x2, x3 = identity) {\n  if (x1 === undefined && x2 === undefined) {\n    // {x} or {}\n    (x1 = 0), (x2 = x === undefined ? x3 : x);\n  } else if (x1 === undefined) {\n    // {x, x2} or {x2}\n    x1 = x === undefined ? 0 : x;\n  } else if (x2 === undefined) {\n    // {x, x1} or {x1}\n    x2 = x === undefined ? 0 : x;\n  }\n  return [x1, x2];\n}\n\n// For marks that have x and y channels (e.g., cell, dot, line, text).\nexport function maybeTuple(x, y) {\n  return x === undefined && y === undefined ? [first, second] : [x, y];\n}\n\n// A helper for extracting the z channel, if it is variable. Used by transforms\n// that require series, such as moving average and normalize.\nexport function maybeZ({z, fill, stroke} = {}) {\n  if (z === undefined) [z] = maybeColorChannel(fill);\n  if (z === undefined) [z] = maybeColorChannel(stroke);\n  return z;\n}\n\nexport function lengthof(data) {\n  return isArray(data) ? data.length : data?.numRows;\n}\n\n// Returns a Uint32Array with elements [0, 1, 2, … data.length - 1].\nexport function range(data) {\n  const n = lengthof(data);\n  const r = new Uint32Array(n);\n  for (let i = 0; i < n; ++i) r[i] = i;\n  return r;\n}\n\n// Returns an array [values[index[0]], values[index[1]], …].\nexport function take(values, index) {\n  return isArray(values) ? map(index, (i) => values[i], values.constructor) : map(index, (i) => values.at(i));\n}\n\n// If f does not take exactly one argument, wraps it in a function that uses take.\nexport function taker(f) {\n  return f.length === 1 ? (index, values) => f(take(values, index)) : f;\n}\n\n// Uses subarray if available, and otherwise slice.\nexport function subarray(I, i, j) {\n  return I.subarray ? I.subarray(i, j) : I.slice(i, j);\n}\n\n// Based on InternMap (d3.group).\nexport function keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n\nexport function maybeInput(key, options) {\n  if (options[key] !== undefined) return options[key];\n  switch (key) {\n    case \"x1\":\n    case \"x2\":\n      key = \"x\";\n      break;\n    case \"y1\":\n    case \"y2\":\n      key = \"y\";\n      break;\n  }\n  return options[key];\n}\n\nexport function column(source) {\n  // Defines a column whose values are lazily populated by calling the returned\n  // setter. If the given source is labeled, the label is propagated to the\n  // returned column definition.\n  let value;\n  return [\n    {\n      transform: () => value,\n      label: labelof(source)\n    },\n    (v) => (value = v)\n  ];\n}\n\n// Like column, but allows the source to be null.\nexport function maybeColumn(source) {\n  return source == null ? [source] : column(source);\n}\n\nexport function labelof(value, defaultValue) {\n  return typeof value === \"string\" ? value : value && value.label !== undefined ? value.label : defaultValue;\n}\n\n// Assuming that both x1 and x2 and lazy columns (per above), this derives a new\n// a column that’s the average of the two, and which inherits the column label\n// (if any). Both input columns are assumed to be quantitative. If either column\n// is temporal, the returned column is also temporal.\nexport function mid(x1, x2) {\n  return {\n    transform(data) {\n      const X1 = x1.transform(data);\n      const X2 = x2.transform(data);\n      return isTemporal(X1) || isTemporal(X2)\n        ? map(X1, (_, i) => new Date((+X1[i] + +X2[i]) / 2))\n        : map(X1, (_, i) => (+X1[i] + +X2[i]) / 2, Float64Array);\n    },\n    label: x1.label\n  };\n}\n\n// If the scale options declare an interval, applies it to the values V.\nexport function maybeApplyInterval(V, scale) {\n  const t = maybeIntervalTransform(scale?.interval, scale?.type);\n  return t ? map(V, t) : V;\n}\n\n// Returns the equivalent scale transform for the specified interval option.\nexport function maybeIntervalTransform(interval, type) {\n  const i = maybeInterval(interval, type);\n  return i && ((v) => (defined(v) ? i.floor(v) : v));\n}\n\n// If interval is not nullish, converts interval shorthand such as a number (for\n// multiples) or a time interval name (such as “day”) to a {floor, offset,\n// range} object similar to a D3 time interval.\nexport function maybeInterval(interval, type) {\n  if (interval == null) return;\n  if (typeof interval === \"number\") return numberInterval(interval);\n  if (typeof interval === \"string\") return (type === \"time\" ? timeInterval : utcInterval)(interval);\n  if (typeof interval.floor !== \"function\") throw new Error(\"invalid interval; missing floor method\");\n  if (typeof interval.offset !== \"function\") throw new Error(\"invalid interval; missing offset method\");\n  return interval;\n}\n\nexport function numberInterval(interval) {\n  interval = +interval;\n  if (0 < interval && interval < 1 && Number.isInteger(1 / interval)) interval = -1 / interval;\n  const n = Math.abs(interval);\n  return interval < 0\n    ? {\n        floor: (d) => Math.floor(d * n) / n,\n        offset: (d, s = 1) => (d * n + Math.floor(s)) / n,\n        range: (lo, hi) => rangei(Math.ceil(lo * n), hi * n).map((x) => x / n)\n      }\n    : {\n        floor: (d) => Math.floor(d / n) * n,\n        offset: (d, s = 1) => d + n * Math.floor(s),\n        range: (lo, hi) => rangei(Math.ceil(lo / n), hi / n).map((x) => x * n)\n      };\n}\n\n// Like maybeInterval, but requires a range method too.\nexport function maybeRangeInterval(interval, type) {\n  interval = maybeInterval(interval, type);\n  if (interval && typeof interval.range !== \"function\") throw new Error(\"invalid interval: missing range method\");\n  return interval;\n}\n\n// Like maybeRangeInterval, but requires a ceil method too.\nexport function maybeNiceInterval(interval, type) {\n  interval = maybeRangeInterval(interval, type);\n  if (interval && typeof interval.ceil !== \"function\") throw new Error(\"invalid interval: missing ceil method\");\n  return interval;\n}\n\nexport function isTimeInterval(t) {\n  return isInterval(t) && typeof t?.floor === \"function\" && t.floor() instanceof Date;\n}\n\nexport function isInterval(t) {\n  return typeof t?.range === \"function\";\n}\n\n// This distinguishes between per-dimension options and a standalone value.\nexport function maybeValue(value) {\n  return value === undefined || isOptions(value) ? value : {value};\n}\n\n// Coerces the given channel values (if any) to numbers. This is useful when\n// values will be interpolated into other code, such as an SVG transform, and\n// where we don’t wish to allow unexpected behavior for weird input.\nexport function numberChannel(source) {\n  return source == null\n    ? null\n    : {\n        transform: (data) => valueof(data, source, Float64Array),\n        label: labelof(source)\n      };\n}\n\nexport function isTuples(data) {\n  if (!isIterable(data)) return false;\n  for (const d of data) {\n    if (d == null) continue;\n    return typeof d === \"object\" && \"0\" in d && \"1\" in d;\n  }\n}\n\nexport function isIterable(value) {\n  return value && typeof value[Symbol.iterator] === \"function\";\n}\n\nexport function isTextual(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value !== \"object\" || value instanceof Date;\n  }\n}\n\nexport function isOrdinal(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    const type = typeof value;\n    return type === \"string\" || type === \"boolean\";\n  }\n}\n\nexport function isTemporal(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return value instanceof Date;\n  }\n}\n\n// Are these strings that might represent dates? This is stricter than ISO 8601\n// because we want to ignore false positives on numbers; for example, the string\n// \"1192\" is more likely to represent a number than a date even though it is\n// valid ISO 8601 representing 1192-01-01.\nexport function isTemporalString(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value === \"string\" && isNaN(value) && isoParse(value);\n  }\n}\n\n// Are these strings that might represent numbers? This is stricter than\n// coercion because we want to ignore false positives on e.g. empty strings.\nexport function isNumericString(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    if (typeof value !== \"string\") return false;\n    if (!value.trim()) continue;\n    return !isNaN(value);\n  }\n}\n\nexport function isNumeric(values) {\n  for (const value of values) {\n    if (value == null) continue;\n    return typeof value === \"number\";\n  }\n}\n\n// Returns true if every non-null value in the specified iterable of values\n// passes the specified predicate, and there is at least one non-null value;\n// returns false if at least one non-null value does not pass the specified\n// predicate; otherwise returns undefined (as if all values are null).\nexport function isEvery(values, is) {\n  let every;\n  for (const value of values) {\n    if (value == null) continue;\n    if (!is(value)) return false;\n    every = true;\n  }\n  return every;\n}\n\nconst namedColors = new Set(\"none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow\".split(\",\")); // prettier-ignore\n\n// Returns true if value is a valid CSS color string. This is intentionally lax\n// because the CSS color spec keeps growing, and we don’t need to parse these\n// colors—we just need to disambiguate them from column names.\n// https://www.w3.org/TR/SVG11/painting.html#SpecifyingPaint\n// https://www.w3.org/TR/css-color-5/\nexport function isColor(value) {\n  if (typeof value !== \"string\") return false;\n  value = value.toLowerCase().trim();\n  return (\n    /^#[0-9a-f]{3,8}$/.test(value) || // hex rgb, rgba, rrggbb, rrggbbaa\n    /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\\(.*\\)$/.test(value) || // <funciri>, CSS variable, color, etc.\n    namedColors.has(value) // currentColor, red, etc.\n  );\n}\n\nexport function isOpacity(value) {\n  return typeof value === \"number\" && ((0 <= value && value <= 1) || isNaN(value));\n}\n\nexport function isNoneish(value) {\n  return value == null || isNone(value);\n}\n\nexport function isNone(value) {\n  return /^\\s*none\\s*$/i.test(value);\n}\n\nexport function isRound(value) {\n  return /^\\s*round\\s*$/i.test(value);\n}\n\nexport function maybeAnchor(value, name) {\n  return maybeKeyword(value, name, [\n    \"middle\",\n    \"top-left\",\n    \"top\",\n    \"top-right\",\n    \"right\",\n    \"bottom-right\",\n    \"bottom\",\n    \"bottom-left\",\n    \"left\"\n  ]);\n}\n\nexport function maybeFrameAnchor(value = \"middle\") {\n  return maybeAnchor(value, \"frameAnchor\");\n}\n\n// Unlike {...defaults, ...options}, this ensures that any undefined (but\n// present) properties in options inherit the given default value.\nexport function inherit(options = {}, ...rest) {\n  let o = options;\n  for (const defaults of rest) {\n    for (const key in defaults) {\n      if (o[key] === undefined) {\n        const value = defaults[key];\n        if (o === options) o = {...o, [key]: value};\n        else o[key] = value;\n      }\n    }\n  }\n  return o;\n}\n\n// Given an iterable of named things (objects with a name property), returns a\n// corresponding object with properties associated with the given name.\nexport function named(things) {\n  console.warn(\"named iterables are deprecated; please use an object instead\");\n  const names = new Set();\n  return Object.fromEntries(\n    Array.from(things, (thing) => {\n      const {name} = thing;\n      if (name == null) throw new Error(\"missing name\");\n      const key = `${name}`;\n      if (key === \"__proto__\") throw new Error(`illegal name: ${key}`);\n      if (names.has(key)) throw new Error(`duplicate name: ${key}`);\n      names.add(key);\n      return [name, thing];\n    })\n  );\n}\n\nexport function maybeNamed(things) {\n  return isIterable(things) ? named(things) : things;\n}\n\n// TODO Accept other types of clips (paths, urls, x, y, other marks…)?\n// https://github.com/observablehq/plot/issues/181\nexport function maybeClip(clip) {\n  if (clip === true) clip = \"frame\";\n  else if (clip === false) clip = null;\n  else if (clip != null) clip = keyword(clip, \"clip\", [\"frame\", \"sphere\"]);\n  return clip;\n}\n\n// https://github.com/observablehq/stdlib/blob/746ca2e69135df6178e4f3a17244def35d8d6b20/src/arrow.js#L4C1-L17C1\nfunction isArrowTable(value) {\n  return (\n    value &&\n    typeof value.getChild === \"function\" &&\n    typeof value.toArray === \"function\" &&\n    value.schema &&\n    Array.isArray(value.schema.fields)\n  );\n}\n\nfunction isArrowVector(value) {\n  return value && typeof value.toArray === \"function\" && value.type;\n}\n\n// Apache Arrow now represents dates as numbers. We currently only support\n// implicit coercion to JavaScript Date objects when the numbers represent\n// milliseconds since Unix epoch.\nfunction isArrowDateType(type) {\n  return (\n    type &&\n    (type.typeId === 8 || // date\n      type.typeId === 10) && // timestamp\n    type.unit === 1 // millisecond\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}