{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { geoPath, group, namespaces, select } from \"d3\";\nimport { create } from \"./context.js\";\nimport { defined, nonempty } from \"./defined.js\";\nimport { formatDefault } from \"./format.js\";\nimport { isNone, isNoneish, isRound, maybeColorChannel, maybeNumberChannel } from \"./options.js\";\nimport { keyof, number, string } from \"./options.js\";\nimport { warn } from \"./warnings.js\";\nexport const offset = (typeof window !== \"undefined\" ? window.devicePixelRatio > 1 : typeof it === \"undefined\") ? 0 : 0.5; // prettier-ignore\n\nlet nextClipId = 0;\nlet nextPatternId = 0;\nexport function getClipId() {\n  return `plot-clip-${++nextClipId}`;\n}\nexport function getPatternId() {\n  return `plot-pattern-${++nextPatternId}`;\n}\nexport function styles(mark, {\n  title,\n  href,\n  ariaLabel: variaLabel,\n  ariaDescription,\n  ariaHidden,\n  target,\n  fill,\n  fillOpacity,\n  stroke,\n  strokeWidth,\n  strokeOpacity,\n  strokeLinejoin,\n  strokeLinecap,\n  strokeMiterlimit,\n  strokeDasharray,\n  strokeDashoffset,\n  opacity,\n  mixBlendMode,\n  imageFilter,\n  paintOrder,\n  pointerEvents,\n  shapeRendering,\n  channels\n}, {\n  ariaLabel: cariaLabel,\n  fill: defaultFill = \"currentColor\",\n  fillOpacity: defaultFillOpacity,\n  stroke: defaultStroke = \"none\",\n  strokeOpacity: defaultStrokeOpacity,\n  strokeWidth: defaultStrokeWidth,\n  strokeLinecap: defaultStrokeLinecap,\n  strokeLinejoin: defaultStrokeLinejoin,\n  strokeMiterlimit: defaultStrokeMiterlimit,\n  paintOrder: defaultPaintOrder\n}) {\n  // Some marks don’t support fill (e.g., tick and rule).\n  if (defaultFill === null) {\n    fill = null;\n    fillOpacity = null;\n  }\n\n  // Some marks don’t support stroke (e.g., image).\n  if (defaultStroke === null) {\n    stroke = null;\n    strokeOpacity = null;\n  }\n\n  // Some marks default to fill with no stroke, while others default to stroke\n  // with no fill. For example, bar and area default to fill, while dot and line\n  // default to stroke. For marks that fill by default, the default fill only\n  // applies if the stroke is (constant) none; if you set a stroke, then the\n  // default fill becomes none. Similarly for marks that stroke by stroke, the\n  // default stroke only applies if the fill is (constant) none.\n  if (isNoneish(defaultFill)) {\n    if (!isNoneish(defaultStroke) && (!isNoneish(fill) || channels?.fill)) defaultStroke = \"none\";\n  } else {\n    if (isNoneish(defaultStroke) && (!isNoneish(stroke) || channels?.stroke)) defaultFill = \"none\";\n  }\n  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);\n  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);\n  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);\n  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);\n  const [vopacity, copacity] = maybeNumberChannel(opacity);\n\n  // For styles that have no effect if there is no stroke, only apply the\n  // defaults if the stroke is not the constant none. (If stroke is a channel,\n  // then cstroke will be undefined, but there’s still a stroke; hence we don’t\n  // use isNoneish here.)\n  if (!isNone(cstroke)) {\n    if (strokeWidth === undefined) strokeWidth = defaultStrokeWidth;\n    if (strokeLinecap === undefined) strokeLinecap = defaultStrokeLinecap;\n    if (strokeLinejoin === undefined) strokeLinejoin = defaultStrokeLinejoin;\n\n    // The default stroke miterlimit need not be applied if the current stroke\n    // is the constant round; this only has effect on miter joins.\n    if (strokeMiterlimit === undefined && !isRound(strokeLinejoin)) strokeMiterlimit = defaultStrokeMiterlimit;\n\n    // The paint order only takes effect if there is both a fill and a stroke\n    // (at least if we ignore markers, which no built-in marks currently use).\n    if (!isNone(cfill) && paintOrder === undefined) paintOrder = defaultPaintOrder;\n  }\n  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);\n\n  // Some marks don’t support fill (e.g., tick and rule).\n  if (defaultFill !== null) {\n    mark.fill = impliedString(cfill, \"currentColor\");\n    mark.fillOpacity = impliedNumber(cfillOpacity, 1);\n  }\n\n  // Some marks don’t support stroke (e.g., image).\n  if (defaultStroke !== null) {\n    mark.stroke = impliedString(cstroke, \"none\");\n    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);\n    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);\n    mark.strokeLinejoin = impliedString(strokeLinejoin, \"miter\");\n    mark.strokeLinecap = impliedString(strokeLinecap, \"butt\");\n    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);\n    mark.strokeDasharray = impliedString(strokeDasharray, \"none\");\n    mark.strokeDashoffset = impliedString(strokeDashoffset, \"0\");\n  }\n  mark.target = string(target);\n  mark.ariaLabel = string(cariaLabel);\n  mark.ariaDescription = string(ariaDescription);\n  mark.ariaHidden = string(ariaHidden);\n  mark.opacity = impliedNumber(copacity, 1);\n  mark.mixBlendMode = impliedString(mixBlendMode, \"normal\");\n  mark.imageFilter = impliedString(imageFilter, \"none\");\n  mark.paintOrder = impliedString(paintOrder, \"normal\");\n  mark.pointerEvents = impliedString(pointerEvents, \"auto\");\n  mark.shapeRendering = impliedString(shapeRendering, \"auto\");\n  return {\n    title: {\n      value: title,\n      optional: true,\n      filter: null\n    },\n    href: {\n      value: href,\n      optional: true,\n      filter: null\n    },\n    ariaLabel: {\n      value: variaLabel,\n      optional: true,\n      filter: null\n    },\n    fill: {\n      value: vfill,\n      scale: \"auto\",\n      optional: true\n    },\n    fillOpacity: {\n      value: vfillOpacity,\n      scale: \"auto\",\n      optional: true\n    },\n    stroke: {\n      value: vstroke,\n      scale: \"auto\",\n      optional: true\n    },\n    strokeOpacity: {\n      value: vstrokeOpacity,\n      scale: \"auto\",\n      optional: true\n    },\n    strokeWidth: {\n      value: vstrokeWidth,\n      optional: true\n    },\n    opacity: {\n      value: vopacity,\n      scale: \"auto\",\n      optional: true\n    }\n  };\n}\n\n// Applies the specified titles via selection.call.\nexport function applyTitle(selection, L) {\n  if (L) selection.filter(i => nonempty(L[i])).append(\"title\").call(applyText, L);\n}\n\n// Like applyTitle, but for grouped data (lines, areas).\nexport function applyTitleGroup(selection, L) {\n  if (L) selection.filter(([i]) => nonempty(L[i])).append(\"title\").call(applyTextGroup, L);\n}\nexport function applyText(selection, T) {\n  if (T) selection.text(i => formatDefault(T[i]));\n}\nexport function applyTextGroup(selection, T) {\n  if (T) selection.text(([i]) => formatDefault(T[i]));\n}\nexport function applyChannelStyles(selection, {\n  target,\n  tip\n}, {\n  ariaLabel: AL,\n  title: T,\n  fill: F,\n  fillOpacity: FO,\n  stroke: S,\n  strokeOpacity: SO,\n  strokeWidth: SW,\n  opacity: O,\n  href: H\n}) {\n  if (AL) applyAttr(selection, \"aria-label\", i => AL[i]);\n  if (F) applyAttr(selection, \"fill\", i => F[i]);\n  if (FO) applyAttr(selection, \"fill-opacity\", i => FO[i]);\n  if (S) applyAttr(selection, \"stroke\", i => S[i]);\n  if (SO) applyAttr(selection, \"stroke-opacity\", i => SO[i]);\n  if (SW) applyAttr(selection, \"stroke-width\", i => SW[i]);\n  if (O) applyAttr(selection, \"opacity\", i => O[i]);\n  if (H) applyHref(selection, i => H[i], target);\n  if (!tip) applyTitle(selection, T);\n}\nexport function applyGroupedChannelStyles(selection, {\n  target,\n  tip\n}, {\n  ariaLabel: AL,\n  title: T,\n  fill: F,\n  fillOpacity: FO,\n  stroke: S,\n  strokeOpacity: SO,\n  strokeWidth: SW,\n  opacity: O,\n  href: H\n}) {\n  if (AL) applyAttr(selection, \"aria-label\", ([i]) => AL[i]);\n  if (F) applyAttr(selection, \"fill\", ([i]) => F[i]);\n  if (FO) applyAttr(selection, \"fill-opacity\", ([i]) => FO[i]);\n  if (S) applyAttr(selection, \"stroke\", ([i]) => S[i]);\n  if (SO) applyAttr(selection, \"stroke-opacity\", ([i]) => SO[i]);\n  if (SW) applyAttr(selection, \"stroke-width\", ([i]) => SW[i]);\n  if (O) applyAttr(selection, \"opacity\", ([i]) => O[i]);\n  if (H) applyHref(selection, ([i]) => H[i], target);\n  if (!tip) applyTitleGroup(selection, T);\n}\nfunction groupAesthetics({\n  ariaLabel: AL,\n  title: T,\n  fill: F,\n  fillOpacity: FO,\n  stroke: S,\n  strokeOpacity: SO,\n  strokeWidth: SW,\n  opacity: O,\n  href: H\n}, {\n  tip\n}) {\n  return [AL, tip ? undefined : T, F, FO, S, SO, SW, O, H].filter(c => c !== undefined);\n}\nexport function groupZ(I, Z, z) {\n  const G = group(I, i => Z[i]);\n  if (z === undefined && G.size > 1 + I.length >> 1) {\n    warn(`Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`);\n  }\n  return G.values();\n}\nexport function* groupIndex(I, position, mark, channels) {\n  const {\n    z\n  } = mark;\n  const {\n    z: Z\n  } = channels; // group channel\n  const A = groupAesthetics(channels, mark); // aesthetic channels\n  const C = [...position, ...A]; // all channels\n\n  // Group the current index by Z (if any).\n  for (const G of Z ? groupZ(I, Z, z) : [I]) {\n    let Ag; // the A-values (aesthetics) of the current group, if any\n    let Gg; // the current group index (a subset of G, and I), if any\n    out: for (const i of G) {\n      // If any channel has an undefined value for this index, skip it.\n      for (const c of C) {\n        if (!defined(c[i])) {\n          if (Gg) Gg.push(-1);\n          continue out;\n        }\n      }\n\n      // Otherwise, if this is a new group, record the aesthetics for this\n      // group. Yield the current group and start a new one.\n      if (Ag === undefined) {\n        if (Gg) yield Gg;\n        Ag = A.map(c => keyof(c[i])), Gg = [i];\n        continue;\n      }\n\n      // Otherwise, add the current index to the current group. Then, if any of\n      // the aesthetics don’t match the current group, yield the current group\n      // and start a new group of the current index.\n      Gg.push(i);\n      for (let j = 0; j < A.length; ++j) {\n        const k = keyof(A[j][i]);\n        if (k !== Ag[j]) {\n          yield Gg;\n          Ag = A.map(c => keyof(c[i])), Gg = [i];\n          continue out;\n        }\n      }\n    }\n\n    // Yield the current group, if any.\n    if (Gg) yield Gg;\n  }\n}\n\n// Note: may mutate selection.node!\nfunction applyClip(selection, mark, dimensions, context) {\n  let clipUrl;\n  const {\n    clip = context.clip\n  } = mark;\n  switch (clip) {\n    case \"frame\":\n      {\n        // Wrap the G element with another (untransformed) G element, applying the\n        // clip to the parent G element so that the clip path is not affected by\n        // the mark’s transform. To simplify the adoption of this fix, mutate the\n        // passed-in selection.node to return the parent G element.\n        selection = create(\"svg:g\", context).each(function () {\n          this.appendChild(selection.node());\n          selection.node = () => this; // Note: mutation!\n        });\n\n        clipUrl = getFrameClip(context, dimensions);\n        break;\n      }\n    case \"sphere\":\n      {\n        clipUrl = getProjectionClip(context);\n        break;\n      }\n  }\n  // Here we’re careful to apply the ARIA attributes to the outer G element when\n  // clipping is applied, and to apply the ARIA attributes before any other\n  // attributes (for readability).\n  applyAttr(selection, \"aria-label\", mark.ariaLabel);\n  applyAttr(selection, \"aria-description\", mark.ariaDescription);\n  applyAttr(selection, \"aria-hidden\", mark.ariaHidden);\n  applyAttr(selection, \"clip-path\", clipUrl);\n}\nfunction memoizeClip(clip) {\n  const cache = new WeakMap();\n  return (context, dimensions) => {\n    let url = cache.get(context);\n    if (!url) {\n      const id = getClipId();\n      select(context.ownerSVGElement).append(\"clipPath\").attr(\"id\", id).call(clip, context, dimensions);\n      cache.set(context, url = `url(#${id})`);\n    }\n    return url;\n  };\n}\nconst getFrameClip = memoizeClip((clipPath, context, dimensions) => {\n  const {\n    width,\n    height,\n    marginLeft,\n    marginRight,\n    marginTop,\n    marginBottom\n  } = dimensions;\n  clipPath.append(\"rect\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginRight - marginLeft).attr(\"height\", height - marginTop - marginBottom);\n});\nconst getProjectionClip = memoizeClip((clipPath, context) => {\n  const {\n    projection\n  } = context;\n  if (!projection) throw new Error(`the \"sphere\" clip option requires a projection`);\n  clipPath.append(\"path\").attr(\"d\", geoPath(projection)({\n    type: \"Sphere\"\n  }));\n});\n\n// Note: may mutate selection.node!\nexport function applyIndirectStyles(selection, mark, dimensions, context) {\n  applyClip(selection, mark, dimensions, context);\n  applyAttr(selection, \"class\", mark.className);\n  applyAttr(selection, \"fill\", mark.fill);\n  applyAttr(selection, \"fill-opacity\", mark.fillOpacity);\n  applyAttr(selection, \"stroke\", mark.stroke);\n  applyAttr(selection, \"stroke-width\", mark.strokeWidth);\n  applyAttr(selection, \"stroke-opacity\", mark.strokeOpacity);\n  applyAttr(selection, \"stroke-linejoin\", mark.strokeLinejoin);\n  applyAttr(selection, \"stroke-linecap\", mark.strokeLinecap);\n  applyAttr(selection, \"stroke-miterlimit\", mark.strokeMiterlimit);\n  applyAttr(selection, \"stroke-dasharray\", mark.strokeDasharray);\n  applyAttr(selection, \"stroke-dashoffset\", mark.strokeDashoffset);\n  applyAttr(selection, \"shape-rendering\", mark.shapeRendering);\n  applyAttr(selection, \"filter\", mark.imageFilter);\n  applyAttr(selection, \"paint-order\", mark.paintOrder);\n  const {\n    pointerEvents = context.pointerSticky === false ? \"none\" : undefined\n  } = mark;\n  applyAttr(selection, \"pointer-events\", pointerEvents);\n}\nexport function applyDirectStyles(selection, mark) {\n  applyStyle(selection, \"mix-blend-mode\", mark.mixBlendMode);\n  applyAttr(selection, \"opacity\", mark.opacity);\n}\nfunction applyHref(selection, href, target) {\n  selection.each(function (i) {\n    const h = href(i);\n    if (h != null) {\n      const a = this.ownerDocument.createElementNS(namespaces.svg, \"a\");\n      a.setAttribute(\"fill\", \"inherit\");\n      a.setAttributeNS(namespaces.xlink, \"href\", h);\n      if (target != null) a.setAttribute(\"target\", target);\n      this.parentNode.insertBefore(a, this).appendChild(this);\n    }\n  });\n}\nexport function applyAttr(selection, name, value) {\n  if (value != null) selection.attr(name, value);\n}\nexport function applyStyle(selection, name, value) {\n  if (value != null) selection.style(name, value);\n}\nexport function applyTransform(selection, mark, {\n  x,\n  y\n}, tx = offset, ty = offset) {\n  tx += mark.dx;\n  ty += mark.dy;\n  if (x?.bandwidth) tx += x.bandwidth() / 2;\n  if (y?.bandwidth) ty += y.bandwidth() / 2;\n  if (tx || ty) selection.attr(\"transform\", `translate(${tx},${ty})`);\n}\nexport function impliedString(value, impliedValue) {\n  if ((value = string(value)) !== impliedValue) return value;\n}\nexport function impliedNumber(value, impliedValue) {\n  if ((value = number(value)) !== impliedValue) return value;\n}\n\n// https://www.w3.org/TR/CSS21/grammar.html\nconst validClassName = /^-?([_a-z]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])([_a-z0-9-]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])*$/i;\nexport function maybeClassName(name) {\n  // The default should be changed whenever the default styles are changed, so\n  // as to avoid conflict when multiple versions of Plot are on the page.\n  if (name === undefined) return \"plot-d6a7b5\";\n  name = `${name}`;\n  if (!validClassName.test(name)) throw new Error(`invalid class name: ${name}`);\n  return name;\n}\nexport function applyInlineStyles(selection, style) {\n  if (typeof style === \"string\") {\n    selection.property(\"style\", style);\n  } else if (style != null) {\n    for (const element of selection) {\n      Object.assign(element.style, style);\n    }\n  }\n}\nexport function applyFrameAnchor({\n  frameAnchor\n}, {\n  width,\n  height,\n  marginTop,\n  marginRight,\n  marginBottom,\n  marginLeft\n}) {\n  return [/left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2, /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2];\n}","map":{"version":3,"names":["geoPath","group","namespaces","select","create","defined","nonempty","formatDefault","isNone","isNoneish","isRound","maybeColorChannel","maybeNumberChannel","keyof","number","string","warn","offset","window","devicePixelRatio","it","nextClipId","nextPatternId","getClipId","getPatternId","styles","mark","title","href","ariaLabel","variaLabel","ariaDescription","ariaHidden","target","fill","fillOpacity","stroke","strokeWidth","strokeOpacity","strokeLinejoin","strokeLinecap","strokeMiterlimit","strokeDasharray","strokeDashoffset","opacity","mixBlendMode","imageFilter","paintOrder","pointerEvents","shapeRendering","channels","cariaLabel","defaultFill","defaultFillOpacity","defaultStroke","defaultStrokeOpacity","defaultStrokeWidth","defaultStrokeLinecap","defaultStrokeLinejoin","defaultStrokeMiterlimit","defaultPaintOrder","vfill","cfill","vfillOpacity","cfillOpacity","vstroke","cstroke","vstrokeOpacity","cstrokeOpacity","vopacity","copacity","undefined","vstrokeWidth","cstrokeWidth","impliedString","impliedNumber","value","optional","filter","scale","applyTitle","selection","L","i","append","call","applyText","applyTitleGroup","applyTextGroup","T","text","applyChannelStyles","tip","AL","F","FO","S","SO","SW","O","H","applyAttr","applyHref","applyGroupedChannelStyles","groupAesthetics","c","groupZ","I","Z","z","G","size","length","values","groupIndex","position","A","C","Ag","Gg","out","push","map","j","k","applyClip","dimensions","context","clipUrl","clip","each","appendChild","node","getFrameClip","getProjectionClip","memoizeClip","cache","WeakMap","url","get","id","ownerSVGElement","attr","set","clipPath","width","height","marginLeft","marginRight","marginTop","marginBottom","projection","Error","type","applyIndirectStyles","className","pointerSticky","applyDirectStyles","applyStyle","h","a","ownerDocument","createElementNS","svg","setAttribute","setAttributeNS","xlink","parentNode","insertBefore","name","style","applyTransform","x","y","tx","ty","dx","dy","bandwidth","impliedValue","validClassName","maybeClassName","test","applyInlineStyles","property","element","Object","assign","applyFrameAnchor","frameAnchor"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/style.js"],"sourcesContent":["import {geoPath, group, namespaces, select} from \"d3\";\nimport {create} from \"./context.js\";\nimport {defined, nonempty} from \"./defined.js\";\nimport {formatDefault} from \"./format.js\";\nimport {isNone, isNoneish, isRound, maybeColorChannel, maybeNumberChannel} from \"./options.js\";\nimport {keyof, number, string} from \"./options.js\";\nimport {warn} from \"./warnings.js\";\n\nexport const offset = (typeof window !== \"undefined\" ? window.devicePixelRatio > 1 : typeof it === \"undefined\") ? 0 : 0.5; // prettier-ignore\n\nlet nextClipId = 0;\nlet nextPatternId = 0;\n\nexport function getClipId() {\n  return `plot-clip-${++nextClipId}`;\n}\n\nexport function getPatternId() {\n  return `plot-pattern-${++nextPatternId}`;\n}\n\nexport function styles(\n  mark,\n  {\n    title,\n    href,\n    ariaLabel: variaLabel,\n    ariaDescription,\n    ariaHidden,\n    target,\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    strokeLinejoin,\n    strokeLinecap,\n    strokeMiterlimit,\n    strokeDasharray,\n    strokeDashoffset,\n    opacity,\n    mixBlendMode,\n    imageFilter,\n    paintOrder,\n    pointerEvents,\n    shapeRendering,\n    channels\n  },\n  {\n    ariaLabel: cariaLabel,\n    fill: defaultFill = \"currentColor\",\n    fillOpacity: defaultFillOpacity,\n    stroke: defaultStroke = \"none\",\n    strokeOpacity: defaultStrokeOpacity,\n    strokeWidth: defaultStrokeWidth,\n    strokeLinecap: defaultStrokeLinecap,\n    strokeLinejoin: defaultStrokeLinejoin,\n    strokeMiterlimit: defaultStrokeMiterlimit,\n    paintOrder: defaultPaintOrder\n  }\n) {\n  // Some marks don’t support fill (e.g., tick and rule).\n  if (defaultFill === null) {\n    fill = null;\n    fillOpacity = null;\n  }\n\n  // Some marks don’t support stroke (e.g., image).\n  if (defaultStroke === null) {\n    stroke = null;\n    strokeOpacity = null;\n  }\n\n  // Some marks default to fill with no stroke, while others default to stroke\n  // with no fill. For example, bar and area default to fill, while dot and line\n  // default to stroke. For marks that fill by default, the default fill only\n  // applies if the stroke is (constant) none; if you set a stroke, then the\n  // default fill becomes none. Similarly for marks that stroke by stroke, the\n  // default stroke only applies if the fill is (constant) none.\n  if (isNoneish(defaultFill)) {\n    if (!isNoneish(defaultStroke) && (!isNoneish(fill) || channels?.fill)) defaultStroke = \"none\";\n  } else {\n    if (isNoneish(defaultStroke) && (!isNoneish(stroke) || channels?.stroke)) defaultFill = \"none\";\n  }\n\n  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);\n  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);\n  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);\n  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);\n  const [vopacity, copacity] = maybeNumberChannel(opacity);\n\n  // For styles that have no effect if there is no stroke, only apply the\n  // defaults if the stroke is not the constant none. (If stroke is a channel,\n  // then cstroke will be undefined, but there’s still a stroke; hence we don’t\n  // use isNoneish here.)\n  if (!isNone(cstroke)) {\n    if (strokeWidth === undefined) strokeWidth = defaultStrokeWidth;\n    if (strokeLinecap === undefined) strokeLinecap = defaultStrokeLinecap;\n    if (strokeLinejoin === undefined) strokeLinejoin = defaultStrokeLinejoin;\n\n    // The default stroke miterlimit need not be applied if the current stroke\n    // is the constant round; this only has effect on miter joins.\n    if (strokeMiterlimit === undefined && !isRound(strokeLinejoin)) strokeMiterlimit = defaultStrokeMiterlimit;\n\n    // The paint order only takes effect if there is both a fill and a stroke\n    // (at least if we ignore markers, which no built-in marks currently use).\n    if (!isNone(cfill) && paintOrder === undefined) paintOrder = defaultPaintOrder;\n  }\n\n  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);\n\n  // Some marks don’t support fill (e.g., tick and rule).\n  if (defaultFill !== null) {\n    mark.fill = impliedString(cfill, \"currentColor\");\n    mark.fillOpacity = impliedNumber(cfillOpacity, 1);\n  }\n\n  // Some marks don’t support stroke (e.g., image).\n  if (defaultStroke !== null) {\n    mark.stroke = impliedString(cstroke, \"none\");\n    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);\n    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);\n    mark.strokeLinejoin = impliedString(strokeLinejoin, \"miter\");\n    mark.strokeLinecap = impliedString(strokeLinecap, \"butt\");\n    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);\n    mark.strokeDasharray = impliedString(strokeDasharray, \"none\");\n    mark.strokeDashoffset = impliedString(strokeDashoffset, \"0\");\n  }\n\n  mark.target = string(target);\n  mark.ariaLabel = string(cariaLabel);\n  mark.ariaDescription = string(ariaDescription);\n  mark.ariaHidden = string(ariaHidden);\n  mark.opacity = impliedNumber(copacity, 1);\n  mark.mixBlendMode = impliedString(mixBlendMode, \"normal\");\n  mark.imageFilter = impliedString(imageFilter, \"none\");\n  mark.paintOrder = impliedString(paintOrder, \"normal\");\n  mark.pointerEvents = impliedString(pointerEvents, \"auto\");\n  mark.shapeRendering = impliedString(shapeRendering, \"auto\");\n\n  return {\n    title: {value: title, optional: true, filter: null},\n    href: {value: href, optional: true, filter: null},\n    ariaLabel: {value: variaLabel, optional: true, filter: null},\n    fill: {value: vfill, scale: \"auto\", optional: true},\n    fillOpacity: {value: vfillOpacity, scale: \"auto\", optional: true},\n    stroke: {value: vstroke, scale: \"auto\", optional: true},\n    strokeOpacity: {value: vstrokeOpacity, scale: \"auto\", optional: true},\n    strokeWidth: {value: vstrokeWidth, optional: true},\n    opacity: {value: vopacity, scale: \"auto\", optional: true}\n  };\n}\n\n// Applies the specified titles via selection.call.\nexport function applyTitle(selection, L) {\n  if (L)\n    selection\n      .filter((i) => nonempty(L[i]))\n      .append(\"title\")\n      .call(applyText, L);\n}\n\n// Like applyTitle, but for grouped data (lines, areas).\nexport function applyTitleGroup(selection, L) {\n  if (L)\n    selection\n      .filter(([i]) => nonempty(L[i]))\n      .append(\"title\")\n      .call(applyTextGroup, L);\n}\n\nexport function applyText(selection, T) {\n  if (T) selection.text((i) => formatDefault(T[i]));\n}\n\nexport function applyTextGroup(selection, T) {\n  if (T) selection.text(([i]) => formatDefault(T[i]));\n}\n\nexport function applyChannelStyles(\n  selection,\n  {target, tip},\n  {\n    ariaLabel: AL,\n    title: T,\n    fill: F,\n    fillOpacity: FO,\n    stroke: S,\n    strokeOpacity: SO,\n    strokeWidth: SW,\n    opacity: O,\n    href: H\n  }\n) {\n  if (AL) applyAttr(selection, \"aria-label\", (i) => AL[i]);\n  if (F) applyAttr(selection, \"fill\", (i) => F[i]);\n  if (FO) applyAttr(selection, \"fill-opacity\", (i) => FO[i]);\n  if (S) applyAttr(selection, \"stroke\", (i) => S[i]);\n  if (SO) applyAttr(selection, \"stroke-opacity\", (i) => SO[i]);\n  if (SW) applyAttr(selection, \"stroke-width\", (i) => SW[i]);\n  if (O) applyAttr(selection, \"opacity\", (i) => O[i]);\n  if (H) applyHref(selection, (i) => H[i], target);\n  if (!tip) applyTitle(selection, T);\n}\n\nexport function applyGroupedChannelStyles(\n  selection,\n  {target, tip},\n  {\n    ariaLabel: AL,\n    title: T,\n    fill: F,\n    fillOpacity: FO,\n    stroke: S,\n    strokeOpacity: SO,\n    strokeWidth: SW,\n    opacity: O,\n    href: H\n  }\n) {\n  if (AL) applyAttr(selection, \"aria-label\", ([i]) => AL[i]);\n  if (F) applyAttr(selection, \"fill\", ([i]) => F[i]);\n  if (FO) applyAttr(selection, \"fill-opacity\", ([i]) => FO[i]);\n  if (S) applyAttr(selection, \"stroke\", ([i]) => S[i]);\n  if (SO) applyAttr(selection, \"stroke-opacity\", ([i]) => SO[i]);\n  if (SW) applyAttr(selection, \"stroke-width\", ([i]) => SW[i]);\n  if (O) applyAttr(selection, \"opacity\", ([i]) => O[i]);\n  if (H) applyHref(selection, ([i]) => H[i], target);\n  if (!tip) applyTitleGroup(selection, T);\n}\n\nfunction groupAesthetics(\n  {\n    ariaLabel: AL,\n    title: T,\n    fill: F,\n    fillOpacity: FO,\n    stroke: S,\n    strokeOpacity: SO,\n    strokeWidth: SW,\n    opacity: O,\n    href: H\n  },\n  {tip}\n) {\n  return [AL, tip ? undefined : T, F, FO, S, SO, SW, O, H].filter((c) => c !== undefined);\n}\n\nexport function groupZ(I, Z, z) {\n  const G = group(I, (i) => Z[i]);\n  if (z === undefined && G.size > (1 + I.length) >> 1) {\n    warn(\n      `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`\n    );\n  }\n  return G.values();\n}\n\nexport function* groupIndex(I, position, mark, channels) {\n  const {z} = mark;\n  const {z: Z} = channels; // group channel\n  const A = groupAesthetics(channels, mark); // aesthetic channels\n  const C = [...position, ...A]; // all channels\n\n  // Group the current index by Z (if any).\n  for (const G of Z ? groupZ(I, Z, z) : [I]) {\n    let Ag; // the A-values (aesthetics) of the current group, if any\n    let Gg; // the current group index (a subset of G, and I), if any\n    out: for (const i of G) {\n      // If any channel has an undefined value for this index, skip it.\n      for (const c of C) {\n        if (!defined(c[i])) {\n          if (Gg) Gg.push(-1);\n          continue out;\n        }\n      }\n\n      // Otherwise, if this is a new group, record the aesthetics for this\n      // group. Yield the current group and start a new one.\n      if (Ag === undefined) {\n        if (Gg) yield Gg;\n        (Ag = A.map((c) => keyof(c[i]))), (Gg = [i]);\n        continue;\n      }\n\n      // Otherwise, add the current index to the current group. Then, if any of\n      // the aesthetics don’t match the current group, yield the current group\n      // and start a new group of the current index.\n      Gg.push(i);\n      for (let j = 0; j < A.length; ++j) {\n        const k = keyof(A[j][i]);\n        if (k !== Ag[j]) {\n          yield Gg;\n          (Ag = A.map((c) => keyof(c[i]))), (Gg = [i]);\n          continue out;\n        }\n      }\n    }\n\n    // Yield the current group, if any.\n    if (Gg) yield Gg;\n  }\n}\n\n// Note: may mutate selection.node!\nfunction applyClip(selection, mark, dimensions, context) {\n  let clipUrl;\n  const {clip = context.clip} = mark;\n  switch (clip) {\n    case \"frame\": {\n      // Wrap the G element with another (untransformed) G element, applying the\n      // clip to the parent G element so that the clip path is not affected by\n      // the mark’s transform. To simplify the adoption of this fix, mutate the\n      // passed-in selection.node to return the parent G element.\n      selection = create(\"svg:g\", context).each(function () {\n        this.appendChild(selection.node());\n        selection.node = () => this; // Note: mutation!\n      });\n      clipUrl = getFrameClip(context, dimensions);\n      break;\n    }\n    case \"sphere\": {\n      clipUrl = getProjectionClip(context);\n      break;\n    }\n  }\n  // Here we’re careful to apply the ARIA attributes to the outer G element when\n  // clipping is applied, and to apply the ARIA attributes before any other\n  // attributes (for readability).\n  applyAttr(selection, \"aria-label\", mark.ariaLabel);\n  applyAttr(selection, \"aria-description\", mark.ariaDescription);\n  applyAttr(selection, \"aria-hidden\", mark.ariaHidden);\n  applyAttr(selection, \"clip-path\", clipUrl);\n}\n\nfunction memoizeClip(clip) {\n  const cache = new WeakMap();\n  return (context, dimensions) => {\n    let url = cache.get(context);\n    if (!url) {\n      const id = getClipId();\n      select(context.ownerSVGElement).append(\"clipPath\").attr(\"id\", id).call(clip, context, dimensions);\n      cache.set(context, (url = `url(#${id})`));\n    }\n    return url;\n  };\n}\n\nconst getFrameClip = memoizeClip((clipPath, context, dimensions) => {\n  const {width, height, marginLeft, marginRight, marginTop, marginBottom} = dimensions;\n  clipPath\n    .append(\"rect\")\n    .attr(\"x\", marginLeft)\n    .attr(\"y\", marginTop)\n    .attr(\"width\", width - marginRight - marginLeft)\n    .attr(\"height\", height - marginTop - marginBottom);\n});\n\nconst getProjectionClip = memoizeClip((clipPath, context) => {\n  const {projection} = context;\n  if (!projection) throw new Error(`the \"sphere\" clip option requires a projection`);\n  clipPath.append(\"path\").attr(\"d\", geoPath(projection)({type: \"Sphere\"}));\n});\n\n// Note: may mutate selection.node!\nexport function applyIndirectStyles(selection, mark, dimensions, context) {\n  applyClip(selection, mark, dimensions, context);\n  applyAttr(selection, \"class\", mark.className);\n  applyAttr(selection, \"fill\", mark.fill);\n  applyAttr(selection, \"fill-opacity\", mark.fillOpacity);\n  applyAttr(selection, \"stroke\", mark.stroke);\n  applyAttr(selection, \"stroke-width\", mark.strokeWidth);\n  applyAttr(selection, \"stroke-opacity\", mark.strokeOpacity);\n  applyAttr(selection, \"stroke-linejoin\", mark.strokeLinejoin);\n  applyAttr(selection, \"stroke-linecap\", mark.strokeLinecap);\n  applyAttr(selection, \"stroke-miterlimit\", mark.strokeMiterlimit);\n  applyAttr(selection, \"stroke-dasharray\", mark.strokeDasharray);\n  applyAttr(selection, \"stroke-dashoffset\", mark.strokeDashoffset);\n  applyAttr(selection, \"shape-rendering\", mark.shapeRendering);\n  applyAttr(selection, \"filter\", mark.imageFilter);\n  applyAttr(selection, \"paint-order\", mark.paintOrder);\n  const {pointerEvents = context.pointerSticky === false ? \"none\" : undefined} = mark;\n  applyAttr(selection, \"pointer-events\", pointerEvents);\n}\n\nexport function applyDirectStyles(selection, mark) {\n  applyStyle(selection, \"mix-blend-mode\", mark.mixBlendMode);\n  applyAttr(selection, \"opacity\", mark.opacity);\n}\n\nfunction applyHref(selection, href, target) {\n  selection.each(function (i) {\n    const h = href(i);\n    if (h != null) {\n      const a = this.ownerDocument.createElementNS(namespaces.svg, \"a\");\n      a.setAttribute(\"fill\", \"inherit\");\n      a.setAttributeNS(namespaces.xlink, \"href\", h);\n      if (target != null) a.setAttribute(\"target\", target);\n      this.parentNode.insertBefore(a, this).appendChild(this);\n    }\n  });\n}\n\nexport function applyAttr(selection, name, value) {\n  if (value != null) selection.attr(name, value);\n}\n\nexport function applyStyle(selection, name, value) {\n  if (value != null) selection.style(name, value);\n}\n\nexport function applyTransform(selection, mark, {x, y}, tx = offset, ty = offset) {\n  tx += mark.dx;\n  ty += mark.dy;\n  if (x?.bandwidth) tx += x.bandwidth() / 2;\n  if (y?.bandwidth) ty += y.bandwidth() / 2;\n  if (tx || ty) selection.attr(\"transform\", `translate(${tx},${ty})`);\n}\n\nexport function impliedString(value, impliedValue) {\n  if ((value = string(value)) !== impliedValue) return value;\n}\n\nexport function impliedNumber(value, impliedValue) {\n  if ((value = number(value)) !== impliedValue) return value;\n}\n\n// https://www.w3.org/TR/CSS21/grammar.html\nconst validClassName =\n  /^-?([_a-z]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])([_a-z0-9-]|[\\240-\\377]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\t\\r\\n\\f])?|\\\\[^\\r\\n\\f0-9a-f])*$/i;\n\nexport function maybeClassName(name) {\n  // The default should be changed whenever the default styles are changed, so\n  // as to avoid conflict when multiple versions of Plot are on the page.\n  if (name === undefined) return \"plot-d6a7b5\";\n  name = `${name}`;\n  if (!validClassName.test(name)) throw new Error(`invalid class name: ${name}`);\n  return name;\n}\n\nexport function applyInlineStyles(selection, style) {\n  if (typeof style === \"string\") {\n    selection.property(\"style\", style);\n  } else if (style != null) {\n    for (const element of selection) {\n      Object.assign(element.style, style);\n    }\n  }\n}\n\nexport function applyFrameAnchor({frameAnchor}, {width, height, marginTop, marginRight, marginBottom, marginLeft}) {\n  return [\n    /left$/.test(frameAnchor)\n      ? marginLeft\n      : /right$/.test(frameAnchor)\n      ? width - marginRight\n      : (marginLeft + width - marginRight) / 2,\n    /^top/.test(frameAnchor)\n      ? marginTop\n      : /^bottom/.test(frameAnchor)\n      ? height - marginBottom\n      : (marginTop + height - marginBottom) / 2\n  ];\n}\n"],"mappings":";AAAA,SAAQA,OAAO,EAAEC,KAAK,EAAEC,UAAU,EAAEC,MAAM,QAAO,IAAI;AACrD,SAAQC,MAAM,QAAO,cAAc;AACnC,SAAQC,OAAO,EAAEC,QAAQ,QAAO,cAAc;AAC9C,SAAQC,aAAa,QAAO,aAAa;AACzC,SAAQC,MAAM,EAAEC,SAAS,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,kBAAkB,QAAO,cAAc;AAC9F,SAAQC,KAAK,EAAEC,MAAM,EAAEC,MAAM,QAAO,cAAc;AAClD,SAAQC,IAAI,QAAO,eAAe;AAElC,OAAO,MAAMC,MAAM,GAAG,CAAC,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,CAACC,gBAAgB,GAAG,CAAC,GAAG,OAAOC,EAAE,KAAK,WAAW,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;;AAE3H,IAAIC,UAAU,GAAG,CAAC;AAClB,IAAIC,aAAa,GAAG,CAAC;AAErB,OAAO,SAASC,SAASA,CAAA,EAAG;EAC1B,OAAQ,aAAY,EAAEF,UAAW,EAAC;AACpC;AAEA,OAAO,SAASG,YAAYA,CAAA,EAAG;EAC7B,OAAQ,gBAAe,EAAEF,aAAc,EAAC;AAC1C;AAEA,OAAO,SAASG,MAAMA,CACpBC,IAAI,EACJ;EACEC,KAAK;EACLC,IAAI;EACJC,SAAS,EAAEC,UAAU;EACrBC,eAAe;EACfC,UAAU;EACVC,MAAM;EACNC,IAAI;EACJC,WAAW;EACXC,MAAM;EACNC,WAAW;EACXC,aAAa;EACbC,cAAc;EACdC,aAAa;EACbC,gBAAgB;EAChBC,eAAe;EACfC,gBAAgB;EAChBC,OAAO;EACPC,YAAY;EACZC,WAAW;EACXC,UAAU;EACVC,aAAa;EACbC,cAAc;EACdC;AACF,CAAC,EACD;EACErB,SAAS,EAAEsB,UAAU;EACrBjB,IAAI,EAAEkB,WAAW,GAAG,cAAc;EAClCjB,WAAW,EAAEkB,kBAAkB;EAC/BjB,MAAM,EAAEkB,aAAa,GAAG,MAAM;EAC9BhB,aAAa,EAAEiB,oBAAoB;EACnClB,WAAW,EAAEmB,kBAAkB;EAC/BhB,aAAa,EAAEiB,oBAAoB;EACnClB,cAAc,EAAEmB,qBAAqB;EACrCjB,gBAAgB,EAAEkB,uBAAuB;EACzCZ,UAAU,EAAEa;AACd,CAAC,EACD;EACA;EACA,IAAIR,WAAW,KAAK,IAAI,EAAE;IACxBlB,IAAI,GAAG,IAAI;IACXC,WAAW,GAAG,IAAI;EACpB;;EAEA;EACA,IAAImB,aAAa,KAAK,IAAI,EAAE;IAC1BlB,MAAM,GAAG,IAAI;IACbE,aAAa,GAAG,IAAI;EACtB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI7B,SAAS,CAAC2C,WAAW,CAAC,EAAE;IAC1B,IAAI,CAAC3C,SAAS,CAAC6C,aAAa,CAAC,KAAK,CAAC7C,SAAS,CAACyB,IAAI,CAAC,IAAIgB,QAAQ,EAAEhB,IAAI,CAAC,EAAEoB,aAAa,GAAG,MAAM;EAC/F,CAAC,MAAM;IACL,IAAI7C,SAAS,CAAC6C,aAAa,CAAC,KAAK,CAAC7C,SAAS,CAAC2B,MAAM,CAAC,IAAIc,QAAQ,EAAEd,MAAM,CAAC,EAAEgB,WAAW,GAAG,MAAM;EAChG;EAEA,MAAM,CAACS,KAAK,EAAEC,KAAK,CAAC,GAAGnD,iBAAiB,CAACuB,IAAI,EAAEkB,WAAW,CAAC;EAC3D,MAAM,CAACW,YAAY,EAAEC,YAAY,CAAC,GAAGpD,kBAAkB,CAACuB,WAAW,EAAEkB,kBAAkB,CAAC;EACxF,MAAM,CAACY,OAAO,EAAEC,OAAO,CAAC,GAAGvD,iBAAiB,CAACyB,MAAM,EAAEkB,aAAa,CAAC;EACnE,MAAM,CAACa,cAAc,EAAEC,cAAc,CAAC,GAAGxD,kBAAkB,CAAC0B,aAAa,EAAEiB,oBAAoB,CAAC;EAChG,MAAM,CAACc,QAAQ,EAAEC,QAAQ,CAAC,GAAG1D,kBAAkB,CAACgC,OAAO,CAAC;;EAExD;EACA;EACA;EACA;EACA,IAAI,CAACpC,MAAM,CAAC0D,OAAO,CAAC,EAAE;IACpB,IAAI7B,WAAW,KAAKkC,SAAS,EAAElC,WAAW,GAAGmB,kBAAkB;IAC/D,IAAIhB,aAAa,KAAK+B,SAAS,EAAE/B,aAAa,GAAGiB,oBAAoB;IACrE,IAAIlB,cAAc,KAAKgC,SAAS,EAAEhC,cAAc,GAAGmB,qBAAqB;;IAExE;IACA;IACA,IAAIjB,gBAAgB,KAAK8B,SAAS,IAAI,CAAC7D,OAAO,CAAC6B,cAAc,CAAC,EAAEE,gBAAgB,GAAGkB,uBAAuB;;IAE1G;IACA;IACA,IAAI,CAACnD,MAAM,CAACsD,KAAK,CAAC,IAAIf,UAAU,KAAKwB,SAAS,EAAExB,UAAU,GAAGa,iBAAiB;EAChF;EAEA,MAAM,CAACY,YAAY,EAAEC,YAAY,CAAC,GAAG7D,kBAAkB,CAACyB,WAAW,CAAC;;EAEpE;EACA,IAAIe,WAAW,KAAK,IAAI,EAAE;IACxB1B,IAAI,CAACQ,IAAI,GAAGwC,aAAa,CAACZ,KAAK,EAAE,cAAc,CAAC;IAChDpC,IAAI,CAACS,WAAW,GAAGwC,aAAa,CAACX,YAAY,EAAE,CAAC,CAAC;EACnD;;EAEA;EACA,IAAIV,aAAa,KAAK,IAAI,EAAE;IAC1B5B,IAAI,CAACU,MAAM,GAAGsC,aAAa,CAACR,OAAO,EAAE,MAAM,CAAC;IAC5CxC,IAAI,CAACW,WAAW,GAAGsC,aAAa,CAACF,YAAY,EAAE,CAAC,CAAC;IACjD/C,IAAI,CAACY,aAAa,GAAGqC,aAAa,CAACP,cAAc,EAAE,CAAC,CAAC;IACrD1C,IAAI,CAACa,cAAc,GAAGmC,aAAa,CAACnC,cAAc,EAAE,OAAO,CAAC;IAC5Db,IAAI,CAACc,aAAa,GAAGkC,aAAa,CAAClC,aAAa,EAAE,MAAM,CAAC;IACzDd,IAAI,CAACe,gBAAgB,GAAGkC,aAAa,CAAClC,gBAAgB,EAAE,CAAC,CAAC;IAC1Df,IAAI,CAACgB,eAAe,GAAGgC,aAAa,CAAChC,eAAe,EAAE,MAAM,CAAC;IAC7DhB,IAAI,CAACiB,gBAAgB,GAAG+B,aAAa,CAAC/B,gBAAgB,EAAE,GAAG,CAAC;EAC9D;EAEAjB,IAAI,CAACO,MAAM,GAAGlB,MAAM,CAACkB,MAAM,CAAC;EAC5BP,IAAI,CAACG,SAAS,GAAGd,MAAM,CAACoC,UAAU,CAAC;EACnCzB,IAAI,CAACK,eAAe,GAAGhB,MAAM,CAACgB,eAAe,CAAC;EAC9CL,IAAI,CAACM,UAAU,GAAGjB,MAAM,CAACiB,UAAU,CAAC;EACpCN,IAAI,CAACkB,OAAO,GAAG+B,aAAa,CAACL,QAAQ,EAAE,CAAC,CAAC;EACzC5C,IAAI,CAACmB,YAAY,GAAG6B,aAAa,CAAC7B,YAAY,EAAE,QAAQ,CAAC;EACzDnB,IAAI,CAACoB,WAAW,GAAG4B,aAAa,CAAC5B,WAAW,EAAE,MAAM,CAAC;EACrDpB,IAAI,CAACqB,UAAU,GAAG2B,aAAa,CAAC3B,UAAU,EAAE,QAAQ,CAAC;EACrDrB,IAAI,CAACsB,aAAa,GAAG0B,aAAa,CAAC1B,aAAa,EAAE,MAAM,CAAC;EACzDtB,IAAI,CAACuB,cAAc,GAAGyB,aAAa,CAACzB,cAAc,EAAE,MAAM,CAAC;EAE3D,OAAO;IACLtB,KAAK,EAAE;MAACiD,KAAK,EAAEjD,KAAK;MAAEkD,QAAQ,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAI,CAAC;IACnDlD,IAAI,EAAE;MAACgD,KAAK,EAAEhD,IAAI;MAAEiD,QAAQ,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAI,CAAC;IACjDjD,SAAS,EAAE;MAAC+C,KAAK,EAAE9C,UAAU;MAAE+C,QAAQ,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAI,CAAC;IAC5D5C,IAAI,EAAE;MAAC0C,KAAK,EAAEf,KAAK;MAAEkB,KAAK,EAAE,MAAM;MAAEF,QAAQ,EAAE;IAAI,CAAC;IACnD1C,WAAW,EAAE;MAACyC,KAAK,EAAEb,YAAY;MAAEgB,KAAK,EAAE,MAAM;MAAEF,QAAQ,EAAE;IAAI,CAAC;IACjEzC,MAAM,EAAE;MAACwC,KAAK,EAAEX,OAAO;MAAEc,KAAK,EAAE,MAAM;MAAEF,QAAQ,EAAE;IAAI,CAAC;IACvDvC,aAAa,EAAE;MAACsC,KAAK,EAAET,cAAc;MAAEY,KAAK,EAAE,MAAM;MAAEF,QAAQ,EAAE;IAAI,CAAC;IACrExC,WAAW,EAAE;MAACuC,KAAK,EAAEJ,YAAY;MAAEK,QAAQ,EAAE;IAAI,CAAC;IAClDjC,OAAO,EAAE;MAACgC,KAAK,EAAEP,QAAQ;MAAEU,KAAK,EAAE,MAAM;MAAEF,QAAQ,EAAE;IAAI;EAC1D,CAAC;AACH;;AAEA;AACA,OAAO,SAASG,UAAUA,CAACC,SAAS,EAAEC,CAAC,EAAE;EACvC,IAAIA,CAAC,EACHD,SAAS,CACNH,MAAM,CAAEK,CAAC,IAAK7E,QAAQ,CAAC4E,CAAC,CAACC,CAAC,CAAC,CAAC,CAAC,CAC7BC,MAAM,CAAC,OAAO,CAAC,CACfC,IAAI,CAACC,SAAS,EAAEJ,CAAC,CAAC;AACzB;;AAEA;AACA,OAAO,SAASK,eAAeA,CAACN,SAAS,EAAEC,CAAC,EAAE;EAC5C,IAAIA,CAAC,EACHD,SAAS,CACNH,MAAM,CAAC,CAAC,CAACK,CAAC,CAAC,KAAK7E,QAAQ,CAAC4E,CAAC,CAACC,CAAC,CAAC,CAAC,CAAC,CAC/BC,MAAM,CAAC,OAAO,CAAC,CACfC,IAAI,CAACG,cAAc,EAAEN,CAAC,CAAC;AAC9B;AAEA,OAAO,SAASI,SAASA,CAACL,SAAS,EAAEQ,CAAC,EAAE;EACtC,IAAIA,CAAC,EAAER,SAAS,CAACS,IAAI,CAAEP,CAAC,IAAK5E,aAAa,CAACkF,CAAC,CAACN,CAAC,CAAC,CAAC,CAAC;AACnD;AAEA,OAAO,SAASK,cAAcA,CAACP,SAAS,EAAEQ,CAAC,EAAE;EAC3C,IAAIA,CAAC,EAAER,SAAS,CAACS,IAAI,CAAC,CAAC,CAACP,CAAC,CAAC,KAAK5E,aAAa,CAACkF,CAAC,CAACN,CAAC,CAAC,CAAC,CAAC;AACrD;AAEA,OAAO,SAASQ,kBAAkBA,CAChCV,SAAS,EACT;EAAChD,MAAM;EAAE2D;AAAG,CAAC,EACb;EACE/D,SAAS,EAAEgE,EAAE;EACblE,KAAK,EAAE8D,CAAC;EACRvD,IAAI,EAAE4D,CAAC;EACP3D,WAAW,EAAE4D,EAAE;EACf3D,MAAM,EAAE4D,CAAC;EACT1D,aAAa,EAAE2D,EAAE;EACjB5D,WAAW,EAAE6D,EAAE;EACftD,OAAO,EAAEuD,CAAC;EACVvE,IAAI,EAAEwE;AACR,CAAC,EACD;EACA,IAAIP,EAAE,EAAEQ,SAAS,CAACpB,SAAS,EAAE,YAAY,EAAGE,CAAC,IAAKU,EAAE,CAACV,CAAC,CAAC,CAAC;EACxD,IAAIW,CAAC,EAAEO,SAAS,CAACpB,SAAS,EAAE,MAAM,EAAGE,CAAC,IAAKW,CAAC,CAACX,CAAC,CAAC,CAAC;EAChD,IAAIY,EAAE,EAAEM,SAAS,CAACpB,SAAS,EAAE,cAAc,EAAGE,CAAC,IAAKY,EAAE,CAACZ,CAAC,CAAC,CAAC;EAC1D,IAAIa,CAAC,EAAEK,SAAS,CAACpB,SAAS,EAAE,QAAQ,EAAGE,CAAC,IAAKa,CAAC,CAACb,CAAC,CAAC,CAAC;EAClD,IAAIc,EAAE,EAAEI,SAAS,CAACpB,SAAS,EAAE,gBAAgB,EAAGE,CAAC,IAAKc,EAAE,CAACd,CAAC,CAAC,CAAC;EAC5D,IAAIe,EAAE,EAAEG,SAAS,CAACpB,SAAS,EAAE,cAAc,EAAGE,CAAC,IAAKe,EAAE,CAACf,CAAC,CAAC,CAAC;EAC1D,IAAIgB,CAAC,EAAEE,SAAS,CAACpB,SAAS,EAAE,SAAS,EAAGE,CAAC,IAAKgB,CAAC,CAAChB,CAAC,CAAC,CAAC;EACnD,IAAIiB,CAAC,EAAEE,SAAS,CAACrB,SAAS,EAAGE,CAAC,IAAKiB,CAAC,CAACjB,CAAC,CAAC,EAAElD,MAAM,CAAC;EAChD,IAAI,CAAC2D,GAAG,EAAEZ,UAAU,CAACC,SAAS,EAAEQ,CAAC,CAAC;AACpC;AAEA,OAAO,SAASc,yBAAyBA,CACvCtB,SAAS,EACT;EAAChD,MAAM;EAAE2D;AAAG,CAAC,EACb;EACE/D,SAAS,EAAEgE,EAAE;EACblE,KAAK,EAAE8D,CAAC;EACRvD,IAAI,EAAE4D,CAAC;EACP3D,WAAW,EAAE4D,EAAE;EACf3D,MAAM,EAAE4D,CAAC;EACT1D,aAAa,EAAE2D,EAAE;EACjB5D,WAAW,EAAE6D,EAAE;EACftD,OAAO,EAAEuD,CAAC;EACVvE,IAAI,EAAEwE;AACR,CAAC,EACD;EACA,IAAIP,EAAE,EAAEQ,SAAS,CAACpB,SAAS,EAAE,YAAY,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKU,EAAE,CAACV,CAAC,CAAC,CAAC;EAC1D,IAAIW,CAAC,EAAEO,SAAS,CAACpB,SAAS,EAAE,MAAM,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKW,CAAC,CAACX,CAAC,CAAC,CAAC;EAClD,IAAIY,EAAE,EAAEM,SAAS,CAACpB,SAAS,EAAE,cAAc,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKY,EAAE,CAACZ,CAAC,CAAC,CAAC;EAC5D,IAAIa,CAAC,EAAEK,SAAS,CAACpB,SAAS,EAAE,QAAQ,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKa,CAAC,CAACb,CAAC,CAAC,CAAC;EACpD,IAAIc,EAAE,EAAEI,SAAS,CAACpB,SAAS,EAAE,gBAAgB,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKc,EAAE,CAACd,CAAC,CAAC,CAAC;EAC9D,IAAIe,EAAE,EAAEG,SAAS,CAACpB,SAAS,EAAE,cAAc,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKe,EAAE,CAACf,CAAC,CAAC,CAAC;EAC5D,IAAIgB,CAAC,EAAEE,SAAS,CAACpB,SAAS,EAAE,SAAS,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKgB,CAAC,CAAChB,CAAC,CAAC,CAAC;EACrD,IAAIiB,CAAC,EAAEE,SAAS,CAACrB,SAAS,EAAE,CAAC,CAACE,CAAC,CAAC,KAAKiB,CAAC,CAACjB,CAAC,CAAC,EAAElD,MAAM,CAAC;EAClD,IAAI,CAAC2D,GAAG,EAAEL,eAAe,CAACN,SAAS,EAAEQ,CAAC,CAAC;AACzC;AAEA,SAASe,eAAeA,CACtB;EACE3E,SAAS,EAAEgE,EAAE;EACblE,KAAK,EAAE8D,CAAC;EACRvD,IAAI,EAAE4D,CAAC;EACP3D,WAAW,EAAE4D,EAAE;EACf3D,MAAM,EAAE4D,CAAC;EACT1D,aAAa,EAAE2D,EAAE;EACjB5D,WAAW,EAAE6D,EAAE;EACftD,OAAO,EAAEuD,CAAC;EACVvE,IAAI,EAAEwE;AACR,CAAC,EACD;EAACR;AAAG,CAAC,EACL;EACA,OAAO,CAACC,EAAE,EAAED,GAAG,GAAGrB,SAAS,GAAGkB,CAAC,EAAEK,CAAC,EAAEC,EAAE,EAAEC,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAEC,CAAC,EAAEC,CAAC,CAAC,CAACtB,MAAM,CAAE2B,CAAC,IAAKA,CAAC,KAAKlC,SAAS,CAAC;AACzF;AAEA,OAAO,SAASmC,MAAMA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAC9B,MAAMC,CAAC,GAAG7G,KAAK,CAAC0G,CAAC,EAAGxB,CAAC,IAAKyB,CAAC,CAACzB,CAAC,CAAC,CAAC;EAC/B,IAAI0B,CAAC,KAAKtC,SAAS,IAAIuC,CAAC,CAACC,IAAI,GAAI,CAAC,GAAGJ,CAAC,CAACK,MAAM,IAAK,CAAC,EAAE;IACnDhG,IAAI,CACD,8SACH,CAAC;EACH;EACA,OAAO8F,CAAC,CAACG,MAAM,CAAC,CAAC;AACnB;AAEA,OAAO,UAAUC,UAAUA,CAACP,CAAC,EAAEQ,QAAQ,EAAEzF,IAAI,EAAEwB,QAAQ,EAAE;EACvD,MAAM;IAAC2D;EAAC,CAAC,GAAGnF,IAAI;EAChB,MAAM;IAACmF,CAAC,EAAED;EAAC,CAAC,GAAG1D,QAAQ,CAAC,CAAC;EACzB,MAAMkE,CAAC,GAAGZ,eAAe,CAACtD,QAAQ,EAAExB,IAAI,CAAC,CAAC,CAAC;EAC3C,MAAM2F,CAAC,GAAG,CAAC,GAAGF,QAAQ,EAAE,GAAGC,CAAC,CAAC,CAAC,CAAC;;EAE/B;EACA,KAAK,MAAMN,CAAC,IAAIF,CAAC,GAAGF,MAAM,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAG,CAACF,CAAC,CAAC,EAAE;IACzC,IAAIW,EAAE,CAAC,CAAC;IACR,IAAIC,EAAE,CAAC,CAAC;IACRC,GAAG,EAAE,KAAK,MAAMrC,CAAC,IAAI2B,CAAC,EAAE;MACtB;MACA,KAAK,MAAML,CAAC,IAAIY,CAAC,EAAE;QACjB,IAAI,CAAChH,OAAO,CAACoG,CAAC,CAACtB,CAAC,CAAC,CAAC,EAAE;UAClB,IAAIoC,EAAE,EAAEA,EAAE,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC;UACnB,SAASD,GAAG;QACd;MACF;;MAEA;MACA;MACA,IAAIF,EAAE,KAAK/C,SAAS,EAAE;QACpB,IAAIgD,EAAE,EAAE,MAAMA,EAAE;QACfD,EAAE,GAAGF,CAAC,CAACM,GAAG,CAAEjB,CAAC,IAAK5F,KAAK,CAAC4F,CAAC,CAACtB,CAAC,CAAC,CAAC,CAAC,EAAIoC,EAAE,GAAG,CAACpC,CAAC,CAAE;QAC5C;MACF;;MAEA;MACA;MACA;MACAoC,EAAE,CAACE,IAAI,CAACtC,CAAC,CAAC;MACV,KAAK,IAAIwC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,CAAC,CAACJ,MAAM,EAAE,EAAEW,CAAC,EAAE;QACjC,MAAMC,CAAC,GAAG/G,KAAK,CAACuG,CAAC,CAACO,CAAC,CAAC,CAACxC,CAAC,CAAC,CAAC;QACxB,IAAIyC,CAAC,KAAKN,EAAE,CAACK,CAAC,CAAC,EAAE;UACf,MAAMJ,EAAE;UACPD,EAAE,GAAGF,CAAC,CAACM,GAAG,CAAEjB,CAAC,IAAK5F,KAAK,CAAC4F,CAAC,CAACtB,CAAC,CAAC,CAAC,CAAC,EAAIoC,EAAE,GAAG,CAACpC,CAAC,CAAE;UAC5C,SAASqC,GAAG;QACd;MACF;IACF;;IAEA;IACA,IAAID,EAAE,EAAE,MAAMA,EAAE;EAClB;AACF;;AAEA;AACA,SAASM,SAASA,CAAC5C,SAAS,EAAEvD,IAAI,EAAEoG,UAAU,EAAEC,OAAO,EAAE;EACvD,IAAIC,OAAO;EACX,MAAM;IAACC,IAAI,GAAGF,OAAO,CAACE;EAAI,CAAC,GAAGvG,IAAI;EAClC,QAAQuG,IAAI;IACV,KAAK,OAAO;MAAE;QACZ;QACA;QACA;QACA;QACAhD,SAAS,GAAG7E,MAAM,CAAC,OAAO,EAAE2H,OAAO,CAAC,CAACG,IAAI,CAAC,YAAY;UACpD,IAAI,CAACC,WAAW,CAAClD,SAAS,CAACmD,IAAI,CAAC,CAAC,CAAC;UAClCnD,SAAS,CAACmD,IAAI,GAAG,MAAM,IAAI,CAAC,CAAC;QAC/B,CAAC,CAAC;;QACFJ,OAAO,GAAGK,YAAY,CAACN,OAAO,EAAED,UAAU,CAAC;QAC3C;MACF;IACA,KAAK,QAAQ;MAAE;QACbE,OAAO,GAAGM,iBAAiB,CAACP,OAAO,CAAC;QACpC;MACF;EACF;EACA;EACA;EACA;EACA1B,SAAS,CAACpB,SAAS,EAAE,YAAY,EAAEvD,IAAI,CAACG,SAAS,CAAC;EAClDwE,SAAS,CAACpB,SAAS,EAAE,kBAAkB,EAAEvD,IAAI,CAACK,eAAe,CAAC;EAC9DsE,SAAS,CAACpB,SAAS,EAAE,aAAa,EAAEvD,IAAI,CAACM,UAAU,CAAC;EACpDqE,SAAS,CAACpB,SAAS,EAAE,WAAW,EAAE+C,OAAO,CAAC;AAC5C;AAEA,SAASO,WAAWA,CAACN,IAAI,EAAE;EACzB,MAAMO,KAAK,GAAG,IAAIC,OAAO,CAAC,CAAC;EAC3B,OAAO,CAACV,OAAO,EAAED,UAAU,KAAK;IAC9B,IAAIY,GAAG,GAAGF,KAAK,CAACG,GAAG,CAACZ,OAAO,CAAC;IAC5B,IAAI,CAACW,GAAG,EAAE;MACR,MAAME,EAAE,GAAGrH,SAAS,CAAC,CAAC;MACtBpB,MAAM,CAAC4H,OAAO,CAACc,eAAe,CAAC,CAACzD,MAAM,CAAC,UAAU,CAAC,CAAC0D,IAAI,CAAC,IAAI,EAAEF,EAAE,CAAC,CAACvD,IAAI,CAAC4C,IAAI,EAAEF,OAAO,EAAED,UAAU,CAAC;MACjGU,KAAK,CAACO,GAAG,CAAChB,OAAO,EAAGW,GAAG,GAAI,QAAOE,EAAG,GAAG,CAAC;IAC3C;IACA,OAAOF,GAAG;EACZ,CAAC;AACH;AAEA,MAAML,YAAY,GAAGE,WAAW,CAAC,CAACS,QAAQ,EAAEjB,OAAO,EAAED,UAAU,KAAK;EAClE,MAAM;IAACmB,KAAK;IAAEC,MAAM;IAAEC,UAAU;IAAEC,WAAW;IAAEC,SAAS;IAAEC;EAAY,CAAC,GAAGxB,UAAU;EACpFkB,QAAQ,CACL5D,MAAM,CAAC,MAAM,CAAC,CACd0D,IAAI,CAAC,GAAG,EAAEK,UAAU,CAAC,CACrBL,IAAI,CAAC,GAAG,EAAEO,SAAS,CAAC,CACpBP,IAAI,CAAC,OAAO,EAAEG,KAAK,GAAGG,WAAW,GAAGD,UAAU,CAAC,CAC/CL,IAAI,CAAC,QAAQ,EAAEI,MAAM,GAAGG,SAAS,GAAGC,YAAY,CAAC;AACtD,CAAC,CAAC;AAEF,MAAMhB,iBAAiB,GAAGC,WAAW,CAAC,CAACS,QAAQ,EAAEjB,OAAO,KAAK;EAC3D,MAAM;IAACwB;EAAU,CAAC,GAAGxB,OAAO;EAC5B,IAAI,CAACwB,UAAU,EAAE,MAAM,IAAIC,KAAK,CAAE,gDAA+C,CAAC;EAClFR,QAAQ,CAAC5D,MAAM,CAAC,MAAM,CAAC,CAAC0D,IAAI,CAAC,GAAG,EAAE9I,OAAO,CAACuJ,UAAU,CAAC,CAAC;IAACE,IAAI,EAAE;EAAQ,CAAC,CAAC,CAAC;AAC1E,CAAC,CAAC;;AAEF;AACA,OAAO,SAASC,mBAAmBA,CAACzE,SAAS,EAAEvD,IAAI,EAAEoG,UAAU,EAAEC,OAAO,EAAE;EACxEF,SAAS,CAAC5C,SAAS,EAAEvD,IAAI,EAAEoG,UAAU,EAAEC,OAAO,CAAC;EAC/C1B,SAAS,CAACpB,SAAS,EAAE,OAAO,EAAEvD,IAAI,CAACiI,SAAS,CAAC;EAC7CtD,SAAS,CAACpB,SAAS,EAAE,MAAM,EAAEvD,IAAI,CAACQ,IAAI,CAAC;EACvCmE,SAAS,CAACpB,SAAS,EAAE,cAAc,EAAEvD,IAAI,CAACS,WAAW,CAAC;EACtDkE,SAAS,CAACpB,SAAS,EAAE,QAAQ,EAAEvD,IAAI,CAACU,MAAM,CAAC;EAC3CiE,SAAS,CAACpB,SAAS,EAAE,cAAc,EAAEvD,IAAI,CAACW,WAAW,CAAC;EACtDgE,SAAS,CAACpB,SAAS,EAAE,gBAAgB,EAAEvD,IAAI,CAACY,aAAa,CAAC;EAC1D+D,SAAS,CAACpB,SAAS,EAAE,iBAAiB,EAAEvD,IAAI,CAACa,cAAc,CAAC;EAC5D8D,SAAS,CAACpB,SAAS,EAAE,gBAAgB,EAAEvD,IAAI,CAACc,aAAa,CAAC;EAC1D6D,SAAS,CAACpB,SAAS,EAAE,mBAAmB,EAAEvD,IAAI,CAACe,gBAAgB,CAAC;EAChE4D,SAAS,CAACpB,SAAS,EAAE,kBAAkB,EAAEvD,IAAI,CAACgB,eAAe,CAAC;EAC9D2D,SAAS,CAACpB,SAAS,EAAE,mBAAmB,EAAEvD,IAAI,CAACiB,gBAAgB,CAAC;EAChE0D,SAAS,CAACpB,SAAS,EAAE,iBAAiB,EAAEvD,IAAI,CAACuB,cAAc,CAAC;EAC5DoD,SAAS,CAACpB,SAAS,EAAE,QAAQ,EAAEvD,IAAI,CAACoB,WAAW,CAAC;EAChDuD,SAAS,CAACpB,SAAS,EAAE,aAAa,EAAEvD,IAAI,CAACqB,UAAU,CAAC;EACpD,MAAM;IAACC,aAAa,GAAG+E,OAAO,CAAC6B,aAAa,KAAK,KAAK,GAAG,MAAM,GAAGrF;EAAS,CAAC,GAAG7C,IAAI;EACnF2E,SAAS,CAACpB,SAAS,EAAE,gBAAgB,EAAEjC,aAAa,CAAC;AACvD;AAEA,OAAO,SAAS6G,iBAAiBA,CAAC5E,SAAS,EAAEvD,IAAI,EAAE;EACjDoI,UAAU,CAAC7E,SAAS,EAAE,gBAAgB,EAAEvD,IAAI,CAACmB,YAAY,CAAC;EAC1DwD,SAAS,CAACpB,SAAS,EAAE,SAAS,EAAEvD,IAAI,CAACkB,OAAO,CAAC;AAC/C;AAEA,SAAS0D,SAASA,CAACrB,SAAS,EAAErD,IAAI,EAAEK,MAAM,EAAE;EAC1CgD,SAAS,CAACiD,IAAI,CAAC,UAAU/C,CAAC,EAAE;IAC1B,MAAM4E,CAAC,GAAGnI,IAAI,CAACuD,CAAC,CAAC;IACjB,IAAI4E,CAAC,IAAI,IAAI,EAAE;MACb,MAAMC,CAAC,GAAG,IAAI,CAACC,aAAa,CAACC,eAAe,CAAChK,UAAU,CAACiK,GAAG,EAAE,GAAG,CAAC;MACjEH,CAAC,CAACI,YAAY,CAAC,MAAM,EAAE,SAAS,CAAC;MACjCJ,CAAC,CAACK,cAAc,CAACnK,UAAU,CAACoK,KAAK,EAAE,MAAM,EAAEP,CAAC,CAAC;MAC7C,IAAI9H,MAAM,IAAI,IAAI,EAAE+H,CAAC,CAACI,YAAY,CAAC,QAAQ,EAAEnI,MAAM,CAAC;MACpD,IAAI,CAACsI,UAAU,CAACC,YAAY,CAACR,CAAC,EAAE,IAAI,CAAC,CAAC7B,WAAW,CAAC,IAAI,CAAC;IACzD;EACF,CAAC,CAAC;AACJ;AAEA,OAAO,SAAS9B,SAASA,CAACpB,SAAS,EAAEwF,IAAI,EAAE7F,KAAK,EAAE;EAChD,IAAIA,KAAK,IAAI,IAAI,EAAEK,SAAS,CAAC6D,IAAI,CAAC2B,IAAI,EAAE7F,KAAK,CAAC;AAChD;AAEA,OAAO,SAASkF,UAAUA,CAAC7E,SAAS,EAAEwF,IAAI,EAAE7F,KAAK,EAAE;EACjD,IAAIA,KAAK,IAAI,IAAI,EAAEK,SAAS,CAACyF,KAAK,CAACD,IAAI,EAAE7F,KAAK,CAAC;AACjD;AAEA,OAAO,SAAS+F,cAAcA,CAAC1F,SAAS,EAAEvD,IAAI,EAAE;EAACkJ,CAAC;EAAEC;AAAC,CAAC,EAAEC,EAAE,GAAG7J,MAAM,EAAE8J,EAAE,GAAG9J,MAAM,EAAE;EAChF6J,EAAE,IAAIpJ,IAAI,CAACsJ,EAAE;EACbD,EAAE,IAAIrJ,IAAI,CAACuJ,EAAE;EACb,IAAIL,CAAC,EAAEM,SAAS,EAAEJ,EAAE,IAAIF,CAAC,CAACM,SAAS,CAAC,CAAC,GAAG,CAAC;EACzC,IAAIL,CAAC,EAAEK,SAAS,EAAEH,EAAE,IAAIF,CAAC,CAACK,SAAS,CAAC,CAAC,GAAG,CAAC;EACzC,IAAIJ,EAAE,IAAIC,EAAE,EAAE9F,SAAS,CAAC6D,IAAI,CAAC,WAAW,EAAG,aAAYgC,EAAG,IAAGC,EAAG,GAAE,CAAC;AACrE;AAEA,OAAO,SAASrG,aAAaA,CAACE,KAAK,EAAEuG,YAAY,EAAE;EACjD,IAAI,CAACvG,KAAK,GAAG7D,MAAM,CAAC6D,KAAK,CAAC,MAAMuG,YAAY,EAAE,OAAOvG,KAAK;AAC5D;AAEA,OAAO,SAASD,aAAaA,CAACC,KAAK,EAAEuG,YAAY,EAAE;EACjD,IAAI,CAACvG,KAAK,GAAG9D,MAAM,CAAC8D,KAAK,CAAC,MAAMuG,YAAY,EAAE,OAAOvG,KAAK;AAC5D;;AAEA;AACA,MAAMwG,cAAc,GAClB,8JAA8J;AAEhK,OAAO,SAASC,cAAcA,CAACZ,IAAI,EAAE;EACnC;EACA;EACA,IAAIA,IAAI,KAAKlG,SAAS,EAAE,OAAO,aAAa;EAC5CkG,IAAI,GAAI,GAAEA,IAAK,EAAC;EAChB,IAAI,CAACW,cAAc,CAACE,IAAI,CAACb,IAAI,CAAC,EAAE,MAAM,IAAIjB,KAAK,CAAE,uBAAsBiB,IAAK,EAAC,CAAC;EAC9E,OAAOA,IAAI;AACb;AAEA,OAAO,SAASc,iBAAiBA,CAACtG,SAAS,EAAEyF,KAAK,EAAE;EAClD,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7BzF,SAAS,CAACuG,QAAQ,CAAC,OAAO,EAAEd,KAAK,CAAC;EACpC,CAAC,MAAM,IAAIA,KAAK,IAAI,IAAI,EAAE;IACxB,KAAK,MAAMe,OAAO,IAAIxG,SAAS,EAAE;MAC/ByG,MAAM,CAACC,MAAM,CAACF,OAAO,CAACf,KAAK,EAAEA,KAAK,CAAC;IACrC;EACF;AACF;AAEA,OAAO,SAASkB,gBAAgBA,CAAC;EAACC;AAAW,CAAC,EAAE;EAAC5C,KAAK;EAAEC,MAAM;EAAEG,SAAS;EAAED,WAAW;EAAEE,YAAY;EAAEH;AAAU,CAAC,EAAE;EACjH,OAAO,CACL,OAAO,CAACmC,IAAI,CAACO,WAAW,CAAC,GACrB1C,UAAU,GACV,QAAQ,CAACmC,IAAI,CAACO,WAAW,CAAC,GAC1B5C,KAAK,GAAGG,WAAW,GACnB,CAACD,UAAU,GAAGF,KAAK,GAAGG,WAAW,IAAI,CAAC,EAC1C,MAAM,CAACkC,IAAI,CAACO,WAAW,CAAC,GACpBxC,SAAS,GACT,SAAS,CAACiC,IAAI,CAACO,WAAW,CAAC,GAC3B3C,MAAM,GAAGI,YAAY,GACrB,CAACD,SAAS,GAAGH,MAAM,GAAGI,YAAY,IAAI,CAAC,CAC5C;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}