{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { InternMap, cross, rollup, sum } from \"d3\";\nimport { keyof, map, range } from \"./options.js\";\nimport { createScales } from \"./scales.js\";\n\n// Returns an array of {x?, y?, i} objects representing the facet domain.\nexport function createFacets(channelsByScale, options) {\n  const {\n    fx,\n    fy\n  } = createScales(channelsByScale, options);\n  const fxDomain = fx?.scale.domain();\n  const fyDomain = fy?.scale.domain();\n  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x, y], i) => ({\n    x,\n    y,\n    i\n  })) : fxDomain ? fxDomain.map((x, i) => ({\n    x,\n    i\n  })) : fyDomain ? fyDomain.map((y, i) => ({\n    y,\n    i\n  })) : undefined;\n}\nexport function recreateFacets(facets, {\n  x: X,\n  y: Y\n}) {\n  X &&= facetIndex(X);\n  Y &&= facetIndex(Y);\n  return facets.filter(X && Y // remove any facets no longer present in the domain\n  ? f => X.has(f.x) && Y.has(f.y) : X ? f => X.has(f.x) : f => Y.has(f.y)).sort(X && Y // reorder facets to match the new scale domains\n  ? (a, b) => X.get(a.x) - X.get(b.x) || Y.get(a.y) - Y.get(b.y) : X ? (a, b) => X.get(a.x) - X.get(b.x) : (a, b) => Y.get(a.y) - Y.get(b.y));\n}\n\n// Returns a (possibly nested) Map of [[key1, index1], [key2, index2], …]\n// representing the data indexes associated with each facet.\nexport function facetGroups(data, {\n  fx,\n  fy\n}) {\n  const I = range(data);\n  const FX = fx?.value;\n  const FY = fy?.value;\n  return fx && fy ? rollup(I, G => (G.fx = FX[G[0]], G.fy = FY[G[0]], G), i => FX[i], i => FY[i]) : fx ? rollup(I, G => (G.fx = FX[G[0]], G), i => FX[i]) : rollup(I, G => (G.fy = FY[G[0]], G), i => FY[i]);\n}\nexport function facetTranslator(fx, fy, {\n  marginTop,\n  marginLeft\n}) {\n  return fx && fy ? ({\n    x,\n    y\n  }) => `translate(${fx(x) - marginLeft},${fy(y) - marginTop})` : fx ? ({\n    x\n  }) => `translate(${fx(x) - marginLeft},0)` : ({\n    y\n  }) => `translate(0,${fy(y) - marginTop})`;\n}\n\n// Returns an index that for each facet lists all the elements present in other\n// facets in the original index. TODO Memoize to avoid repeated work?\nexport function facetExclude(index) {\n  const ex = [];\n  const e = new Uint32Array(sum(index, d => d.length));\n  for (const i of index) {\n    let n = 0;\n    for (const j of index) {\n      if (i === j) continue;\n      e.set(j, n);\n      n += j.length;\n    }\n    ex.push(e.slice(0, n));\n  }\n  return ex;\n}\nconst facetAnchors = new Map([[\"top\", facetAnchorTop], [\"right\", facetAnchorRight], [\"bottom\", facetAnchorBottom], [\"left\", facetAnchorLeft], [\"top-left\", and(facetAnchorTop, facetAnchorLeft)], [\"top-right\", and(facetAnchorTop, facetAnchorRight)], [\"bottom-left\", and(facetAnchorBottom, facetAnchorLeft)], [\"bottom-right\", and(facetAnchorBottom, facetAnchorRight)], [\"top-empty\", facetAnchorTopEmpty], [\"right-empty\", facetAnchorRightEmpty], [\"bottom-empty\", facetAnchorBottomEmpty], [\"left-empty\", facetAnchorLeftEmpty], [\"empty\", facetAnchorEmpty]]);\nexport function maybeFacetAnchor(facetAnchor) {\n  if (facetAnchor == null) return null;\n  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());\n  if (anchor) return anchor;\n  throw new Error(`invalid facet anchor: ${facetAnchor}`);\n}\nconst indexCache = new WeakMap();\nfunction facetIndex(V) {\n  let I = indexCache.get(V);\n  if (!I) indexCache.set(V, I = new InternMap(map(V, (v, i) => [v, i])));\n  return I;\n}\n\n// Like V.indexOf(v), but with the same semantics as InternMap.\nfunction facetIndexOf(V, v) {\n  return facetIndex(V).get(v);\n}\n\n// Like facets.find, but with the same semantics as InternMap.\nfunction facetFind(facets, x, y) {\n  x = keyof(x);\n  y = keyof(y);\n  return facets.find(f => Object.is(keyof(f.x), x) && Object.is(keyof(f.y), y));\n}\nfunction facetEmpty(facets, x, y) {\n  return facetFind(facets, x, y)?.empty;\n}\nfunction facetAnchorTop(facets, {\n  y: Y\n}, {\n  y\n}) {\n  return Y ? facetIndexOf(Y, y) === 0 : true;\n}\nfunction facetAnchorBottom(facets, {\n  y: Y\n}, {\n  y\n}) {\n  return Y ? facetIndexOf(Y, y) === Y.length - 1 : true;\n}\nfunction facetAnchorLeft(facets, {\n  x: X\n}, {\n  x\n}) {\n  return X ? facetIndexOf(X, x) === 0 : true;\n}\nfunction facetAnchorRight(facets, {\n  x: X\n}, {\n  x\n}) {\n  return X ? facetIndexOf(X, x) === X.length - 1 : true;\n}\nfunction facetAnchorTopEmpty(facets, {\n  y: Y\n}, {\n  x,\n  y,\n  empty\n}) {\n  if (empty) return false;\n  if (!Y) return;\n  const i = facetIndexOf(Y, y);\n  if (i > 0) return facetEmpty(facets, x, Y[i - 1]);\n}\nfunction facetAnchorBottomEmpty(facets, {\n  y: Y\n}, {\n  x,\n  y,\n  empty\n}) {\n  if (empty) return false;\n  if (!Y) return;\n  const i = facetIndexOf(Y, y);\n  if (i < Y.length - 1) return facetEmpty(facets, x, Y[i + 1]);\n}\nfunction facetAnchorLeftEmpty(facets, {\n  x: X\n}, {\n  x,\n  y,\n  empty\n}) {\n  if (empty) return false;\n  if (!X) return;\n  const i = facetIndexOf(X, x);\n  if (i > 0) return facetEmpty(facets, X[i - 1], y);\n}\nfunction facetAnchorRightEmpty(facets, {\n  x: X\n}, {\n  x,\n  y,\n  empty\n}) {\n  if (empty) return false;\n  if (!X) return;\n  const i = facetIndexOf(X, x);\n  if (i < X.length - 1) return facetEmpty(facets, X[i + 1], y);\n}\nfunction facetAnchorEmpty(facets, channels, {\n  empty\n}) {\n  return empty;\n}\nfunction and(a, b) {\n  return function () {\n    return a.apply(null, arguments) && b.apply(null, arguments);\n  };\n}\n\n// Facet filter, by mark; for now only the \"eq\" filter is provided.\nexport function facetFilter(facets, {\n  channels: {\n    fx,\n    fy\n  },\n  groups\n}) {\n  return fx && fy ? facets.map(({\n    x,\n    y\n  }) => groups.get(x)?.get(y) ?? []) : fx ? facets.map(({\n    x\n  }) => groups.get(x) ?? []) : facets.map(({\n    y\n  }) => groups.get(y) ?? []);\n}","map":{"version":3,"names":["InternMap","cross","rollup","sum","keyof","map","range","createScales","createFacets","channelsByScale","options","fx","fy","fxDomain","scale","domain","fyDomain","x","y","i","undefined","recreateFacets","facets","X","Y","facetIndex","filter","f","has","sort","a","b","get","facetGroups","data","I","FX","value","FY","G","facetTranslator","marginTop","marginLeft","facetExclude","index","ex","e","Uint32Array","d","length","n","j","set","push","slice","facetAnchors","Map","facetAnchorTop","facetAnchorRight","facetAnchorBottom","facetAnchorLeft","and","facetAnchorTopEmpty","facetAnchorRightEmpty","facetAnchorBottomEmpty","facetAnchorLeftEmpty","facetAnchorEmpty","maybeFacetAnchor","facetAnchor","anchor","toLowerCase","Error","indexCache","WeakMap","V","v","facetIndexOf","facetFind","find","Object","is","facetEmpty","empty","channels","apply","arguments","facetFilter","groups"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/facet.js"],"sourcesContent":["import {InternMap, cross, rollup, sum} from \"d3\";\nimport {keyof, map, range} from \"./options.js\";\nimport {createScales} from \"./scales.js\";\n\n// Returns an array of {x?, y?, i} objects representing the facet domain.\nexport function createFacets(channelsByScale, options) {\n  const {fx, fy} = createScales(channelsByScale, options);\n  const fxDomain = fx?.scale.domain();\n  const fyDomain = fy?.scale.domain();\n  return fxDomain && fyDomain\n    ? cross(fxDomain, fyDomain).map(([x, y], i) => ({x, y, i}))\n    : fxDomain\n    ? fxDomain.map((x, i) => ({x, i}))\n    : fyDomain\n    ? fyDomain.map((y, i) => ({y, i}))\n    : undefined;\n}\n\nexport function recreateFacets(facets, {x: X, y: Y}) {\n  X &&= facetIndex(X);\n  Y &&= facetIndex(Y);\n  return facets\n    .filter(\n      X && Y // remove any facets no longer present in the domain\n        ? (f) => X.has(f.x) && Y.has(f.y)\n        : X\n        ? (f) => X.has(f.x)\n        : (f) => Y.has(f.y)\n    )\n    .sort(\n      X && Y // reorder facets to match the new scale domains\n        ? (a, b) => X.get(a.x) - X.get(b.x) || Y.get(a.y) - Y.get(b.y)\n        : X\n        ? (a, b) => X.get(a.x) - X.get(b.x)\n        : (a, b) => Y.get(a.y) - Y.get(b.y)\n    );\n}\n\n// Returns a (possibly nested) Map of [[key1, index1], [key2, index2], …]\n// representing the data indexes associated with each facet.\nexport function facetGroups(data, {fx, fy}) {\n  const I = range(data);\n  const FX = fx?.value;\n  const FY = fy?.value;\n  return fx && fy\n    ? rollup(\n        I,\n        (G) => ((G.fx = FX[G[0]]), (G.fy = FY[G[0]]), G),\n        (i) => FX[i],\n        (i) => FY[i]\n      )\n    : fx\n    ? rollup(\n        I,\n        (G) => ((G.fx = FX[G[0]]), G),\n        (i) => FX[i]\n      )\n    : rollup(\n        I,\n        (G) => ((G.fy = FY[G[0]]), G),\n        (i) => FY[i]\n      );\n}\n\nexport function facetTranslator(fx, fy, {marginTop, marginLeft}) {\n  return fx && fy\n    ? ({x, y}) => `translate(${fx(x) - marginLeft},${fy(y) - marginTop})`\n    : fx\n    ? ({x}) => `translate(${fx(x) - marginLeft},0)`\n    : ({y}) => `translate(0,${fy(y) - marginTop})`;\n}\n\n// Returns an index that for each facet lists all the elements present in other\n// facets in the original index. TODO Memoize to avoid repeated work?\nexport function facetExclude(index) {\n  const ex = [];\n  const e = new Uint32Array(sum(index, (d) => d.length));\n  for (const i of index) {\n    let n = 0;\n    for (const j of index) {\n      if (i === j) continue;\n      e.set(j, n);\n      n += j.length;\n    }\n    ex.push(e.slice(0, n));\n  }\n  return ex;\n}\n\nconst facetAnchors = new Map([\n  [\"top\", facetAnchorTop],\n  [\"right\", facetAnchorRight],\n  [\"bottom\", facetAnchorBottom],\n  [\"left\", facetAnchorLeft],\n  [\"top-left\", and(facetAnchorTop, facetAnchorLeft)],\n  [\"top-right\", and(facetAnchorTop, facetAnchorRight)],\n  [\"bottom-left\", and(facetAnchorBottom, facetAnchorLeft)],\n  [\"bottom-right\", and(facetAnchorBottom, facetAnchorRight)],\n  [\"top-empty\", facetAnchorTopEmpty],\n  [\"right-empty\", facetAnchorRightEmpty],\n  [\"bottom-empty\", facetAnchorBottomEmpty],\n  [\"left-empty\", facetAnchorLeftEmpty],\n  [\"empty\", facetAnchorEmpty]\n]);\n\nexport function maybeFacetAnchor(facetAnchor) {\n  if (facetAnchor == null) return null;\n  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());\n  if (anchor) return anchor;\n  throw new Error(`invalid facet anchor: ${facetAnchor}`);\n}\n\nconst indexCache = new WeakMap();\n\nfunction facetIndex(V) {\n  let I = indexCache.get(V);\n  if (!I) indexCache.set(V, (I = new InternMap(map(V, (v, i) => [v, i]))));\n  return I;\n}\n\n// Like V.indexOf(v), but with the same semantics as InternMap.\nfunction facetIndexOf(V, v) {\n  return facetIndex(V).get(v);\n}\n\n// Like facets.find, but with the same semantics as InternMap.\nfunction facetFind(facets, x, y) {\n  x = keyof(x);\n  y = keyof(y);\n  return facets.find((f) => Object.is(keyof(f.x), x) && Object.is(keyof(f.y), y));\n}\n\nfunction facetEmpty(facets, x, y) {\n  return facetFind(facets, x, y)?.empty;\n}\n\nfunction facetAnchorTop(facets, {y: Y}, {y}) {\n  return Y ? facetIndexOf(Y, y) === 0 : true;\n}\n\nfunction facetAnchorBottom(facets, {y: Y}, {y}) {\n  return Y ? facetIndexOf(Y, y) === Y.length - 1 : true;\n}\n\nfunction facetAnchorLeft(facets, {x: X}, {x}) {\n  return X ? facetIndexOf(X, x) === 0 : true;\n}\n\nfunction facetAnchorRight(facets, {x: X}, {x}) {\n  return X ? facetIndexOf(X, x) === X.length - 1 : true;\n}\n\nfunction facetAnchorTopEmpty(facets, {y: Y}, {x, y, empty}) {\n  if (empty) return false;\n  if (!Y) return;\n  const i = facetIndexOf(Y, y);\n  if (i > 0) return facetEmpty(facets, x, Y[i - 1]);\n}\n\nfunction facetAnchorBottomEmpty(facets, {y: Y}, {x, y, empty}) {\n  if (empty) return false;\n  if (!Y) return;\n  const i = facetIndexOf(Y, y);\n  if (i < Y.length - 1) return facetEmpty(facets, x, Y[i + 1]);\n}\n\nfunction facetAnchorLeftEmpty(facets, {x: X}, {x, y, empty}) {\n  if (empty) return false;\n  if (!X) return;\n  const i = facetIndexOf(X, x);\n  if (i > 0) return facetEmpty(facets, X[i - 1], y);\n}\n\nfunction facetAnchorRightEmpty(facets, {x: X}, {x, y, empty}) {\n  if (empty) return false;\n  if (!X) return;\n  const i = facetIndexOf(X, x);\n  if (i < X.length - 1) return facetEmpty(facets, X[i + 1], y);\n}\n\nfunction facetAnchorEmpty(facets, channels, {empty}) {\n  return empty;\n}\n\nfunction and(a, b) {\n  return function () {\n    return a.apply(null, arguments) && b.apply(null, arguments);\n  };\n}\n\n// Facet filter, by mark; for now only the \"eq\" filter is provided.\nexport function facetFilter(facets, {channels: {fx, fy}, groups}) {\n  return fx && fy\n    ? facets.map(({x, y}) => groups.get(x)?.get(y) ?? [])\n    : fx\n    ? facets.map(({x}) => groups.get(x) ?? [])\n    : facets.map(({y}) => groups.get(y) ?? []);\n}\n"],"mappings":";;;;AAAA,SAAQA,SAAS,EAAEC,KAAK,EAAEC,MAAM,EAAEC,GAAG,QAAO,IAAI;AAChD,SAAQC,KAAK,EAAEC,GAAG,EAAEC,KAAK,QAAO,cAAc;AAC9C,SAAQC,YAAY,QAAO,aAAa;;AAExC;AACA,OAAO,SAASC,YAAYA,CAACC,eAAe,EAAEC,OAAO,EAAE;EACrD,MAAM;IAACC,EAAE;IAAEC;EAAE,CAAC,GAAGL,YAAY,CAACE,eAAe,EAAEC,OAAO,CAAC;EACvD,MAAMG,QAAQ,GAAGF,EAAE,EAAEG,KAAK,CAACC,MAAM,CAAC,CAAC;EACnC,MAAMC,QAAQ,GAAGJ,EAAE,EAAEE,KAAK,CAACC,MAAM,CAAC,CAAC;EACnC,OAAOF,QAAQ,IAAIG,QAAQ,GACvBf,KAAK,CAACY,QAAQ,EAAEG,QAAQ,CAAC,CAACX,GAAG,CAAC,CAAC,CAACY,CAAC,EAAEC,CAAC,CAAC,EAAEC,CAAC,MAAM;IAACF,CAAC;IAAEC,CAAC;IAAEC;EAAC,CAAC,CAAC,CAAC,GACzDN,QAAQ,GACRA,QAAQ,CAACR,GAAG,CAAC,CAACY,CAAC,EAAEE,CAAC,MAAM;IAACF,CAAC;IAAEE;EAAC,CAAC,CAAC,CAAC,GAChCH,QAAQ,GACRA,QAAQ,CAACX,GAAG,CAAC,CAACa,CAAC,EAAEC,CAAC,MAAM;IAACD,CAAC;IAAEC;EAAC,CAAC,CAAC,CAAC,GAChCC,SAAS;AACf;AAEA,OAAO,SAASC,cAAcA,CAACC,MAAM,EAAE;EAACL,CAAC,EAAEM,CAAC;EAAEL,CAAC,EAAEM;AAAC,CAAC,EAAE;EACnDD,CAAC,KAAKE,UAAU,CAACF,CAAC,CAAC;EACnBC,CAAC,KAAKC,UAAU,CAACD,CAAC,CAAC;EACnB,OAAOF,MAAM,CACVI,MAAM,CACLH,CAAC,IAAIC,CAAC,CAAC;EAAA,EACFG,CAAC,IAAKJ,CAAC,CAACK,GAAG,CAACD,CAAC,CAACV,CAAC,CAAC,IAAIO,CAAC,CAACI,GAAG,CAACD,CAAC,CAACT,CAAC,CAAC,GAC/BK,CAAC,GACAI,CAAC,IAAKJ,CAAC,CAACK,GAAG,CAACD,CAAC,CAACV,CAAC,CAAC,GAChBU,CAAC,IAAKH,CAAC,CAACI,GAAG,CAACD,CAAC,CAACT,CAAC,CACtB,CAAC,CACAW,IAAI,CACHN,CAAC,IAAIC,CAAC,CAAC;EAAA,EACH,CAACM,CAAC,EAAEC,CAAC,KAAKR,CAAC,CAACS,GAAG,CAACF,CAAC,CAACb,CAAC,CAAC,GAAGM,CAAC,CAACS,GAAG,CAACD,CAAC,CAACd,CAAC,CAAC,IAAIO,CAAC,CAACQ,GAAG,CAACF,CAAC,CAACZ,CAAC,CAAC,GAAGM,CAAC,CAACQ,GAAG,CAACD,CAAC,CAACb,CAAC,CAAC,GAC5DK,CAAC,GACD,CAACO,CAAC,EAAEC,CAAC,KAAKR,CAAC,CAACS,GAAG,CAACF,CAAC,CAACb,CAAC,CAAC,GAAGM,CAAC,CAACS,GAAG,CAACD,CAAC,CAACd,CAAC,CAAC,GACjC,CAACa,CAAC,EAAEC,CAAC,KAAKP,CAAC,CAACQ,GAAG,CAACF,CAAC,CAACZ,CAAC,CAAC,GAAGM,CAAC,CAACQ,GAAG,CAACD,CAAC,CAACb,CAAC,CACtC,CAAC;AACL;;AAEA;AACA;AACA,OAAO,SAASe,WAAWA,CAACC,IAAI,EAAE;EAACvB,EAAE;EAAEC;AAAE,CAAC,EAAE;EAC1C,MAAMuB,CAAC,GAAG7B,KAAK,CAAC4B,IAAI,CAAC;EACrB,MAAME,EAAE,GAAGzB,EAAE,EAAE0B,KAAK;EACpB,MAAMC,EAAE,GAAG1B,EAAE,EAAEyB,KAAK;EACpB,OAAO1B,EAAE,IAAIC,EAAE,GACXV,MAAM,CACJiC,CAAC,EACAI,CAAC,KAAOA,CAAC,CAAC5B,EAAE,GAAGyB,EAAE,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAIA,CAAC,CAAC3B,EAAE,GAAG0B,EAAE,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAGA,CAAC,CAAC,EAC/CpB,CAAC,IAAKiB,EAAE,CAACjB,CAAC,CAAC,EACXA,CAAC,IAAKmB,EAAE,CAACnB,CAAC,CACb,CAAC,GACDR,EAAE,GACFT,MAAM,CACJiC,CAAC,EACAI,CAAC,KAAOA,CAAC,CAAC5B,EAAE,GAAGyB,EAAE,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAGA,CAAC,CAAC,EAC5BpB,CAAC,IAAKiB,EAAE,CAACjB,CAAC,CACb,CAAC,GACDjB,MAAM,CACJiC,CAAC,EACAI,CAAC,KAAOA,CAAC,CAAC3B,EAAE,GAAG0B,EAAE,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAGA,CAAC,CAAC,EAC5BpB,CAAC,IAAKmB,EAAE,CAACnB,CAAC,CACb,CAAC;AACP;AAEA,OAAO,SAASqB,eAAeA,CAAC7B,EAAE,EAAEC,EAAE,EAAE;EAAC6B,SAAS;EAAEC;AAAU,CAAC,EAAE;EAC/D,OAAO/B,EAAE,IAAIC,EAAE,GACX,CAAC;IAACK,CAAC;IAAEC;EAAC,CAAC,KAAM,aAAYP,EAAE,CAACM,CAAC,CAAC,GAAGyB,UAAW,IAAG9B,EAAE,CAACM,CAAC,CAAC,GAAGuB,SAAU,GAAE,GACnE9B,EAAE,GACF,CAAC;IAACM;EAAC,CAAC,KAAM,aAAYN,EAAE,CAACM,CAAC,CAAC,GAAGyB,UAAW,KAAI,GAC7C,CAAC;IAACxB;EAAC,CAAC,KAAM,eAAcN,EAAE,CAACM,CAAC,CAAC,GAAGuB,SAAU,GAAE;AAClD;;AAEA;AACA;AACA,OAAO,SAASE,YAAYA,CAACC,KAAK,EAAE;EAClC,MAAMC,EAAE,GAAG,EAAE;EACb,MAAMC,CAAC,GAAG,IAAIC,WAAW,CAAC5C,GAAG,CAACyC,KAAK,EAAGI,CAAC,IAAKA,CAAC,CAACC,MAAM,CAAC,CAAC;EACtD,KAAK,MAAM9B,CAAC,IAAIyB,KAAK,EAAE;IACrB,IAAIM,CAAC,GAAG,CAAC;IACT,KAAK,MAAMC,CAAC,IAAIP,KAAK,EAAE;MACrB,IAAIzB,CAAC,KAAKgC,CAAC,EAAE;MACbL,CAAC,CAACM,GAAG,CAACD,CAAC,EAAED,CAAC,CAAC;MACXA,CAAC,IAAIC,CAAC,CAACF,MAAM;IACf;IACAJ,EAAE,CAACQ,IAAI,CAACP,CAAC,CAACQ,KAAK,CAAC,CAAC,EAAEJ,CAAC,CAAC,CAAC;EACxB;EACA,OAAOL,EAAE;AACX;AAEA,MAAMU,YAAY,GAAG,IAAIC,GAAG,CAAC,CAC3B,CAAC,KAAK,EAAEC,cAAc,CAAC,EACvB,CAAC,OAAO,EAAEC,gBAAgB,CAAC,EAC3B,CAAC,QAAQ,EAAEC,iBAAiB,CAAC,EAC7B,CAAC,MAAM,EAAEC,eAAe,CAAC,EACzB,CAAC,UAAU,EAAEC,GAAG,CAACJ,cAAc,EAAEG,eAAe,CAAC,CAAC,EAClD,CAAC,WAAW,EAAEC,GAAG,CAACJ,cAAc,EAAEC,gBAAgB,CAAC,CAAC,EACpD,CAAC,aAAa,EAAEG,GAAG,CAACF,iBAAiB,EAAEC,eAAe,CAAC,CAAC,EACxD,CAAC,cAAc,EAAEC,GAAG,CAACF,iBAAiB,EAAED,gBAAgB,CAAC,CAAC,EAC1D,CAAC,WAAW,EAAEI,mBAAmB,CAAC,EAClC,CAAC,aAAa,EAAEC,qBAAqB,CAAC,EACtC,CAAC,cAAc,EAAEC,sBAAsB,CAAC,EACxC,CAAC,YAAY,EAAEC,oBAAoB,CAAC,EACpC,CAAC,OAAO,EAAEC,gBAAgB,CAAC,CAC5B,CAAC;AAEF,OAAO,SAASC,gBAAgBA,CAACC,WAAW,EAAE;EAC5C,IAAIA,WAAW,IAAI,IAAI,EAAE,OAAO,IAAI;EACpC,MAAMC,MAAM,GAAGd,YAAY,CAACvB,GAAG,CAAE,GAAEoC,WAAY,EAAC,CAACE,WAAW,CAAC,CAAC,CAAC;EAC/D,IAAID,MAAM,EAAE,OAAOA,MAAM;EACzB,MAAM,IAAIE,KAAK,CAAE,yBAAwBH,WAAY,EAAC,CAAC;AACzD;AAEA,MAAMI,UAAU,GAAG,IAAIC,OAAO,CAAC,CAAC;AAEhC,SAAShD,UAAUA,CAACiD,CAAC,EAAE;EACrB,IAAIvC,CAAC,GAAGqC,UAAU,CAACxC,GAAG,CAAC0C,CAAC,CAAC;EACzB,IAAI,CAACvC,CAAC,EAAEqC,UAAU,CAACpB,GAAG,CAACsB,CAAC,EAAGvC,CAAC,GAAG,IAAInC,SAAS,CAACK,GAAG,CAACqE,CAAC,EAAE,CAACC,CAAC,EAAExD,CAAC,KAAK,CAACwD,CAAC,EAAExD,CAAC,CAAC,CAAC,CAAE,CAAC;EACxE,OAAOgB,CAAC;AACV;;AAEA;AACA,SAASyC,YAAYA,CAACF,CAAC,EAAEC,CAAC,EAAE;EAC1B,OAAOlD,UAAU,CAACiD,CAAC,CAAC,CAAC1C,GAAG,CAAC2C,CAAC,CAAC;AAC7B;;AAEA;AACA,SAASE,SAASA,CAACvD,MAAM,EAAEL,CAAC,EAAEC,CAAC,EAAE;EAC/BD,CAAC,GAAGb,KAAK,CAACa,CAAC,CAAC;EACZC,CAAC,GAAGd,KAAK,CAACc,CAAC,CAAC;EACZ,OAAOI,MAAM,CAACwD,IAAI,CAAEnD,CAAC,IAAKoD,MAAM,CAACC,EAAE,CAAC5E,KAAK,CAACuB,CAAC,CAACV,CAAC,CAAC,EAAEA,CAAC,CAAC,IAAI8D,MAAM,CAACC,EAAE,CAAC5E,KAAK,CAACuB,CAAC,CAACT,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC;AACjF;AAEA,SAAS+D,UAAUA,CAAC3D,MAAM,EAAEL,CAAC,EAAEC,CAAC,EAAE;EAChC,OAAO2D,SAAS,CAACvD,MAAM,EAAEL,CAAC,EAAEC,CAAC,CAAC,EAAEgE,KAAK;AACvC;AAEA,SAASzB,cAAcA,CAACnC,MAAM,EAAE;EAACJ,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACN;AAAC,CAAC,EAAE;EAC3C,OAAOM,CAAC,GAAGoD,YAAY,CAACpD,CAAC,EAAEN,CAAC,CAAC,KAAK,CAAC,GAAG,IAAI;AAC5C;AAEA,SAASyC,iBAAiBA,CAACrC,MAAM,EAAE;EAACJ,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACN;AAAC,CAAC,EAAE;EAC9C,OAAOM,CAAC,GAAGoD,YAAY,CAACpD,CAAC,EAAEN,CAAC,CAAC,KAAKM,CAAC,CAACyB,MAAM,GAAG,CAAC,GAAG,IAAI;AACvD;AAEA,SAASW,eAAeA,CAACtC,MAAM,EAAE;EAACL,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACN;AAAC,CAAC,EAAE;EAC5C,OAAOM,CAAC,GAAGqD,YAAY,CAACrD,CAAC,EAAEN,CAAC,CAAC,KAAK,CAAC,GAAG,IAAI;AAC5C;AAEA,SAASyC,gBAAgBA,CAACpC,MAAM,EAAE;EAACL,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACN;AAAC,CAAC,EAAE;EAC7C,OAAOM,CAAC,GAAGqD,YAAY,CAACrD,CAAC,EAAEN,CAAC,CAAC,KAAKM,CAAC,CAAC0B,MAAM,GAAG,CAAC,GAAG,IAAI;AACvD;AAEA,SAASa,mBAAmBA,CAACxC,MAAM,EAAE;EAACJ,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACP,CAAC;EAAEC,CAAC;EAAEgE;AAAK,CAAC,EAAE;EAC1D,IAAIA,KAAK,EAAE,OAAO,KAAK;EACvB,IAAI,CAAC1D,CAAC,EAAE;EACR,MAAML,CAAC,GAAGyD,YAAY,CAACpD,CAAC,EAAEN,CAAC,CAAC;EAC5B,IAAIC,CAAC,GAAG,CAAC,EAAE,OAAO8D,UAAU,CAAC3D,MAAM,EAAEL,CAAC,EAAEO,CAAC,CAACL,CAAC,GAAG,CAAC,CAAC,CAAC;AACnD;AAEA,SAAS6C,sBAAsBA,CAAC1C,MAAM,EAAE;EAACJ,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACP,CAAC;EAAEC,CAAC;EAAEgE;AAAK,CAAC,EAAE;EAC7D,IAAIA,KAAK,EAAE,OAAO,KAAK;EACvB,IAAI,CAAC1D,CAAC,EAAE;EACR,MAAML,CAAC,GAAGyD,YAAY,CAACpD,CAAC,EAAEN,CAAC,CAAC;EAC5B,IAAIC,CAAC,GAAGK,CAAC,CAACyB,MAAM,GAAG,CAAC,EAAE,OAAOgC,UAAU,CAAC3D,MAAM,EAAEL,CAAC,EAAEO,CAAC,CAACL,CAAC,GAAG,CAAC,CAAC,CAAC;AAC9D;AAEA,SAAS8C,oBAAoBA,CAAC3C,MAAM,EAAE;EAACL,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACN,CAAC;EAAEC,CAAC;EAAEgE;AAAK,CAAC,EAAE;EAC3D,IAAIA,KAAK,EAAE,OAAO,KAAK;EACvB,IAAI,CAAC3D,CAAC,EAAE;EACR,MAAMJ,CAAC,GAAGyD,YAAY,CAACrD,CAAC,EAAEN,CAAC,CAAC;EAC5B,IAAIE,CAAC,GAAG,CAAC,EAAE,OAAO8D,UAAU,CAAC3D,MAAM,EAAEC,CAAC,CAACJ,CAAC,GAAG,CAAC,CAAC,EAAED,CAAC,CAAC;AACnD;AAEA,SAAS6C,qBAAqBA,CAACzC,MAAM,EAAE;EAACL,CAAC,EAAEM;AAAC,CAAC,EAAE;EAACN,CAAC;EAAEC,CAAC;EAAEgE;AAAK,CAAC,EAAE;EAC5D,IAAIA,KAAK,EAAE,OAAO,KAAK;EACvB,IAAI,CAAC3D,CAAC,EAAE;EACR,MAAMJ,CAAC,GAAGyD,YAAY,CAACrD,CAAC,EAAEN,CAAC,CAAC;EAC5B,IAAIE,CAAC,GAAGI,CAAC,CAAC0B,MAAM,GAAG,CAAC,EAAE,OAAOgC,UAAU,CAAC3D,MAAM,EAAEC,CAAC,CAACJ,CAAC,GAAG,CAAC,CAAC,EAAED,CAAC,CAAC;AAC9D;AAEA,SAASgD,gBAAgBA,CAAC5C,MAAM,EAAE6D,QAAQ,EAAE;EAACD;AAAK,CAAC,EAAE;EACnD,OAAOA,KAAK;AACd;AAEA,SAASrB,GAAGA,CAAC/B,CAAC,EAAEC,CAAC,EAAE;EACjB,OAAO,YAAY;IACjB,OAAOD,CAAC,CAACsD,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,IAAItD,CAAC,CAACqD,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAC7D,CAAC;AACH;;AAEA;AACA,OAAO,SAASC,WAAWA,CAAChE,MAAM,EAAE;EAAC6D,QAAQ,EAAE;IAACxE,EAAE;IAAEC;EAAE,CAAC;EAAE2E;AAAM,CAAC,EAAE;EAChE,OAAO5E,EAAE,IAAIC,EAAE,GACXU,MAAM,CAACjB,GAAG,CAAC,CAAC;IAACY,CAAC;IAAEC;EAAC,CAAC,KAAKqE,MAAM,CAACvD,GAAG,CAACf,CAAC,CAAC,EAAEe,GAAG,CAACd,CAAC,CAAC,IAAI,EAAE,CAAC,GACnDP,EAAE,GACFW,MAAM,CAACjB,GAAG,CAAC,CAAC;IAACY;EAAC,CAAC,KAAKsE,MAAM,CAACvD,GAAG,CAACf,CAAC,CAAC,IAAI,EAAE,CAAC,GACxCK,MAAM,CAACjB,GAAG,CAAC,CAAC;IAACa;EAAC,CAAC,KAAKqE,MAAM,CAACvD,GAAG,CAACd,CAAC,CAAC,IAAI,EAAE,CAAC;AAC9C"},"metadata":{},"sourceType":"module","externalDependencies":[]}