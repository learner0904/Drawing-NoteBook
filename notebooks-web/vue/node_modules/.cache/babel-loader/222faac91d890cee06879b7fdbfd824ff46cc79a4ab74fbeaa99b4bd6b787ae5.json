{"ast":null,"code":"import { interpolateBlues, interpolateBrBG, interpolateBuGn, interpolateBuPu, interpolateGnBu, interpolateGreens, interpolateGreys, interpolateOranges, interpolateOrRd, interpolatePiYG, interpolatePRGn, interpolatePuBu, interpolatePuBuGn, interpolatePuOr, interpolatePuRd, interpolatePurples, interpolateRdBu, interpolateRdGy, interpolateRdPu, interpolateRdYlBu, interpolateRdYlGn, interpolateReds, interpolateSpectral, interpolateYlGn, interpolateYlGnBu, interpolateYlOrBr, interpolateYlOrRd, interpolateTurbo, interpolateViridis, interpolateMagma, interpolateInferno, interpolatePlasma, interpolateCividis, interpolateCubehelixDefault, interpolateWarm, interpolateCool, interpolateRainbow, interpolateSinebow, quantize, schemeAccent, schemeBlues, schemeBrBG, schemeBuGn, schemeBuPu, schemeCategory10, schemeDark2, schemeGnBu, schemeGreens, schemeGreys, schemeObservable10, schemeOranges, schemeOrRd, schemePaired, schemePastel1, schemePastel2, schemePiYG, schemePRGn, schemePuBu, schemePuBuGn, schemePuOr, schemePuRd, schemePurples, schemeRdBu, schemeRdGy, schemeRdPu, schemeRdYlBu, schemeRdYlGn, schemeReds, schemeSet1, schemeSet2, schemeSet3, schemeSpectral, schemeTableau10, schemeYlGn, schemeYlGnBu, schemeYlOrBr, schemeYlOrRd } from \"d3\";\nconst categoricalSchemes = new Map([[\"accent\", schemeAccent], [\"category10\", schemeCategory10], [\"dark2\", schemeDark2], [\"observable10\", schemeObservable10], [\"paired\", schemePaired], [\"pastel1\", schemePastel1], [\"pastel2\", schemePastel2], [\"set1\", schemeSet1], [\"set2\", schemeSet2], [\"set3\", schemeSet3], [\"tableau10\", schemeTableau10]]);\nexport function isCategoricalScheme(scheme) {\n  return scheme != null && categoricalSchemes.has(`${scheme}`.toLowerCase());\n}\nconst ordinalSchemes = new Map([...categoricalSchemes,\n// diverging\n[\"brbg\", scheme11(schemeBrBG, interpolateBrBG)], [\"prgn\", scheme11(schemePRGn, interpolatePRGn)], [\"piyg\", scheme11(schemePiYG, interpolatePiYG)], [\"puor\", scheme11(schemePuOr, interpolatePuOr)], [\"rdbu\", scheme11(schemeRdBu, interpolateRdBu)], [\"rdgy\", scheme11(schemeRdGy, interpolateRdGy)], [\"rdylbu\", scheme11(schemeRdYlBu, interpolateRdYlBu)], [\"rdylgn\", scheme11(schemeRdYlGn, interpolateRdYlGn)], [\"spectral\", scheme11(schemeSpectral, interpolateSpectral)],\n// reversed diverging (for temperature data)\n[\"burd\", scheme11r(schemeRdBu, interpolateRdBu)], [\"buylrd\", scheme11r(schemeRdYlBu, interpolateRdYlBu)],\n// sequential (single-hue)\n[\"blues\", scheme9(schemeBlues, interpolateBlues)], [\"greens\", scheme9(schemeGreens, interpolateGreens)], [\"greys\", scheme9(schemeGreys, interpolateGreys)], [\"oranges\", scheme9(schemeOranges, interpolateOranges)], [\"purples\", scheme9(schemePurples, interpolatePurples)], [\"reds\", scheme9(schemeReds, interpolateReds)],\n// sequential (multi-hue)\n[\"turbo\", schemei(interpolateTurbo)], [\"viridis\", schemei(interpolateViridis)], [\"magma\", schemei(interpolateMagma)], [\"inferno\", schemei(interpolateInferno)], [\"plasma\", schemei(interpolatePlasma)], [\"cividis\", schemei(interpolateCividis)], [\"cubehelix\", schemei(interpolateCubehelixDefault)], [\"warm\", schemei(interpolateWarm)], [\"cool\", schemei(interpolateCool)], [\"bugn\", scheme9(schemeBuGn, interpolateBuGn)], [\"bupu\", scheme9(schemeBuPu, interpolateBuPu)], [\"gnbu\", scheme9(schemeGnBu, interpolateGnBu)], [\"orrd\", scheme9(schemeOrRd, interpolateOrRd)], [\"pubu\", scheme9(schemePuBu, interpolatePuBu)], [\"pubugn\", scheme9(schemePuBuGn, interpolatePuBuGn)], [\"purd\", scheme9(schemePuRd, interpolatePuRd)], [\"rdpu\", scheme9(schemeRdPu, interpolateRdPu)], [\"ylgn\", scheme9(schemeYlGn, interpolateYlGn)], [\"ylgnbu\", scheme9(schemeYlGnBu, interpolateYlGnBu)], [\"ylorbr\", scheme9(schemeYlOrBr, interpolateYlOrBr)], [\"ylorrd\", scheme9(schemeYlOrRd, interpolateYlOrRd)],\n// cyclical\n[\"rainbow\", schemeicyclical(interpolateRainbow)], [\"sinebow\", schemeicyclical(interpolateSinebow)]]);\nfunction scheme9(scheme, interpolate) {\n  return ({\n    length: n\n  }) => {\n    if (n === 1) return [scheme[3][1]]; // favor midpoint\n    if (n === 2) return [scheme[3][1], scheme[3][2]]; // favor darker\n    n = Math.max(3, Math.floor(n));\n    return n > 9 ? quantize(interpolate, n) : scheme[n];\n  };\n}\nfunction scheme11(scheme, interpolate) {\n  return ({\n    length: n\n  }) => {\n    if (n === 2) return [scheme[3][0], scheme[3][2]]; // favor diverging extrema\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize(interpolate, n) : scheme[n];\n  };\n}\nfunction scheme11r(scheme, interpolate) {\n  return ({\n    length: n\n  }) => {\n    if (n === 2) return [scheme[3][2], scheme[3][0]]; // favor diverging extrema\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize(t => interpolate(1 - t), n) : scheme[n].slice().reverse();\n  };\n}\nfunction schemei(interpolate) {\n  return ({\n    length: n\n  }) => quantize(interpolate, Math.max(2, Math.floor(n)));\n}\nfunction schemeicyclical(interpolate) {\n  return ({\n    length: n\n  }) => quantize(interpolate, Math.floor(n) + 1).slice(0, -1);\n}\nexport function ordinalScheme(scheme) {\n  const s = `${scheme}`.toLowerCase();\n  if (!ordinalSchemes.has(s)) throw new Error(`unknown ordinal scheme: ${s}`);\n  return ordinalSchemes.get(s);\n}\nexport function ordinalRange(scheme, length) {\n  const s = ordinalScheme(scheme);\n  const r = typeof s === \"function\" ? s({\n    length\n  }) : s;\n  return r.length !== length ? r.slice(0, length) : r;\n}\n\n// If the specified domain contains only booleans (ignoring null and undefined),\n// returns a corresponding range where false is mapped to the low color and true\n// is mapped to the high color of the specified scheme.\nexport function maybeBooleanRange(domain, scheme = \"greys\") {\n  const range = new Set();\n  const [f, t] = ordinalRange(scheme, 2);\n  for (const value of domain) {\n    if (value == null) continue;\n    if (value === true) range.add(t);else if (value === false) range.add(f);else return;\n  }\n  return [...range];\n}\nconst quantitativeSchemes = new Map([\n// diverging\n[\"brbg\", interpolateBrBG], [\"prgn\", interpolatePRGn], [\"piyg\", interpolatePiYG], [\"puor\", interpolatePuOr], [\"rdbu\", interpolateRdBu], [\"rdgy\", interpolateRdGy], [\"rdylbu\", interpolateRdYlBu], [\"rdylgn\", interpolateRdYlGn], [\"spectral\", interpolateSpectral],\n// reversed diverging (for temperature data)\n[\"burd\", t => interpolateRdBu(1 - t)], [\"buylrd\", t => interpolateRdYlBu(1 - t)],\n// sequential (single-hue)\n[\"blues\", interpolateBlues], [\"greens\", interpolateGreens], [\"greys\", interpolateGreys], [\"purples\", interpolatePurples], [\"reds\", interpolateReds], [\"oranges\", interpolateOranges],\n// sequential (multi-hue)\n[\"turbo\", interpolateTurbo], [\"viridis\", interpolateViridis], [\"magma\", interpolateMagma], [\"inferno\", interpolateInferno], [\"plasma\", interpolatePlasma], [\"cividis\", interpolateCividis], [\"cubehelix\", interpolateCubehelixDefault], [\"warm\", interpolateWarm], [\"cool\", interpolateCool], [\"bugn\", interpolateBuGn], [\"bupu\", interpolateBuPu], [\"gnbu\", interpolateGnBu], [\"orrd\", interpolateOrRd], [\"pubugn\", interpolatePuBuGn], [\"pubu\", interpolatePuBu], [\"purd\", interpolatePuRd], [\"rdpu\", interpolateRdPu], [\"ylgnbu\", interpolateYlGnBu], [\"ylgn\", interpolateYlGn], [\"ylorbr\", interpolateYlOrBr], [\"ylorrd\", interpolateYlOrRd],\n// cyclical\n[\"rainbow\", interpolateRainbow], [\"sinebow\", interpolateSinebow]]);\nexport function quantitativeScheme(scheme) {\n  const s = `${scheme}`.toLowerCase();\n  if (!quantitativeSchemes.has(s)) throw new Error(`unknown quantitative scheme: ${s}`);\n  return quantitativeSchemes.get(s);\n}\nconst divergingSchemes = new Set([\"brbg\", \"prgn\", \"piyg\", \"puor\", \"rdbu\", \"rdgy\", \"rdylbu\", \"rdylgn\", \"spectral\", \"burd\", \"buylrd\"]);\nexport function isDivergingScheme(scheme) {\n  return scheme != null && divergingSchemes.has(`${scheme}`.toLowerCase());\n}","map":{"version":3,"names":["interpolateBlues","interpolateBrBG","interpolateBuGn","interpolateBuPu","interpolateGnBu","interpolateGreens","interpolateGreys","interpolateOranges","interpolateOrRd","interpolatePiYG","interpolatePRGn","interpolatePuBu","interpolatePuBuGn","interpolatePuOr","interpolatePuRd","interpolatePurples","interpolateRdBu","interpolateRdGy","interpolateRdPu","interpolateRdYlBu","interpolateRdYlGn","interpolateReds","interpolateSpectral","interpolateYlGn","interpolateYlGnBu","interpolateYlOrBr","interpolateYlOrRd","interpolateTurbo","interpolateViridis","interpolateMagma","interpolateInferno","interpolatePlasma","interpolateCividis","interpolateCubehelixDefault","interpolateWarm","interpolateCool","interpolateRainbow","interpolateSinebow","quantize","schemeAccent","schemeBlues","schemeBrBG","schemeBuGn","schemeBuPu","schemeCategory10","schemeDark2","schemeGnBu","schemeGreens","schemeGreys","schemeObservable10","schemeOranges","schemeOrRd","schemePaired","schemePastel1","schemePastel2","schemePiYG","schemePRGn","schemePuBu","schemePuBuGn","schemePuOr","schemePuRd","schemePurples","schemeRdBu","schemeRdGy","schemeRdPu","schemeRdYlBu","schemeRdYlGn","schemeReds","schemeSet1","schemeSet2","schemeSet3","schemeSpectral","schemeTableau10","schemeYlGn","schemeYlGnBu","schemeYlOrBr","schemeYlOrRd","categoricalSchemes","Map","isCategoricalScheme","scheme","has","toLowerCase","ordinalSchemes","scheme11","scheme11r","scheme9","schemei","schemeicyclical","interpolate","length","n","Math","max","floor","t","slice","reverse","ordinalScheme","s","Error","get","ordinalRange","r","maybeBooleanRange","domain","range","Set","f","value","add","quantitativeSchemes","quantitativeScheme","divergingSchemes","isDivergingScheme"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/scales/schemes.js"],"sourcesContent":["import {\n  interpolateBlues,\n  interpolateBrBG,\n  interpolateBuGn,\n  interpolateBuPu,\n  interpolateGnBu,\n  interpolateGreens,\n  interpolateGreys,\n  interpolateOranges,\n  interpolateOrRd,\n  interpolatePiYG,\n  interpolatePRGn,\n  interpolatePuBu,\n  interpolatePuBuGn,\n  interpolatePuOr,\n  interpolatePuRd,\n  interpolatePurples,\n  interpolateRdBu,\n  interpolateRdGy,\n  interpolateRdPu,\n  interpolateRdYlBu,\n  interpolateRdYlGn,\n  interpolateReds,\n  interpolateSpectral,\n  interpolateYlGn,\n  interpolateYlGnBu,\n  interpolateYlOrBr,\n  interpolateYlOrRd,\n  interpolateTurbo,\n  interpolateViridis,\n  interpolateMagma,\n  interpolateInferno,\n  interpolatePlasma,\n  interpolateCividis,\n  interpolateCubehelixDefault,\n  interpolateWarm,\n  interpolateCool,\n  interpolateRainbow,\n  interpolateSinebow,\n  quantize,\n  schemeAccent,\n  schemeBlues,\n  schemeBrBG,\n  schemeBuGn,\n  schemeBuPu,\n  schemeCategory10,\n  schemeDark2,\n  schemeGnBu,\n  schemeGreens,\n  schemeGreys,\n  schemeObservable10,\n  schemeOranges,\n  schemeOrRd,\n  schemePaired,\n  schemePastel1,\n  schemePastel2,\n  schemePiYG,\n  schemePRGn,\n  schemePuBu,\n  schemePuBuGn,\n  schemePuOr,\n  schemePuRd,\n  schemePurples,\n  schemeRdBu,\n  schemeRdGy,\n  schemeRdPu,\n  schemeRdYlBu,\n  schemeRdYlGn,\n  schemeReds,\n  schemeSet1,\n  schemeSet2,\n  schemeSet3,\n  schemeSpectral,\n  schemeTableau10,\n  schemeYlGn,\n  schemeYlGnBu,\n  schemeYlOrBr,\n  schemeYlOrRd\n} from \"d3\";\n\nconst categoricalSchemes = new Map([\n  [\"accent\", schemeAccent],\n  [\"category10\", schemeCategory10],\n  [\"dark2\", schemeDark2],\n  [\"observable10\", schemeObservable10],\n  [\"paired\", schemePaired],\n  [\"pastel1\", schemePastel1],\n  [\"pastel2\", schemePastel2],\n  [\"set1\", schemeSet1],\n  [\"set2\", schemeSet2],\n  [\"set3\", schemeSet3],\n  [\"tableau10\", schemeTableau10]\n]);\n\nexport function isCategoricalScheme(scheme) {\n  return scheme != null && categoricalSchemes.has(`${scheme}`.toLowerCase());\n}\n\nconst ordinalSchemes = new Map([\n  ...categoricalSchemes,\n\n  // diverging\n  [\"brbg\", scheme11(schemeBrBG, interpolateBrBG)],\n  [\"prgn\", scheme11(schemePRGn, interpolatePRGn)],\n  [\"piyg\", scheme11(schemePiYG, interpolatePiYG)],\n  [\"puor\", scheme11(schemePuOr, interpolatePuOr)],\n  [\"rdbu\", scheme11(schemeRdBu, interpolateRdBu)],\n  [\"rdgy\", scheme11(schemeRdGy, interpolateRdGy)],\n  [\"rdylbu\", scheme11(schemeRdYlBu, interpolateRdYlBu)],\n  [\"rdylgn\", scheme11(schemeRdYlGn, interpolateRdYlGn)],\n  [\"spectral\", scheme11(schemeSpectral, interpolateSpectral)],\n\n  // reversed diverging (for temperature data)\n  [\"burd\", scheme11r(schemeRdBu, interpolateRdBu)],\n  [\"buylrd\", scheme11r(schemeRdYlBu, interpolateRdYlBu)],\n\n  // sequential (single-hue)\n  [\"blues\", scheme9(schemeBlues, interpolateBlues)],\n  [\"greens\", scheme9(schemeGreens, interpolateGreens)],\n  [\"greys\", scheme9(schemeGreys, interpolateGreys)],\n  [\"oranges\", scheme9(schemeOranges, interpolateOranges)],\n  [\"purples\", scheme9(schemePurples, interpolatePurples)],\n  [\"reds\", scheme9(schemeReds, interpolateReds)],\n\n  // sequential (multi-hue)\n  [\"turbo\", schemei(interpolateTurbo)],\n  [\"viridis\", schemei(interpolateViridis)],\n  [\"magma\", schemei(interpolateMagma)],\n  [\"inferno\", schemei(interpolateInferno)],\n  [\"plasma\", schemei(interpolatePlasma)],\n  [\"cividis\", schemei(interpolateCividis)],\n  [\"cubehelix\", schemei(interpolateCubehelixDefault)],\n  [\"warm\", schemei(interpolateWarm)],\n  [\"cool\", schemei(interpolateCool)],\n  [\"bugn\", scheme9(schemeBuGn, interpolateBuGn)],\n  [\"bupu\", scheme9(schemeBuPu, interpolateBuPu)],\n  [\"gnbu\", scheme9(schemeGnBu, interpolateGnBu)],\n  [\"orrd\", scheme9(schemeOrRd, interpolateOrRd)],\n  [\"pubu\", scheme9(schemePuBu, interpolatePuBu)],\n  [\"pubugn\", scheme9(schemePuBuGn, interpolatePuBuGn)],\n  [\"purd\", scheme9(schemePuRd, interpolatePuRd)],\n  [\"rdpu\", scheme9(schemeRdPu, interpolateRdPu)],\n  [\"ylgn\", scheme9(schemeYlGn, interpolateYlGn)],\n  [\"ylgnbu\", scheme9(schemeYlGnBu, interpolateYlGnBu)],\n  [\"ylorbr\", scheme9(schemeYlOrBr, interpolateYlOrBr)],\n  [\"ylorrd\", scheme9(schemeYlOrRd, interpolateYlOrRd)],\n\n  // cyclical\n  [\"rainbow\", schemeicyclical(interpolateRainbow)],\n  [\"sinebow\", schemeicyclical(interpolateSinebow)]\n]);\n\nfunction scheme9(scheme, interpolate) {\n  return ({length: n}) => {\n    if (n === 1) return [scheme[3][1]]; // favor midpoint\n    if (n === 2) return [scheme[3][1], scheme[3][2]]; // favor darker\n    n = Math.max(3, Math.floor(n));\n    return n > 9 ? quantize(interpolate, n) : scheme[n];\n  };\n}\n\nfunction scheme11(scheme, interpolate) {\n  return ({length: n}) => {\n    if (n === 2) return [scheme[3][0], scheme[3][2]]; // favor diverging extrema\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize(interpolate, n) : scheme[n];\n  };\n}\n\nfunction scheme11r(scheme, interpolate) {\n  return ({length: n}) => {\n    if (n === 2) return [scheme[3][2], scheme[3][0]]; // favor diverging extrema\n    n = Math.max(3, Math.floor(n));\n    return n > 11 ? quantize((t) => interpolate(1 - t), n) : scheme[n].slice().reverse();\n  };\n}\n\nfunction schemei(interpolate) {\n  return ({length: n}) => quantize(interpolate, Math.max(2, Math.floor(n)));\n}\n\nfunction schemeicyclical(interpolate) {\n  return ({length: n}) => quantize(interpolate, Math.floor(n) + 1).slice(0, -1);\n}\n\nexport function ordinalScheme(scheme) {\n  const s = `${scheme}`.toLowerCase();\n  if (!ordinalSchemes.has(s)) throw new Error(`unknown ordinal scheme: ${s}`);\n  return ordinalSchemes.get(s);\n}\n\nexport function ordinalRange(scheme, length) {\n  const s = ordinalScheme(scheme);\n  const r = typeof s === \"function\" ? s({length}) : s;\n  return r.length !== length ? r.slice(0, length) : r;\n}\n\n// If the specified domain contains only booleans (ignoring null and undefined),\n// returns a corresponding range where false is mapped to the low color and true\n// is mapped to the high color of the specified scheme.\nexport function maybeBooleanRange(domain, scheme = \"greys\") {\n  const range = new Set();\n  const [f, t] = ordinalRange(scheme, 2);\n  for (const value of domain) {\n    if (value == null) continue;\n    if (value === true) range.add(t);\n    else if (value === false) range.add(f);\n    else return;\n  }\n  return [...range];\n}\n\nconst quantitativeSchemes = new Map([\n  // diverging\n  [\"brbg\", interpolateBrBG],\n  [\"prgn\", interpolatePRGn],\n  [\"piyg\", interpolatePiYG],\n  [\"puor\", interpolatePuOr],\n  [\"rdbu\", interpolateRdBu],\n  [\"rdgy\", interpolateRdGy],\n  [\"rdylbu\", interpolateRdYlBu],\n  [\"rdylgn\", interpolateRdYlGn],\n  [\"spectral\", interpolateSpectral],\n\n  // reversed diverging (for temperature data)\n  [\"burd\", (t) => interpolateRdBu(1 - t)],\n  [\"buylrd\", (t) => interpolateRdYlBu(1 - t)],\n\n  // sequential (single-hue)\n  [\"blues\", interpolateBlues],\n  [\"greens\", interpolateGreens],\n  [\"greys\", interpolateGreys],\n  [\"purples\", interpolatePurples],\n  [\"reds\", interpolateReds],\n  [\"oranges\", interpolateOranges],\n\n  // sequential (multi-hue)\n  [\"turbo\", interpolateTurbo],\n  [\"viridis\", interpolateViridis],\n  [\"magma\", interpolateMagma],\n  [\"inferno\", interpolateInferno],\n  [\"plasma\", interpolatePlasma],\n  [\"cividis\", interpolateCividis],\n  [\"cubehelix\", interpolateCubehelixDefault],\n  [\"warm\", interpolateWarm],\n  [\"cool\", interpolateCool],\n  [\"bugn\", interpolateBuGn],\n  [\"bupu\", interpolateBuPu],\n  [\"gnbu\", interpolateGnBu],\n  [\"orrd\", interpolateOrRd],\n  [\"pubugn\", interpolatePuBuGn],\n  [\"pubu\", interpolatePuBu],\n  [\"purd\", interpolatePuRd],\n  [\"rdpu\", interpolateRdPu],\n  [\"ylgnbu\", interpolateYlGnBu],\n  [\"ylgn\", interpolateYlGn],\n  [\"ylorbr\", interpolateYlOrBr],\n  [\"ylorrd\", interpolateYlOrRd],\n\n  // cyclical\n  [\"rainbow\", interpolateRainbow],\n  [\"sinebow\", interpolateSinebow]\n]);\n\nexport function quantitativeScheme(scheme) {\n  const s = `${scheme}`.toLowerCase();\n  if (!quantitativeSchemes.has(s)) throw new Error(`unknown quantitative scheme: ${s}`);\n  return quantitativeSchemes.get(s);\n}\n\nconst divergingSchemes = new Set([\n  \"brbg\",\n  \"prgn\",\n  \"piyg\",\n  \"puor\",\n  \"rdbu\",\n  \"rdgy\",\n  \"rdylbu\",\n  \"rdylgn\",\n  \"spectral\",\n  \"burd\",\n  \"buylrd\"\n]);\n\nexport function isDivergingScheme(scheme) {\n  return scheme != null && divergingSchemes.has(`${scheme}`.toLowerCase());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}