{"ast":null,"code":"import { ascending, descending } from \"d3\";\nimport { create } from \"../context.js\";\nimport { Mark } from \"../mark.js\";\nimport { radians } from \"../math.js\";\nimport { constant, keyword } from \"../options.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform } from \"../style.js\";\nimport { maybeSameValue } from \"./link.js\";\nconst defaults = {\n  ariaLabel: \"arrow\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeMiterlimit: 1,\n  strokeWidth: 1.5\n};\nexport class Arrow extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1,\n      y1,\n      x2,\n      y2,\n      bend = 0,\n      headAngle = 60,\n      headLength = 8,\n      // Disable the arrow with headLength = 0; or, use Plot.link.\n      inset = 0,\n      insetStart = inset,\n      insetEnd = inset,\n      sweep\n    } = options;\n    super(data, {\n      x1: {\n        value: x1,\n        scale: \"x\"\n      },\n      y1: {\n        value: y1,\n        scale: \"y\"\n      },\n      x2: {\n        value: x2,\n        scale: \"x\",\n        optional: true\n      },\n      y2: {\n        value: y2,\n        scale: \"y\",\n        optional: true\n      }\n    }, options, defaults);\n    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));\n    this.headAngle = +headAngle;\n    this.headLength = +headLength;\n    this.insetStart = +insetStart;\n    this.insetEnd = +insetEnd;\n    this.sweep = maybeSweep(sweep);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x1: X1,\n      y1: Y1,\n      x2: X2 = X1,\n      y2: Y2 = Y1,\n      SW\n    } = channels;\n    const {\n      strokeWidth,\n      bend,\n      headAngle,\n      headLength,\n      insetStart,\n      insetEnd\n    } = this;\n    const sw = SW ? i => SW[i] : constant(strokeWidth === undefined ? 1 : strokeWidth);\n\n    // The angle between the arrow’s shaft and one of the wings; the “head”\n    // angle between the wings is twice this value.\n    const wingAngle = headAngle * radians / 2;\n\n    // The length of the arrowhead’s “wings” (the line segments that extend from\n    // the end point) relative to the stroke width.\n    const wingScale = headLength / 1.5;\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(g => g.selectAll().data(index).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", i => {\n      // The start ⟨x1,y1⟩ and end ⟨x2,y2⟩ points may be inset, and the\n      // ending line angle may be altered for inset swoopy arrows.\n      let x1 = X1[i],\n        y1 = Y1[i],\n        x2 = X2[i],\n        y2 = Y2[i];\n      const lineLength = Math.hypot(x2 - x1, y2 - y1);\n      if (lineLength <= insetStart + insetEnd) return null;\n      let lineAngle = Math.atan2(y2 - y1, x2 - x1);\n\n      // We don’t allow the wing length to be too large relative to the\n      // length of the arrow. (Plot.vector allows arbitrarily large\n      // wings, but that’s okay since vectors are usually small.)\n      const headLength = Math.min(wingScale * sw(i), lineLength / 3);\n\n      // When bending, the offset between the straight line between the two points\n      // and the outgoing tangent from the start point. (Also the negative\n      // incoming tangent to the end point.) This must be within ±π/2. A positive\n      // angle will produce a clockwise curve; a negative angle will produce a\n      // counterclockwise curve; zero will produce a straight line.\n      const bendAngle = this.sweep(x1, y1, x2, y2) * bend * radians;\n\n      // The radius of the circle that intersects with the two endpoints\n      // and has the specified bend angle.\n      const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;\n\n      // Apply insets.\n      if (insetStart || insetEnd) {\n        if (r < 1e5) {\n          // For inset swoopy arrows, compute the circle-circle\n          // intersection between a circle centered around the\n          // respective arrow endpoint and the center of the circle\n          // segment that forms the shaft of the arrow.\n          const sign = Math.sign(bendAngle);\n          const [cx, cy] = pointPointCenter([x1, y1], [x2, y2], r, sign);\n          if (insetStart) {\n            [x1, y1] = circleCircleIntersect([cx, cy, r], [x1, y1, insetStart], -sign * Math.sign(insetStart));\n          }\n          // For the end inset, rotate the arrowhead so that it aligns\n          // with the truncated end of the arrow. Since the arrow is a\n          // segment of the circle centered at ⟨cx,cy⟩, we can compute\n          // the angular difference to the new endpoint.\n          if (insetEnd) {\n            const [x, y] = circleCircleIntersect([cx, cy, r], [x2, y2, insetEnd], sign * Math.sign(insetEnd));\n            lineAngle += Math.atan2(y - cy, x - cx) - Math.atan2(y2 - cy, x2 - cx);\n            x2 = x, y2 = y;\n          }\n        } else {\n          // For inset straight arrows, offset along the straight line.\n          const dx = x2 - x1,\n            dy = y2 - y1,\n            d = Math.hypot(dx, dy);\n          if (insetStart) x1 += dx / d * insetStart, y1 += dy / d * insetStart;\n          if (insetEnd) x2 -= dx / d * insetEnd, y2 -= dy / d * insetEnd;\n        }\n      }\n\n      // The angle of the arrow as it approaches the endpoint, and the\n      // angles of the adjacent wings. Here “left” refers to if the\n      // arrow is pointing up.\n      const endAngle = lineAngle + bendAngle;\n      const leftAngle = endAngle + wingAngle;\n      const rightAngle = endAngle - wingAngle;\n\n      // The endpoints of the two wings.\n      const x3 = x2 - headLength * Math.cos(leftAngle);\n      const y3 = y2 - headLength * Math.sin(leftAngle);\n      const x4 = x2 - headLength * Math.cos(rightAngle);\n      const y4 = y2 - headLength * Math.sin(rightAngle);\n\n      // If the radius is very large (or even infinite, as when the bend\n      // angle is zero), then render a straight line.\n      const a = r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`;\n      const h = headLength ? `M${x3},${y3}L${x2},${y2}L${x4},${y4}` : \"\";\n      return `M${x1},${y1}${a}${x2},${y2}${h}`;\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n}\n\n// Maybe flip the bend angle, depending on the arrow orientation.\nfunction maybeSweep(sweep = 1) {\n  if (typeof sweep === \"number\") return constant(Math.sign(sweep));\n  if (typeof sweep === \"function\") return (x1, y1, x2, y2) => Math.sign(sweep(x1, y1, x2, y2));\n  switch (keyword(sweep, \"sweep\", [\"+x\", \"-x\", \"+y\", \"-y\"])) {\n    case \"+x\":\n      return (x1, y1, x2) => ascending(x1, x2);\n    case \"-x\":\n      return (x1, y1, x2) => descending(x1, x2);\n    case \"+y\":\n      return (x1, y1, x2, y2) => ascending(y1, y2);\n    case \"-y\":\n      return (x1, y1, x2, y2) => descending(y1, y2);\n  }\n}\n\n// Returns the center of a circle that goes through the two given points ⟨ax,ay⟩\n// and ⟨bx,by⟩ and has radius r. There are two such points; use the sign +1 or\n// -1 to choose between them. Returns [NaN, NaN] if r is too small.\nfunction pointPointCenter([ax, ay], [bx, by], r, sign) {\n  const dx = bx - ax,\n    dy = by - ay,\n    d = Math.hypot(dx, dy);\n  const k = sign * Math.sqrt(r * r - d * d / 4) / d;\n  return [(ax + bx) / 2 - dy * k, (ay + by) / 2 + dx * k];\n}\n\n// Given two circles, one centered at ⟨ax,ay⟩ with radius ar, and the other\n// centered at ⟨bx,by⟩ with radius br, returns a point at which the two circles\n// intersect. There are typically two such points; use the sign +1 or -1 to\n// chose between them. Returns [NaN, NaN] if there is no intersection.\n// https://mathworld.wolfram.com/Circle-CircleIntersection.html\nfunction circleCircleIntersect([ax, ay, ar], [bx, by, br], sign) {\n  const dx = bx - ax,\n    dy = by - ay,\n    d = Math.hypot(dx, dy);\n  const x = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);\n  const y = sign * Math.sqrt(ar * ar - x * x);\n  return [ax + (dx * x + dy * y) / d, ay + (dy * x - dx * y) / d];\n}\nexport function arrow(data, {\n  x,\n  x1,\n  x2,\n  y,\n  y1,\n  y2,\n  ...options\n} = {}) {\n  [x1, x2] = maybeSameValue(x, x1, x2);\n  [y1, y2] = maybeSameValue(y, y1, y2);\n  return new Arrow(data, {\n    ...options,\n    x1,\n    x2,\n    y1,\n    y2\n  });\n}","map":{"version":3,"names":["ascending","descending","create","Mark","radians","constant","keyword","applyChannelStyles","applyDirectStyles","applyIndirectStyles","applyTransform","maybeSameValue","defaults","ariaLabel","fill","stroke","strokeLinecap","strokeMiterlimit","strokeWidth","Arrow","constructor","data","options","x1","y1","x2","y2","bend","headAngle","headLength","inset","insetStart","insetEnd","sweep","value","scale","optional","Math","max","min","maybeSweep","render","index","scales","channels","dimensions","context","X1","Y1","X2","Y2","SW","sw","i","undefined","wingAngle","wingScale","call","g","selectAll","enter","append","attr","lineLength","hypot","lineAngle","atan2","bendAngle","r","tan","sign","cx","cy","pointPointCenter","circleCircleIntersect","x","y","dx","dy","d","endAngle","leftAngle","rightAngle","x3","cos","y3","sin","x4","y4","a","h","node","ax","ay","bx","by","k","sqrt","ar","br","arrow"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/arrow.js"],"sourcesContent":["import {ascending, descending} from \"d3\";\nimport {create} from \"../context.js\";\nimport {Mark} from \"../mark.js\";\nimport {radians} from \"../math.js\";\nimport {constant, keyword} from \"../options.js\";\nimport {applyChannelStyles, applyDirectStyles, applyIndirectStyles, applyTransform} from \"../style.js\";\nimport {maybeSameValue} from \"./link.js\";\n\nconst defaults = {\n  ariaLabel: \"arrow\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeMiterlimit: 1,\n  strokeWidth: 1.5\n};\n\nexport class Arrow extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1,\n      y1,\n      x2,\n      y2,\n      bend = 0,\n      headAngle = 60,\n      headLength = 8, // Disable the arrow with headLength = 0; or, use Plot.link.\n      inset = 0,\n      insetStart = inset,\n      insetEnd = inset,\n      sweep\n    } = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\"},\n        y1: {value: y1, scale: \"y\"},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true}\n      },\n      options,\n      defaults\n    );\n    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));\n    this.headAngle = +headAngle;\n    this.headLength = +headLength;\n    this.insetStart = +insetStart;\n    this.insetEnd = +insetEnd;\n    this.sweep = maybeSweep(sweep);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1, SW} = channels;\n    const {strokeWidth, bend, headAngle, headLength, insetStart, insetEnd} = this;\n    const sw = SW ? (i) => SW[i] : constant(strokeWidth === undefined ? 1 : strokeWidth);\n\n    // The angle between the arrow’s shaft and one of the wings; the “head”\n    // angle between the wings is twice this value.\n    const wingAngle = (headAngle * radians) / 2;\n\n    // The length of the arrowhead’s “wings” (the line segments that extend from\n    // the end point) relative to the stroke width.\n    const wingScale = headLength / 1.5;\n\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .attr(\"d\", (i) => {\n            // The start ⟨x1,y1⟩ and end ⟨x2,y2⟩ points may be inset, and the\n            // ending line angle may be altered for inset swoopy arrows.\n            let x1 = X1[i],\n              y1 = Y1[i],\n              x2 = X2[i],\n              y2 = Y2[i];\n            const lineLength = Math.hypot(x2 - x1, y2 - y1);\n            if (lineLength <= insetStart + insetEnd) return null;\n            let lineAngle = Math.atan2(y2 - y1, x2 - x1);\n\n            // We don’t allow the wing length to be too large relative to the\n            // length of the arrow. (Plot.vector allows arbitrarily large\n            // wings, but that’s okay since vectors are usually small.)\n            const headLength = Math.min(wingScale * sw(i), lineLength / 3);\n\n            // When bending, the offset between the straight line between the two points\n            // and the outgoing tangent from the start point. (Also the negative\n            // incoming tangent to the end point.) This must be within ±π/2. A positive\n            // angle will produce a clockwise curve; a negative angle will produce a\n            // counterclockwise curve; zero will produce a straight line.\n            const bendAngle = this.sweep(x1, y1, x2, y2) * bend * radians;\n\n            // The radius of the circle that intersects with the two endpoints\n            // and has the specified bend angle.\n            const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;\n\n            // Apply insets.\n            if (insetStart || insetEnd) {\n              if (r < 1e5) {\n                // For inset swoopy arrows, compute the circle-circle\n                // intersection between a circle centered around the\n                // respective arrow endpoint and the center of the circle\n                // segment that forms the shaft of the arrow.\n                const sign = Math.sign(bendAngle);\n                const [cx, cy] = pointPointCenter([x1, y1], [x2, y2], r, sign);\n                if (insetStart) {\n                  [x1, y1] = circleCircleIntersect([cx, cy, r], [x1, y1, insetStart], -sign * Math.sign(insetStart));\n                }\n                // For the end inset, rotate the arrowhead so that it aligns\n                // with the truncated end of the arrow. Since the arrow is a\n                // segment of the circle centered at ⟨cx,cy⟩, we can compute\n                // the angular difference to the new endpoint.\n                if (insetEnd) {\n                  const [x, y] = circleCircleIntersect([cx, cy, r], [x2, y2, insetEnd], sign * Math.sign(insetEnd));\n                  lineAngle += Math.atan2(y - cy, x - cx) - Math.atan2(y2 - cy, x2 - cx);\n                  (x2 = x), (y2 = y);\n                }\n              } else {\n                // For inset straight arrows, offset along the straight line.\n                const dx = x2 - x1,\n                  dy = y2 - y1,\n                  d = Math.hypot(dx, dy);\n                if (insetStart) (x1 += (dx / d) * insetStart), (y1 += (dy / d) * insetStart);\n                if (insetEnd) (x2 -= (dx / d) * insetEnd), (y2 -= (dy / d) * insetEnd);\n              }\n            }\n\n            // The angle of the arrow as it approaches the endpoint, and the\n            // angles of the adjacent wings. Here “left” refers to if the\n            // arrow is pointing up.\n            const endAngle = lineAngle + bendAngle;\n            const leftAngle = endAngle + wingAngle;\n            const rightAngle = endAngle - wingAngle;\n\n            // The endpoints of the two wings.\n            const x3 = x2 - headLength * Math.cos(leftAngle);\n            const y3 = y2 - headLength * Math.sin(leftAngle);\n            const x4 = x2 - headLength * Math.cos(rightAngle);\n            const y4 = y2 - headLength * Math.sin(rightAngle);\n\n            // If the radius is very large (or even infinite, as when the bend\n            // angle is zero), then render a straight line.\n            const a = r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`;\n            const h = headLength ? `M${x3},${y3}L${x2},${y2}L${x4},${y4}` : \"\";\n            return `M${x1},${y1}${a}${x2},${y2}${h}`;\n          })\n          .call(applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\n// Maybe flip the bend angle, depending on the arrow orientation.\nfunction maybeSweep(sweep = 1) {\n  if (typeof sweep === \"number\") return constant(Math.sign(sweep));\n  if (typeof sweep === \"function\") return (x1, y1, x2, y2) => Math.sign(sweep(x1, y1, x2, y2));\n  switch (keyword(sweep, \"sweep\", [\"+x\", \"-x\", \"+y\", \"-y\"])) {\n    case \"+x\":\n      return (x1, y1, x2) => ascending(x1, x2);\n    case \"-x\":\n      return (x1, y1, x2) => descending(x1, x2);\n    case \"+y\":\n      return (x1, y1, x2, y2) => ascending(y1, y2);\n    case \"-y\":\n      return (x1, y1, x2, y2) => descending(y1, y2);\n  }\n}\n\n// Returns the center of a circle that goes through the two given points ⟨ax,ay⟩\n// and ⟨bx,by⟩ and has radius r. There are two such points; use the sign +1 or\n// -1 to choose between them. Returns [NaN, NaN] if r is too small.\nfunction pointPointCenter([ax, ay], [bx, by], r, sign) {\n  const dx = bx - ax,\n    dy = by - ay,\n    d = Math.hypot(dx, dy);\n  const k = (sign * Math.sqrt(r * r - (d * d) / 4)) / d;\n  return [(ax + bx) / 2 - dy * k, (ay + by) / 2 + dx * k];\n}\n\n// Given two circles, one centered at ⟨ax,ay⟩ with radius ar, and the other\n// centered at ⟨bx,by⟩ with radius br, returns a point at which the two circles\n// intersect. There are typically two such points; use the sign +1 or -1 to\n// chose between them. Returns [NaN, NaN] if there is no intersection.\n// https://mathworld.wolfram.com/Circle-CircleIntersection.html\nfunction circleCircleIntersect([ax, ay, ar], [bx, by, br], sign) {\n  const dx = bx - ax,\n    dy = by - ay,\n    d = Math.hypot(dx, dy);\n  const x = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);\n  const y = sign * Math.sqrt(ar * ar - x * x);\n  return [ax + (dx * x + dy * y) / d, ay + (dy * x - dx * y) / d];\n}\n\nexport function arrow(data, {x, x1, x2, y, y1, y2, ...options} = {}) {\n  [x1, x2] = maybeSameValue(x, x1, x2);\n  [y1, y2] = maybeSameValue(y, y1, y2);\n  return new Arrow(data, {...options, x1, x2, y1, y2});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}