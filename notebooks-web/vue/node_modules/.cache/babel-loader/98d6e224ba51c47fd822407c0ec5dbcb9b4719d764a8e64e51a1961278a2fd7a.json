{"ast":null,"code":"import { channelDomain, createChannels, valueObject } from \"./channel.js\";\nimport { defined } from \"./defined.js\";\nimport { maybeFacetAnchor } from \"./facet.js\";\nimport { maybeClip, maybeNamed, maybeValue } from \"./options.js\";\nimport { dataify, isDomainSort, isObject, isOptions, keyword, range, singleton } from \"./options.js\";\nimport { project } from \"./projection.js\";\nimport { maybeClassName, styles } from \"./style.js\";\nimport { basic, initializer } from \"./transforms/basic.js\";\nexport class Mark {\n  constructor(data, channels = {}, options = {}, defaults) {\n    const {\n      facet = \"auto\",\n      facetAnchor,\n      fx,\n      fy,\n      sort,\n      dx = 0,\n      dy = 0,\n      margin = 0,\n      marginTop = margin,\n      marginRight = margin,\n      marginBottom = margin,\n      marginLeft = margin,\n      className,\n      clip = defaults?.clip,\n      channels: extraChannels,\n      tip,\n      render\n    } = options;\n    this.data = data;\n    this.sort = isDomainSort(sort) ? sort : null;\n    this.initializer = initializer(options).initializer;\n    this.transform = this.initializer ? options.transform : basic(options).transform;\n    if (facet === null || facet === false) {\n      this.facet = null;\n    } else {\n      this.facet = keyword(facet === true ? \"include\" : facet, \"facet\", [\"auto\", \"include\", \"exclude\", \"super\"]);\n      this.fx = data === singleton && typeof fx === \"string\" ? [fx] : fx;\n      this.fy = data === singleton && typeof fy === \"string\" ? [fy] : fy;\n    }\n    this.facetAnchor = maybeFacetAnchor(facetAnchor);\n    channels = maybeNamed(channels);\n    if (extraChannels !== undefined) channels = {\n      ...maybeChannels(extraChannels),\n      ...channels\n    };\n    if (defaults !== undefined) channels = {\n      ...styles(this, options, defaults),\n      ...channels\n    };\n    this.channels = Object.fromEntries(Object.entries(channels).map(([name, channel]) => {\n      if (isOptions(channel.value)) {\n        // apply scale and label overrides\n        const {\n          value,\n          label = channel.label,\n          scale = channel.scale\n        } = channel.value;\n        channel = {\n          ...channel,\n          label,\n          scale,\n          value\n        };\n      }\n      if (data === singleton && typeof channel.value === \"string\") {\n        // convert field names to singleton values for decoration marks (e.g., frame)\n        const {\n          value\n        } = channel;\n        channel = {\n          ...channel,\n          value: [value]\n        };\n      }\n      return [name, channel];\n    }).filter(([name, {\n      value,\n      optional\n    }]) => {\n      if (value != null) return true;\n      if (optional) return false;\n      throw new Error(`missing channel value: ${name}`);\n    }));\n    this.dx = +dx;\n    this.dy = +dy;\n    this.marginTop = +marginTop;\n    this.marginRight = +marginRight;\n    this.marginBottom = +marginBottom;\n    this.marginLeft = +marginLeft;\n    this.clip = maybeClip(clip);\n    this.tip = maybeTip(tip);\n    this.className = className ? maybeClassName(className) : null;\n    // Super-faceting currently disallow position channels; in the future, we\n    // could allow position to be specified in fx and fy in addition to (or\n    // instead of) x and y.\n    if (this.facet === \"super\") {\n      if (fx || fy) throw new Error(`super-faceting cannot use fx or fy`);\n      for (const name in this.channels) {\n        const {\n          scale\n        } = channels[name];\n        if (scale !== \"x\" && scale !== \"y\") continue;\n        throw new Error(`super-faceting cannot use x or y`);\n      }\n    }\n    if (render != null) {\n      this.render = composeRender(render, this.render);\n    }\n  }\n  initialize(facets, facetChannels, plotOptions) {\n    let data = dataify(this.data);\n    if (facets === undefined && data != null) facets = [range(data)];\n    const originalFacets = facets;\n    if (this.transform != null) ({\n      facets,\n      data\n    } = this.transform(data, facets, plotOptions)), data = dataify(data);\n    if (facets !== undefined) facets.original = originalFacets; // needed to read facetChannels\n    const channels = createChannels(this.channels, data);\n    if (this.sort != null) channelDomain(data, facets, channels, facetChannels, this.sort); // mutates facetChannels!\n    return {\n      data,\n      facets,\n      channels\n    };\n  }\n  filter(index, channels, values) {\n    for (const name in channels) {\n      const {\n        filter = defined\n      } = channels[name];\n      if (filter !== null) {\n        const value = values[name];\n        index = index.filter(i => filter(value[i]));\n      }\n    }\n    return index;\n  }\n  // If there is a projection, and there are paired x and y channels associated\n  // with the x and y scale respectively (and not already in screen coordinates\n  // as with an initializer), then apply the projection, replacing the x and y\n  // values. Note that the x and y scales themselves donâ€™t exist if there is a\n  // projection, but whether the channels are associated with scales still\n  // determines whether the projection should apply; think of the projection as\n  // a combination xy-scale.\n  project(channels, values, context) {\n    for (const cx in channels) {\n      if (channels[cx].scale === \"x\" && /^x|x$/.test(cx)) {\n        const cy = cx.replace(/^x|x$/, \"y\");\n        if (cy in channels && channels[cy].scale === \"y\") {\n          project(cx, cy, values, context.projection);\n        }\n      }\n    }\n  }\n  scale(channels, scales, context) {\n    const values = valueObject(channels, scales);\n    if (context.projection) this.project(channels, values, context);\n    return values;\n  }\n}\nexport function marks(...marks) {\n  marks.plot = Mark.prototype.plot;\n  return marks;\n}\nexport function composeRender(r1, r2) {\n  if (r1 == null) return r2 === null ? undefined : r2;\n  if (r2 == null) return r1 === null ? undefined : r1;\n  if (typeof r1 !== \"function\") throw new TypeError(`invalid render transform: ${r1}`);\n  if (typeof r2 !== \"function\") throw new TypeError(`invalid render transform: ${r2}`);\n  return function (i, s, v, d, c, next) {\n    return r1.call(this, i, s, v, d, c, (i, s, v, d, c) => {\n      return r2.call(this, i, s, v, d, c, next); // preserve this\n    });\n  };\n}\n\nfunction maybeChannels(channels) {\n  return Object.fromEntries(Object.entries(maybeNamed(channels)).map(([name, channel]) => {\n    channel = typeof channel === \"string\" ? {\n      value: channel,\n      label: name\n    } : maybeValue(channel); // for shorthand extra channels, use name as label\n    if (channel.filter === undefined && channel.scale == null) channel = {\n      ...channel,\n      filter: null\n    };\n    return [name, channel];\n  }));\n}\nfunction maybeTip(tip) {\n  return tip === true ? \"xy\" : tip === false || tip == null ? null : typeof tip === \"string\" ? keyword(tip, \"tip\", [\"x\", \"y\", \"xy\"]) : tip; // tip options object\n}\n\nexport function withTip(options, pointer) {\n  return options?.tip === true ? {\n    ...options,\n    tip: pointer\n  } : isObject(options?.tip) && options.tip.pointer === undefined ? {\n    ...options,\n    tip: {\n      ...options.tip,\n      pointer\n    }\n  } : options;\n}","map":{"version":3,"names":["channelDomain","createChannels","valueObject","defined","maybeFacetAnchor","maybeClip","maybeNamed","maybeValue","dataify","isDomainSort","isObject","isOptions","keyword","range","singleton","project","maybeClassName","styles","basic","initializer","Mark","constructor","data","channels","options","defaults","facet","facetAnchor","fx","fy","sort","dx","dy","margin","marginTop","marginRight","marginBottom","marginLeft","className","clip","extraChannels","tip","render","transform","undefined","maybeChannels","Object","fromEntries","entries","map","name","channel","value","label","scale","filter","optional","Error","maybeTip","composeRender","initialize","facets","facetChannels","plotOptions","originalFacets","original","index","values","i","context","cx","test","cy","replace","projection","scales","marks","plot","prototype","r1","r2","TypeError","s","v","d","c","next","call","withTip","pointer"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/mark.js"],"sourcesContent":["import {channelDomain, createChannels, valueObject} from \"./channel.js\";\nimport {defined} from \"./defined.js\";\nimport {maybeFacetAnchor} from \"./facet.js\";\nimport {maybeClip, maybeNamed, maybeValue} from \"./options.js\";\nimport {dataify, isDomainSort, isObject, isOptions, keyword, range, singleton} from \"./options.js\";\nimport {project} from \"./projection.js\";\nimport {maybeClassName, styles} from \"./style.js\";\nimport {basic, initializer} from \"./transforms/basic.js\";\n\nexport class Mark {\n  constructor(data, channels = {}, options = {}, defaults) {\n    const {\n      facet = \"auto\",\n      facetAnchor,\n      fx,\n      fy,\n      sort,\n      dx = 0,\n      dy = 0,\n      margin = 0,\n      marginTop = margin,\n      marginRight = margin,\n      marginBottom = margin,\n      marginLeft = margin,\n      className,\n      clip = defaults?.clip,\n      channels: extraChannels,\n      tip,\n      render\n    } = options;\n    this.data = data;\n    this.sort = isDomainSort(sort) ? sort : null;\n    this.initializer = initializer(options).initializer;\n    this.transform = this.initializer ? options.transform : basic(options).transform;\n    if (facet === null || facet === false) {\n      this.facet = null;\n    } else {\n      this.facet = keyword(facet === true ? \"include\" : facet, \"facet\", [\"auto\", \"include\", \"exclude\", \"super\"]);\n      this.fx = data === singleton && typeof fx === \"string\" ? [fx] : fx;\n      this.fy = data === singleton && typeof fy === \"string\" ? [fy] : fy;\n    }\n    this.facetAnchor = maybeFacetAnchor(facetAnchor);\n    channels = maybeNamed(channels);\n    if (extraChannels !== undefined) channels = {...maybeChannels(extraChannels), ...channels};\n    if (defaults !== undefined) channels = {...styles(this, options, defaults), ...channels};\n    this.channels = Object.fromEntries(\n      Object.entries(channels)\n        .map(([name, channel]) => {\n          if (isOptions(channel.value)) {\n            // apply scale and label overrides\n            const {value, label = channel.label, scale = channel.scale} = channel.value;\n            channel = {...channel, label, scale, value};\n          }\n          if (data === singleton && typeof channel.value === \"string\") {\n            // convert field names to singleton values for decoration marks (e.g., frame)\n            const {value} = channel;\n            channel = {...channel, value: [value]};\n          }\n          return [name, channel];\n        })\n        .filter(([name, {value, optional}]) => {\n          if (value != null) return true;\n          if (optional) return false;\n          throw new Error(`missing channel value: ${name}`);\n        })\n    );\n    this.dx = +dx;\n    this.dy = +dy;\n    this.marginTop = +marginTop;\n    this.marginRight = +marginRight;\n    this.marginBottom = +marginBottom;\n    this.marginLeft = +marginLeft;\n    this.clip = maybeClip(clip);\n    this.tip = maybeTip(tip);\n    this.className = className ? maybeClassName(className) : null;\n    // Super-faceting currently disallow position channels; in the future, we\n    // could allow position to be specified in fx and fy in addition to (or\n    // instead of) x and y.\n    if (this.facet === \"super\") {\n      if (fx || fy) throw new Error(`super-faceting cannot use fx or fy`);\n      for (const name in this.channels) {\n        const {scale} = channels[name];\n        if (scale !== \"x\" && scale !== \"y\") continue;\n        throw new Error(`super-faceting cannot use x or y`);\n      }\n    }\n    if (render != null) {\n      this.render = composeRender(render, this.render);\n    }\n  }\n  initialize(facets, facetChannels, plotOptions) {\n    let data = dataify(this.data);\n    if (facets === undefined && data != null) facets = [range(data)];\n    const originalFacets = facets;\n    if (this.transform != null) ({facets, data} = this.transform(data, facets, plotOptions)), (data = dataify(data));\n    if (facets !== undefined) facets.original = originalFacets; // needed to read facetChannels\n    const channels = createChannels(this.channels, data);\n    if (this.sort != null) channelDomain(data, facets, channels, facetChannels, this.sort); // mutates facetChannels!\n    return {data, facets, channels};\n  }\n  filter(index, channels, values) {\n    for (const name in channels) {\n      const {filter = defined} = channels[name];\n      if (filter !== null) {\n        const value = values[name];\n        index = index.filter((i) => filter(value[i]));\n      }\n    }\n    return index;\n  }\n  // If there is a projection, and there are paired x and y channels associated\n  // with the x and y scale respectively (and not already in screen coordinates\n  // as with an initializer), then apply the projection, replacing the x and y\n  // values. Note that the x and y scales themselves donâ€™t exist if there is a\n  // projection, but whether the channels are associated with scales still\n  // determines whether the projection should apply; think of the projection as\n  // a combination xy-scale.\n  project(channels, values, context) {\n    for (const cx in channels) {\n      if (channels[cx].scale === \"x\" && /^x|x$/.test(cx)) {\n        const cy = cx.replace(/^x|x$/, \"y\");\n        if (cy in channels && channels[cy].scale === \"y\") {\n          project(cx, cy, values, context.projection);\n        }\n      }\n    }\n  }\n  scale(channels, scales, context) {\n    const values = valueObject(channels, scales);\n    if (context.projection) this.project(channels, values, context);\n    return values;\n  }\n}\n\nexport function marks(...marks) {\n  marks.plot = Mark.prototype.plot;\n  return marks;\n}\n\nexport function composeRender(r1, r2) {\n  if (r1 == null) return r2 === null ? undefined : r2;\n  if (r2 == null) return r1 === null ? undefined : r1;\n  if (typeof r1 !== \"function\") throw new TypeError(`invalid render transform: ${r1}`);\n  if (typeof r2 !== \"function\") throw new TypeError(`invalid render transform: ${r2}`);\n  return function (i, s, v, d, c, next) {\n    return r1.call(this, i, s, v, d, c, (i, s, v, d, c) => {\n      return r2.call(this, i, s, v, d, c, next); // preserve this\n    });\n  };\n}\n\nfunction maybeChannels(channels) {\n  return Object.fromEntries(\n    Object.entries(maybeNamed(channels)).map(([name, channel]) => {\n      channel = typeof channel === \"string\" ? {value: channel, label: name} : maybeValue(channel); // for shorthand extra channels, use name as label\n      if (channel.filter === undefined && channel.scale == null) channel = {...channel, filter: null};\n      return [name, channel];\n    })\n  );\n}\n\nfunction maybeTip(tip) {\n  return tip === true\n    ? \"xy\"\n    : tip === false || tip == null\n    ? null\n    : typeof tip === \"string\"\n    ? keyword(tip, \"tip\", [\"x\", \"y\", \"xy\"])\n    : tip; // tip options object\n}\n\nexport function withTip(options, pointer) {\n  return options?.tip === true\n    ? {...options, tip: pointer}\n    : isObject(options?.tip) && options.tip.pointer === undefined\n    ? {...options, tip: {...options.tip, pointer}}\n    : options;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}