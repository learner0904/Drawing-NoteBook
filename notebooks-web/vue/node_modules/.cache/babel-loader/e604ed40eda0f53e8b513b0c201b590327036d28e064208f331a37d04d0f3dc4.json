{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { geoPath, line as shapeLine } from \"d3\";\nimport { create } from \"../context.js\";\nimport { curveAuto, maybeCurveAuto } from \"../curve.js\";\nimport { Mark } from \"../mark.js\";\nimport { applyGroupedMarkers, markers } from \"../marker.js\";\nimport { coerceNumbers, indexOf, identity, maybeTuple, maybeZ } from \"../options.js\";\nimport { applyDirectStyles, applyIndirectStyles, applyTransform, applyGroupedChannelStyles, groupIndex } from \"../style.js\";\nimport { maybeDenseIntervalX, maybeDenseIntervalY } from \"../transforms/bin.js\";\nconst defaults = {\n  ariaLabel: \"line\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nexport class Line extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x,\n      y,\n      z,\n      curve,\n      tension\n    } = options;\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\"\n      },\n      y: {\n        value: y,\n        scale: \"y\"\n      },\n      z: {\n        value: maybeZ(options),\n        optional: true\n      }\n    }, options, defaults);\n    this.z = z;\n    this.curve = maybeCurveAuto(curve, tension);\n    markers(this, options);\n  }\n  filter(index) {\n    return index;\n  }\n  project(channels, values, context) {\n    // For the auto curve, projection is handled at render.\n    if (this.curve !== curveAuto) {\n      super.project(channels, values, context);\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x: X,\n      y: Y\n    } = channels;\n    const {\n      curve\n    } = this;\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(g => g.selectAll().data(groupIndex(index, [X, Y], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels, context).attr(\"d\", curve === curveAuto && context.projection ? sphereLine(context.projection, X, Y) : shapeLine().curve(curve).defined(i => i >= 0).x(i => X[i]).y(i => Y[i]))).node();\n  }\n}\nfunction sphereLine(projection, X, Y) {\n  const path = geoPath(projection);\n  X = coerceNumbers(X);\n  Y = coerceNumbers(Y);\n  return I => {\n    let line = [];\n    const lines = [line];\n    for (const i of I) {\n      // Check for undefined value; see groupIndex.\n      if (i === -1) {\n        line = [];\n        lines.push(line);\n      } else {\n        line.push([X[i], Y[i]]);\n      }\n    }\n    return path({\n      type: \"MultiLineString\",\n      coordinates: lines\n    });\n  };\n}\nexport function line(data, {\n  x,\n  y,\n  ...options\n} = {}) {\n  [x, y] = maybeTuple(x, y);\n  return new Line(data, {\n    ...options,\n    x,\n    y\n  });\n}\nexport function lineX(data, {\n  x = identity,\n  y = indexOf,\n  ...options\n} = {}) {\n  return new Line(data, maybeDenseIntervalY({\n    ...options,\n    x,\n    y\n  }));\n}\nexport function lineY(data, {\n  x = indexOf,\n  y = identity,\n  ...options\n} = {}) {\n  return new Line(data, maybeDenseIntervalX({\n    ...options,\n    x,\n    y\n  }));\n}","map":{"version":3,"names":["geoPath","line","shapeLine","create","curveAuto","maybeCurveAuto","Mark","applyGroupedMarkers","markers","coerceNumbers","indexOf","identity","maybeTuple","maybeZ","applyDirectStyles","applyIndirectStyles","applyTransform","applyGroupedChannelStyles","groupIndex","maybeDenseIntervalX","maybeDenseIntervalY","defaults","ariaLabel","fill","stroke","strokeWidth","strokeLinecap","strokeLinejoin","strokeMiterlimit","Line","constructor","data","options","x","y","z","curve","tension","value","scale","optional","filter","index","project","channels","values","context","render","scales","dimensions","X","Y","call","g","selectAll","enter","append","attr","projection","sphereLine","defined","i","node","path","I","lines","push","type","coordinates","lineX","lineY"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/line.js"],"sourcesContent":["import {geoPath, line as shapeLine} from \"d3\";\nimport {create} from \"../context.js\";\nimport {curveAuto, maybeCurveAuto} from \"../curve.js\";\nimport {Mark} from \"../mark.js\";\nimport {applyGroupedMarkers, markers} from \"../marker.js\";\nimport {coerceNumbers, indexOf, identity, maybeTuple, maybeZ} from \"../options.js\";\nimport {\n  applyDirectStyles,\n  applyIndirectStyles,\n  applyTransform,\n  applyGroupedChannelStyles,\n  groupIndex\n} from \"../style.js\";\nimport {maybeDenseIntervalX, maybeDenseIntervalY} from \"../transforms/bin.js\";\n\nconst defaults = {\n  ariaLabel: \"line\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\n\nexport class Line extends Mark {\n  constructor(data, options = {}) {\n    const {x, y, z, curve, tension} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\"},\n        y: {value: y, scale: \"y\"},\n        z: {value: maybeZ(options), optional: true}\n      },\n      options,\n      defaults\n    );\n    this.z = z;\n    this.curve = maybeCurveAuto(curve, tension);\n    markers(this, options);\n  }\n  filter(index) {\n    return index;\n  }\n  project(channels, values, context) {\n    // For the auto curve, projection is handled at render.\n    if (this.curve !== curveAuto) {\n      super.project(channels, values, context);\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x: X, y: Y} = channels;\n    const {curve} = this;\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, scales)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(groupIndex(index, [X, Y], this, channels))\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .call(applyGroupedChannelStyles, this, channels)\n          .call(applyGroupedMarkers, this, channels, context)\n          .attr(\n            \"d\",\n            curve === curveAuto && context.projection\n              ? sphereLine(context.projection, X, Y)\n              : shapeLine()\n                  .curve(curve)\n                  .defined((i) => i >= 0)\n                  .x((i) => X[i])\n                  .y((i) => Y[i])\n          )\n      )\n      .node();\n  }\n}\n\nfunction sphereLine(projection, X, Y) {\n  const path = geoPath(projection);\n  X = coerceNumbers(X);\n  Y = coerceNumbers(Y);\n  return (I) => {\n    let line = [];\n    const lines = [line];\n    for (const i of I) {\n      // Check for undefined value; see groupIndex.\n      if (i === -1) {\n        line = [];\n        lines.push(line);\n      } else {\n        line.push([X[i], Y[i]]);\n      }\n    }\n    return path({type: \"MultiLineString\", coordinates: lines});\n  };\n}\n\nexport function line(data, {x, y, ...options} = {}) {\n  [x, y] = maybeTuple(x, y);\n  return new Line(data, {...options, x, y});\n}\n\nexport function lineX(data, {x = identity, y = indexOf, ...options} = {}) {\n  return new Line(data, maybeDenseIntervalY({...options, x, y}));\n}\n\nexport function lineY(data, {x = indexOf, y = identity, ...options} = {}) {\n  return new Line(data, maybeDenseIntervalX({...options, x, y}));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}