{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport IntervalTree from \"interval-tree-1d\";\nimport { finite, positive } from \"../defined.js\";\nimport { identity, maybeNamed, number, valueof } from \"../options.js\";\nimport { initializer } from \"./basic.js\";\nimport { applyPosition } from \"../projection.js\";\nconst anchorXLeft = ({\n  marginLeft\n}) => [1, marginLeft];\nconst anchorXRight = ({\n  width,\n  marginRight\n}) => [-1, width - marginRight];\nconst anchorXMiddle = ({\n  width,\n  marginLeft,\n  marginRight\n}) => [0, (marginLeft + width - marginRight) / 2];\nconst anchorYTop = ({\n  marginTop\n}) => [1, marginTop];\nconst anchorYBottom = ({\n  height,\n  marginBottom\n}) => [-1, height - marginBottom];\nconst anchorYMiddle = ({\n  height,\n  marginTop,\n  marginBottom\n}) => [0, (marginTop + height - marginBottom) / 2];\nfunction maybeAnchor(anchor) {\n  return typeof anchor === \"string\" ? {\n    anchor\n  } : anchor;\n}\nexport function dodgeX(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions(dodgeOptions);\n  let {\n    anchor = \"left\",\n    padding = 1,\n    r = options.r\n  } = maybeAnchor(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"left\":\n      anchor = anchorXLeft;\n      break;\n    case \"right\":\n      anchor = anchorXRight;\n      break;\n    case \"middle\":\n      anchor = anchorXMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"x\", \"y\", anchor, number(padding), r, options);\n}\nexport function dodgeY(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions(dodgeOptions);\n  let {\n    anchor = \"bottom\",\n    padding = 1,\n    r = options.r\n  } = maybeAnchor(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"top\":\n      anchor = anchorYTop;\n      break;\n    case \"bottom\":\n      anchor = anchorYBottom;\n      break;\n    case \"middle\":\n      anchor = anchorYMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"y\", \"x\", anchor, number(padding), r, options);\n}\nfunction mergeOptions(options) {\n  const {\n    anchor,\n    padding,\n    ...rest\n  } = options;\n  const {\n    r\n  } = rest; // don’t consume r; allow it to propagate\n  return [{\n    anchor,\n    padding,\n    r\n  }, rest];\n}\nfunction dodge(y, x, anchor, padding, r, options) {\n  if (r != null && typeof r !== \"number\") {\n    let {\n      channels,\n      sort,\n      reverse\n    } = options;\n    channels = maybeNamed(channels);\n    if (channels?.r === undefined) options = {\n      ...options,\n      channels: {\n        ...channels,\n        r: {\n          value: r,\n          scale: \"r\"\n        }\n      }\n    };\n    if (sort === undefined && reverse === undefined) options.sort = {\n      channel: \"-r\"\n    };\n  }\n  return initializer(options, function (data, facets, channels, scales, dimensions, context) {\n    let {\n      [x]: X,\n      r: R\n    } = channels;\n    if (!channels[x]) throw new Error(`missing channel: ${x}`);\n    ({\n      [x]: X\n    } = applyPosition(channels, scales, context));\n    const cr = R ? undefined : r !== undefined ? number(r) : this.r !== undefined ? this.r : 3;\n    if (R) R = valueof(R.value, scales[R.scale] || identity, Float64Array);\n    let [ky, ty] = anchor(dimensions);\n    const compare = ky ? compareAscending : compareSymmetric;\n    const Y = new Float64Array(X.length);\n    const radius = R ? i => R[i] : () => cr;\n    for (let I of facets) {\n      const tree = IntervalTree();\n      I = I.filter(R ? i => finite(X[i]) && positive(R[i]) : i => finite(X[i]));\n      const intervals = new Float64Array(2 * I.length + 2);\n      for (const i of I) {\n        const ri = radius(i);\n        const y0 = ky ? ri + padding : 0; // offset baseline for varying radius\n        const l = X[i] - ri;\n        const h = X[i] + ri;\n\n        // The first two positions are 0 to test placing the dot on the baseline.\n        let k = 2;\n\n        // For any previously placed circles that may overlap this circle, compute\n        // the y-positions that place this circle tangent to these other circles.\n        // https://observablehq.com/@mbostock/circle-offset-along-line\n        tree.queryInterval(l - padding, h + padding, ([,, j]) => {\n          const yj = Y[j] - y0;\n          const dx = X[i] - X[j];\n          const dr = padding + (R ? R[i] + R[j] : 2 * cr);\n          const dy = Math.sqrt(dr * dr - dx * dx);\n          intervals[k++] = yj - dy;\n          intervals[k++] = yj + dy;\n        });\n\n        // Find the best y-value where this circle can fit.\n        let candidates = intervals.slice(0, k);\n        if (ky) candidates = candidates.filter(y => y >= 0);\n        out: for (const y of candidates.sort(compare)) {\n          for (let j = 0; j < k; j += 2) {\n            if (intervals[j] + 1e-6 < y && y < intervals[j + 1] - 1e-6) {\n              continue out;\n            }\n          }\n          Y[i] = y + y0;\n          break;\n        }\n\n        // Insert the placed circle into the interval tree.\n        tree.insert([l, h, i]);\n      }\n    }\n    if (!ky) ky = 1;\n    for (const I of facets) {\n      for (const i of I) {\n        Y[i] = Y[i] * ky + ty;\n      }\n    }\n    return {\n      data,\n      facets,\n      channels: {\n        [y]: {\n          value: Y,\n          source: null\n        },\n        // don’t show in tooltip\n        [x]: {\n          value: X,\n          source: channels[x]\n        },\n        ...(R && {\n          r: {\n            value: R,\n            source: channels.r\n          }\n        })\n      }\n    };\n  });\n}\nfunction compareSymmetric(a, b) {\n  return Math.abs(a) - Math.abs(b);\n}\nfunction compareAscending(a, b) {\n  return a - b;\n}","map":{"version":3,"names":["IntervalTree","finite","positive","identity","maybeNamed","number","valueof","initializer","applyPosition","anchorXLeft","marginLeft","anchorXRight","width","marginRight","anchorXMiddle","anchorYTop","marginTop","anchorYBottom","height","marginBottom","anchorYMiddle","maybeAnchor","anchor","dodgeX","dodgeOptions","options","arguments","length","mergeOptions","padding","r","toLowerCase","Error","dodge","dodgeY","rest","y","x","channels","sort","reverse","undefined","value","scale","channel","data","facets","scales","dimensions","context","X","R","cr","Float64Array","ky","ty","compare","compareAscending","compareSymmetric","Y","radius","i","I","tree","filter","intervals","ri","y0","l","h","k","queryInterval","j","yj","dx","dr","dy","Math","sqrt","candidates","slice","out","insert","source","a","b","abs"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/transforms/dodge.js"],"sourcesContent":["import IntervalTree from \"interval-tree-1d\";\nimport {finite, positive} from \"../defined.js\";\nimport {identity, maybeNamed, number, valueof} from \"../options.js\";\nimport {initializer} from \"./basic.js\";\nimport {applyPosition} from \"../projection.js\";\n\nconst anchorXLeft = ({marginLeft}) => [1, marginLeft];\nconst anchorXRight = ({width, marginRight}) => [-1, width - marginRight];\nconst anchorXMiddle = ({width, marginLeft, marginRight}) => [0, (marginLeft + width - marginRight) / 2];\nconst anchorYTop = ({marginTop}) => [1, marginTop];\nconst anchorYBottom = ({height, marginBottom}) => [-1, height - marginBottom];\nconst anchorYMiddle = ({height, marginTop, marginBottom}) => [0, (marginTop + height - marginBottom) / 2];\n\nfunction maybeAnchor(anchor) {\n  return typeof anchor === \"string\" ? {anchor} : anchor;\n}\n\nexport function dodgeX(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions(dodgeOptions);\n  let {anchor = \"left\", padding = 1, r = options.r} = maybeAnchor(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"left\":\n      anchor = anchorXLeft;\n      break;\n    case \"right\":\n      anchor = anchorXRight;\n      break;\n    case \"middle\":\n      anchor = anchorXMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"x\", \"y\", anchor, number(padding), r, options);\n}\n\nexport function dodgeY(dodgeOptions = {}, options = {}) {\n  if (arguments.length === 1) [dodgeOptions, options] = mergeOptions(dodgeOptions);\n  let {anchor = \"bottom\", padding = 1, r = options.r} = maybeAnchor(dodgeOptions);\n  switch (`${anchor}`.toLowerCase()) {\n    case \"top\":\n      anchor = anchorYTop;\n      break;\n    case \"bottom\":\n      anchor = anchorYBottom;\n      break;\n    case \"middle\":\n      anchor = anchorYMiddle;\n      break;\n    default:\n      throw new Error(`unknown dodge anchor: ${anchor}`);\n  }\n  return dodge(\"y\", \"x\", anchor, number(padding), r, options);\n}\n\nfunction mergeOptions(options) {\n  const {anchor, padding, ...rest} = options;\n  const {r} = rest; // don’t consume r; allow it to propagate\n  return [{anchor, padding, r}, rest];\n}\n\nfunction dodge(y, x, anchor, padding, r, options) {\n  if (r != null && typeof r !== \"number\") {\n    let {channels, sort, reverse} = options;\n    channels = maybeNamed(channels);\n    if (channels?.r === undefined) options = {...options, channels: {...channels, r: {value: r, scale: \"r\"}}};\n    if (sort === undefined && reverse === undefined) options.sort = {channel: \"-r\"};\n  }\n  return initializer(options, function (data, facets, channels, scales, dimensions, context) {\n    let {[x]: X, r: R} = channels;\n    if (!channels[x]) throw new Error(`missing channel: ${x}`);\n    ({[x]: X} = applyPosition(channels, scales, context));\n    const cr = R ? undefined : r !== undefined ? number(r) : this.r !== undefined ? this.r : 3;\n    if (R) R = valueof(R.value, scales[R.scale] || identity, Float64Array);\n    let [ky, ty] = anchor(dimensions);\n    const compare = ky ? compareAscending : compareSymmetric;\n    const Y = new Float64Array(X.length);\n    const radius = R ? (i) => R[i] : () => cr;\n    for (let I of facets) {\n      const tree = IntervalTree();\n      I = I.filter(R ? (i) => finite(X[i]) && positive(R[i]) : (i) => finite(X[i]));\n      const intervals = new Float64Array(2 * I.length + 2);\n      for (const i of I) {\n        const ri = radius(i);\n        const y0 = ky ? ri + padding : 0; // offset baseline for varying radius\n        const l = X[i] - ri;\n        const h = X[i] + ri;\n\n        // The first two positions are 0 to test placing the dot on the baseline.\n        let k = 2;\n\n        // For any previously placed circles that may overlap this circle, compute\n        // the y-positions that place this circle tangent to these other circles.\n        // https://observablehq.com/@mbostock/circle-offset-along-line\n        tree.queryInterval(l - padding, h + padding, ([, , j]) => {\n          const yj = Y[j] - y0;\n          const dx = X[i] - X[j];\n          const dr = padding + (R ? R[i] + R[j] : 2 * cr);\n          const dy = Math.sqrt(dr * dr - dx * dx);\n          intervals[k++] = yj - dy;\n          intervals[k++] = yj + dy;\n        });\n\n        // Find the best y-value where this circle can fit.\n        let candidates = intervals.slice(0, k);\n        if (ky) candidates = candidates.filter((y) => y >= 0);\n        out: for (const y of candidates.sort(compare)) {\n          for (let j = 0; j < k; j += 2) {\n            if (intervals[j] + 1e-6 < y && y < intervals[j + 1] - 1e-6) {\n              continue out;\n            }\n          }\n          Y[i] = y + y0;\n          break;\n        }\n\n        // Insert the placed circle into the interval tree.\n        tree.insert([l, h, i]);\n      }\n    }\n    if (!ky) ky = 1;\n    for (const I of facets) {\n      for (const i of I) {\n        Y[i] = Y[i] * ky + ty;\n      }\n    }\n    return {\n      data,\n      facets,\n      channels: {\n        [y]: {value: Y, source: null}, // don’t show in tooltip\n        [x]: {value: X, source: channels[x]},\n        ...(R && {r: {value: R, source: channels.r}})\n      }\n    };\n  });\n}\n\nfunction compareSymmetric(a, b) {\n  return Math.abs(a) - Math.abs(b);\n}\n\nfunction compareAscending(a, b) {\n  return a - b;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}