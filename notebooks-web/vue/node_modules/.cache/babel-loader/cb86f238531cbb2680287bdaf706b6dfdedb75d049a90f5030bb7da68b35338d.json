{"ast":null,"code":"import { InternSet, extent, quantize, reverse as reverseof, sort, symbolsFill, symbolsStroke } from \"d3\";\nimport { scaleBand, scaleOrdinal, scalePoint, scaleImplicit } from \"d3\";\nimport { ascendingDefined } from \"../defined.js\";\nimport { isNoneish, map, maybeRangeInterval } from \"../options.js\";\nimport { maybeSymbol } from \"../symbol.js\";\nimport { registry, color, position, symbol } from \"./index.js\";\nimport { maybeBooleanRange, ordinalScheme, quantitativeScheme } from \"./schemes.js\";\n\n// This denotes an implicitly ordinal color scale: the scale type was not set,\n// but the associated values are strings or booleans. If the associated defined\n// values are entirely boolean, the range will default to greys. You can opt out\n// of this by setting the type explicitly.\nexport const ordinalImplicit = Symbol(\"ordinal\");\nfunction createScaleO(key, scale, channels, {\n  type,\n  interval,\n  domain,\n  range,\n  reverse,\n  hint\n}) {\n  interval = maybeRangeInterval(interval, type);\n  if (domain === undefined) domain = inferDomain(channels, interval, key);\n  if (type === \"categorical\" || type === ordinalImplicit) type = \"ordinal\"; // shorthand for color schemes\n  if (reverse) domain = reverseof(domain);\n  domain = scale.domain(domain).domain(); // deduplicate\n  if (range !== undefined) {\n    // If the range is specified as a function, pass it the domain.\n    if (typeof range === \"function\") range = range(domain);\n    scale.range(range);\n  }\n  return {\n    type,\n    domain,\n    range,\n    scale,\n    hint,\n    interval\n  };\n}\nexport function createScaleOrdinal(key, channels, {\n  type,\n  interval,\n  domain,\n  range,\n  scheme,\n  unknown,\n  ...options\n}) {\n  interval = maybeRangeInterval(interval, type);\n  if (domain === undefined) domain = inferDomain(channels, interval, key);\n  let hint;\n  if (registry.get(key) === symbol) {\n    hint = inferSymbolHint(channels);\n    range = range === undefined ? inferSymbolRange(hint) : map(range, maybeSymbol);\n  } else if (registry.get(key) === color) {\n    if (range === undefined && (type === \"ordinal\" || type === ordinalImplicit)) {\n      range = maybeBooleanRange(domain, scheme);\n      if (range !== undefined) scheme = undefined; // Don’t re-apply scheme.\n    }\n\n    if (scheme === undefined && range === undefined) {\n      scheme = type === \"ordinal\" ? \"turbo\" : \"observable10\";\n    }\n    if (scheme !== undefined) {\n      if (range !== undefined) {\n        const interpolate = quantitativeScheme(scheme);\n        const t0 = range[0],\n          d = range[1] - range[0];\n        range = ({\n          length: n\n        }) => quantize(t => interpolate(t0 + d * t), n);\n      } else {\n        range = ordinalScheme(scheme);\n      }\n    }\n  }\n  if (unknown === scaleImplicit) {\n    throw new Error(`implicit unknown on ${key} scale is not supported`);\n  }\n  return createScaleO(key, scaleOrdinal().unknown(unknown), channels, {\n    ...options,\n    type,\n    domain,\n    range,\n    hint\n  });\n}\nexport function createScalePoint(key, channels, {\n  align = 0.5,\n  padding = 0.5,\n  ...options\n}) {\n  return maybeRound(scalePoint().align(align).padding(padding), channels, options, key);\n}\nexport function createScaleBand(key, channels, {\n  align = 0.5,\n  padding = 0.1,\n  paddingInner = padding,\n  paddingOuter = key === \"fx\" || key === \"fy\" ? 0 : padding,\n  ...options\n}) {\n  return maybeRound(scaleBand().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter), channels, options, key);\n}\nfunction maybeRound(scale, channels, options, key) {\n  let {\n    round\n  } = options;\n  if (round !== undefined) scale.round(round = !!round);\n  scale = createScaleO(key, scale, channels, options);\n  scale.round = round; // preserve for autoScaleRound\n  return scale;\n}\nfunction inferDomain(channels, interval, key) {\n  const values = new InternSet();\n  for (const {\n    value,\n    domain\n  } of channels) {\n    if (domain !== undefined) return domain(); // see channelDomain\n    if (value === undefined) continue;\n    for (const v of value) values.add(v);\n  }\n  if (interval !== undefined) {\n    const [min, max] = extent(values).map(interval.floor, interval);\n    return interval.range(min, interval.offset(max));\n  }\n  if (values.size > 10e3 && registry.get(key) === position) {\n    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);\n  }\n  return sort(values, ascendingDefined);\n}\n\n// If all channels provide a consistent hint, propagate it to the scale.\nfunction inferHint(channels, key) {\n  let value;\n  for (const {\n    hint\n  } of channels) {\n    const candidate = hint?.[key];\n    if (candidate === undefined) continue; // no hint here\n    if (value === undefined) value = candidate; // first hint\n    else if (value !== candidate) return; // inconsistent hint\n  }\n\n  return value;\n}\nfunction inferSymbolHint(channels) {\n  return {\n    fill: inferHint(channels, \"fill\"),\n    stroke: inferHint(channels, \"stroke\")\n  };\n}\nfunction inferSymbolRange(hint) {\n  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;\n}","map":{"version":3,"names":["InternSet","extent","quantize","reverse","reverseof","sort","symbolsFill","symbolsStroke","scaleBand","scaleOrdinal","scalePoint","scaleImplicit","ascendingDefined","isNoneish","map","maybeRangeInterval","maybeSymbol","registry","color","position","symbol","maybeBooleanRange","ordinalScheme","quantitativeScheme","ordinalImplicit","Symbol","createScaleO","key","scale","channels","type","interval","domain","range","hint","undefined","inferDomain","createScaleOrdinal","scheme","unknown","options","get","inferSymbolHint","inferSymbolRange","interpolate","t0","d","length","n","t","Error","createScalePoint","align","padding","maybeRound","createScaleBand","paddingInner","paddingOuter","round","values","value","v","add","min","max","floor","offset","size","inferHint","candidate","fill","stroke"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/scales/ordinal.js"],"sourcesContent":["import {InternSet, extent, quantize, reverse as reverseof, sort, symbolsFill, symbolsStroke} from \"d3\";\nimport {scaleBand, scaleOrdinal, scalePoint, scaleImplicit} from \"d3\";\nimport {ascendingDefined} from \"../defined.js\";\nimport {isNoneish, map, maybeRangeInterval} from \"../options.js\";\nimport {maybeSymbol} from \"../symbol.js\";\nimport {registry, color, position, symbol} from \"./index.js\";\nimport {maybeBooleanRange, ordinalScheme, quantitativeScheme} from \"./schemes.js\";\n\n// This denotes an implicitly ordinal color scale: the scale type was not set,\n// but the associated values are strings or booleans. If the associated defined\n// values are entirely boolean, the range will default to greys. You can opt out\n// of this by setting the type explicitly.\nexport const ordinalImplicit = Symbol(\"ordinal\");\n\nfunction createScaleO(key, scale, channels, {type, interval, domain, range, reverse, hint}) {\n  interval = maybeRangeInterval(interval, type);\n  if (domain === undefined) domain = inferDomain(channels, interval, key);\n  if (type === \"categorical\" || type === ordinalImplicit) type = \"ordinal\"; // shorthand for color schemes\n  if (reverse) domain = reverseof(domain);\n  domain = scale.domain(domain).domain(); // deduplicate\n  if (range !== undefined) {\n    // If the range is specified as a function, pass it the domain.\n    if (typeof range === \"function\") range = range(domain);\n    scale.range(range);\n  }\n  return {type, domain, range, scale, hint, interval};\n}\n\nexport function createScaleOrdinal(key, channels, {type, interval, domain, range, scheme, unknown, ...options}) {\n  interval = maybeRangeInterval(interval, type);\n  if (domain === undefined) domain = inferDomain(channels, interval, key);\n  let hint;\n  if (registry.get(key) === symbol) {\n    hint = inferSymbolHint(channels);\n    range = range === undefined ? inferSymbolRange(hint) : map(range, maybeSymbol);\n  } else if (registry.get(key) === color) {\n    if (range === undefined && (type === \"ordinal\" || type === ordinalImplicit)) {\n      range = maybeBooleanRange(domain, scheme);\n      if (range !== undefined) scheme = undefined; // Don’t re-apply scheme.\n    }\n    if (scheme === undefined && range === undefined) {\n      scheme = type === \"ordinal\" ? \"turbo\" : \"observable10\";\n    }\n    if (scheme !== undefined) {\n      if (range !== undefined) {\n        const interpolate = quantitativeScheme(scheme);\n        const t0 = range[0],\n          d = range[1] - range[0];\n        range = ({length: n}) => quantize((t) => interpolate(t0 + d * t), n);\n      } else {\n        range = ordinalScheme(scheme);\n      }\n    }\n  }\n  if (unknown === scaleImplicit) {\n    throw new Error(`implicit unknown on ${key} scale is not supported`);\n  }\n  return createScaleO(key, scaleOrdinal().unknown(unknown), channels, {...options, type, domain, range, hint});\n}\n\nexport function createScalePoint(key, channels, {align = 0.5, padding = 0.5, ...options}) {\n  return maybeRound(scalePoint().align(align).padding(padding), channels, options, key);\n}\n\nexport function createScaleBand(\n  key,\n  channels,\n  {\n    align = 0.5,\n    padding = 0.1,\n    paddingInner = padding,\n    paddingOuter = key === \"fx\" || key === \"fy\" ? 0 : padding,\n    ...options\n  }\n) {\n  return maybeRound(\n    scaleBand().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),\n    channels,\n    options,\n    key\n  );\n}\n\nfunction maybeRound(scale, channels, options, key) {\n  let {round} = options;\n  if (round !== undefined) scale.round((round = !!round));\n  scale = createScaleO(key, scale, channels, options);\n  scale.round = round; // preserve for autoScaleRound\n  return scale;\n}\n\nfunction inferDomain(channels, interval, key) {\n  const values = new InternSet();\n  for (const {value, domain} of channels) {\n    if (domain !== undefined) return domain(); // see channelDomain\n    if (value === undefined) continue;\n    for (const v of value) values.add(v);\n  }\n  if (interval !== undefined) {\n    const [min, max] = extent(values).map(interval.floor, interval);\n    return interval.range(min, interval.offset(max));\n  }\n  if (values.size > 10e3 && registry.get(key) === position) {\n    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);\n  }\n  return sort(values, ascendingDefined);\n}\n\n// If all channels provide a consistent hint, propagate it to the scale.\nfunction inferHint(channels, key) {\n  let value;\n  for (const {hint} of channels) {\n    const candidate = hint?.[key];\n    if (candidate === undefined) continue; // no hint here\n    if (value === undefined) value = candidate; // first hint\n    else if (value !== candidate) return; // inconsistent hint\n  }\n  return value;\n}\n\nfunction inferSymbolHint(channels) {\n  return {\n    fill: inferHint(channels, \"fill\"),\n    stroke: inferHint(channels, \"stroke\")\n  };\n}\n\nfunction inferSymbolRange(hint) {\n  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}