{"ast":null,"code":"import { ascending, InternSet } from \"d3\";\nimport { marks } from \"../mark.js\";\nimport { isColor, isNumeric, isObject, isOptions, isOrdinal, labelof, valueof } from \"../options.js\";\nimport { bin, binX, binY } from \"../transforms/bin.js\";\nimport { group, groupX, groupY } from \"../transforms/group.js\";\nimport { areaX, areaY } from \"./area.js\";\nimport { barX, barY } from \"./bar.js\";\nimport { cell } from \"./cell.js\";\nimport { dot } from \"./dot.js\";\nimport { frame } from \"./frame.js\";\nimport { line, lineX, lineY } from \"./line.js\";\nimport { rect, rectX, rectY } from \"./rect.js\";\nimport { ruleX, ruleY } from \"./rule.js\";\nexport function autoSpec(data, options) {\n  options = normalizeOptions(options);\n\n  // Greedily materialize columns for type inference; we’ll need them anyway to\n  // plot! Note that we don’t apply any type inference to the fx and fy\n  // channels, if present; these are always ordinal (at least for now).\n  const {\n    x,\n    y,\n    color,\n    size\n  } = options;\n  const X = materializeValue(data, x);\n  const Y = materializeValue(data, y);\n  const C = materializeValue(data, color);\n  const S = materializeValue(data, size);\n\n  // Compute the default options.\n  let {\n    fx,\n    fy,\n    x: {\n      value: xValue,\n      reduce: xReduce,\n      zero: xZero,\n      ...xOptions\n    },\n    y: {\n      value: yValue,\n      reduce: yReduce,\n      zero: yZero,\n      ...yOptions\n    },\n    color: {\n      value: colorValue,\n      color: colorColor,\n      reduce: colorReduce\n    },\n    size: {\n      value: sizeValue,\n      reduce: sizeReduce\n    },\n    // TODO constant radius?\n    mark\n  } = options;\n\n  // Determine the default reducer, if any.\n  if (xReduce === undefined) xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? \"count\" : null;\n  if (yReduce === undefined) yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? \"count\" : null;\n\n  // Determine the default size reducer, if any.\n  if (sizeReduce === undefined && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X)) && (yValue == null || isOrdinal(Y))) {\n    sizeReduce = \"count\";\n  }\n\n  // Determine the default zero-ness.\n  if (xZero === undefined) xZero = isZeroReducer(xReduce) ? true : undefined;\n  if (yZero === undefined) yZero = isZeroReducer(yReduce) ? true : undefined;\n\n  // TODO Shorthand: array of primitives should result in a histogram\n  if (xValue == null && yValue == null) throw new Error(\"must specify x or y\");\n  if (xReduce != null && yValue == null) throw new Error(\"reducing x requires y\");\n  if (yReduce != null && xValue == null) throw new Error(\"reducing y requires x\");\n\n  // Determine the default mark type.\n  if (mark === undefined) {\n    mark = sizeValue != null || sizeReduce != null ? \"dot\" : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null // histogram or heatmap\n    ? \"bar\" : xValue != null && yValue != null ? isOrdinal(X) || isOrdinal(Y) || xReduce == null && yReduce == null && !isMonotonic(X) && !isMonotonic(Y) ? \"dot\" : \"line\" : xValue != null || yValue != null ? \"rule\" : null;\n  }\n  let Z; // may be set to null to disable series-by-color for line and area\n  let colorMode; // \"fill\" or \"stroke\"\n\n  // Determine the mark implementation.\n  let markImpl;\n  switch (mark) {\n    case \"dot\":\n      markImpl = dot;\n      colorMode = \"stroke\";\n      break;\n    case \"line\":\n      markImpl = X && Y || xReduce != null || yReduce != null // same logic as area (see below), but default to line\n      ? yZero || yReduce != null || X && isMonotonic(X) ? lineY : xZero || xReduce != null || Y && isMonotonic(Y) ? lineX : line : X // 1d line by index\n      ? lineX : lineY;\n      colorMode = \"stroke\";\n      if (isHighCardinality(C)) Z = null; // TODO only if z not set by user\n      break;\n    case \"area\":\n      markImpl = !(yZero || yReduce != null) && (xZero || xReduce != null || Y && isMonotonic(Y)) ? areaX : areaY; // favor areaY if unsure\n      colorMode = \"fill\";\n      if (isHighCardinality(C)) Z = null; // TODO only if z not set by user\n      break;\n    case \"rule\":\n      markImpl = X ? ruleX : ruleY;\n      colorMode = \"stroke\";\n      break;\n    case \"bar\":\n      markImpl = xReduce != null // bin or group on y\n      ? isOrdinal(Y) ? isSelectReducer(xReduce) && X && isOrdinal(X) ? cell : barX : rectX : yReduce != null // bin or group on x\n      ? isOrdinal(X) ? isSelectReducer(yReduce) && Y && isOrdinal(Y) ? cell : barY : rectY : colorReduce != null || sizeReduce != null // bin or group on both x and y\n      ? X && isOrdinal(X) && Y && isOrdinal(Y) ? cell : X && isOrdinal(X) ? barY : Y && isOrdinal(Y) ? barX : rect : X && isNumeric(X) && !(Y && isNumeric(Y)) ? barX // if y is temporal, treat as ordinal\n      : Y && isNumeric(Y) && !(X && isNumeric(X)) ? barY // if x is temporal, treat as ordinal\n      : cell;\n      colorMode = \"fill\";\n      break;\n    default:\n      throw new Error(`invalid mark: ${mark}`);\n  }\n\n  // Determine the mark options.\n  let markOptions = {\n    fx,\n    fy,\n    x: X ?? undefined,\n    // treat null x as undefined for implicit stack\n    y: Y ?? undefined,\n    // treat null y as undefined for implicit stack\n    [colorMode]: C ?? colorColor,\n    z: Z,\n    r: S ?? undefined,\n    // treat null size as undefined for default constant radius\n    tip: true\n  };\n  let transformImpl;\n  let transformOptions = {\n    [colorMode]: colorReduce ?? undefined,\n    r: sizeReduce ?? undefined\n  };\n  if (xReduce != null && yReduce != null) {\n    throw new Error(`cannot reduce both x and y`); // for now at least\n  } else if (yReduce != null) {\n    transformOptions.y = yReduce;\n    transformImpl = isOrdinal(X) ? groupX : binX;\n  } else if (xReduce != null) {\n    transformOptions.x = xReduce;\n    transformImpl = isOrdinal(Y) ? groupY : binY;\n  } else if (colorReduce != null || sizeReduce != null) {\n    if (X && Y) {\n      transformImpl = isOrdinal(X) && isOrdinal(Y) ? group : isOrdinal(X) ? binY : isOrdinal(Y) ? binX : bin;\n    } else if (X) {\n      transformImpl = isOrdinal(X) ? groupX : binX;\n    } else if (Y) {\n      transformImpl = isOrdinal(Y) ? groupY : binY;\n    }\n  }\n\n  // When using the bin transform, pass through additional options (e.g., thresholds).\n  if (transformImpl === bin || transformImpl === binX) markOptions.x = {\n    value: X,\n    ...xOptions\n  };\n  if (transformImpl === bin || transformImpl === binY) markOptions.y = {\n    value: Y,\n    ...yOptions\n  };\n\n  // If zero-ness is not specified, default based on whether the resolved mark\n  // type will include a zero baseline.\n  if (xZero === undefined) xZero = X && !(transformImpl === bin || transformImpl === binX) && (markImpl === barX || markImpl === areaX || markImpl === rectX || markImpl === ruleY);\n  if (yZero === undefined) yZero = Y && !(transformImpl === bin || transformImpl === binY) && (markImpl === barY || markImpl === areaY || markImpl === rectY || markImpl === ruleX);\n  return {\n    fx: fx ?? null,\n    fy: fy ?? null,\n    x: {\n      value: xValue ?? null,\n      reduce: xReduce ?? null,\n      zero: !!xZero,\n      ...xOptions\n    },\n    y: {\n      value: yValue ?? null,\n      reduce: yReduce ?? null,\n      zero: !!yZero,\n      ...yOptions\n    },\n    color: {\n      value: colorValue ?? null,\n      reduce: colorReduce ?? null,\n      ...(colorColor !== undefined && {\n        color: colorColor\n      })\n    },\n    size: {\n      value: sizeValue ?? null,\n      reduce: sizeReduce ?? null\n    },\n    mark,\n    markImpl: implNames[markImpl],\n    markOptions,\n    transformImpl: implNames[transformImpl],\n    transformOptions,\n    colorMode\n  };\n}\nexport function auto(data, options) {\n  const spec = autoSpec(data, options);\n  const {\n    fx,\n    fy,\n    x: {\n      zero: xZero\n    },\n    y: {\n      zero: yZero\n    },\n    markOptions,\n    transformOptions,\n    colorMode\n  } = spec;\n  const markImpl = impls[spec.markImpl];\n  const transformImpl = impls[spec.transformImpl];\n  // In the case of filled marks (particularly bars and areas) the frame and\n  // rules should come after the mark; in the case of stroked marks\n  // (particularly dots and lines) they should come before the mark.\n  const frames = fx != null || fy != null ? frame({\n    strokeOpacity: 0.1\n  }) : null;\n  const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];\n  const mark = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions) : markOptions);\n  return colorMode === \"stroke\" ? marks(frames, rules, mark) : marks(frames, mark, rules);\n}\n\n// TODO What about sorted within series?\nfunction isMonotonic(values) {\n  let previous;\n  let previousOrder;\n  for (const value of values) {\n    if (value == null) continue;\n    if (previous === undefined) {\n      previous = value;\n      continue;\n    }\n    const order = Math.sign(ascending(previous, value));\n    if (!order) continue; // skip zero, NaN\n    if (previousOrder !== undefined && order !== previousOrder) return false;\n    previous = value;\n    previousOrder = order;\n  }\n  return true;\n}\n\n// Allow x and y and other dimensions to be specified as shorthand field names\n// (but note that they can also be specified as a {transform} object such as\n// Plot.identity). We don’t support reducers for the faceting, but for symmetry\n// with x and y we allow facets to be specified as {value} objects.\nfunction normalizeOptions({\n  x,\n  y,\n  color,\n  size,\n  fx,\n  fy,\n  mark\n} = {}) {\n  if (!isOptions(x)) x = makeOptions(x);\n  if (!isOptions(y)) y = makeOptions(y);\n  if (!isOptions(color)) color = isColor(color) ? {\n    color\n  } : makeOptions(color);\n  if (!isOptions(size)) size = makeOptions(size);\n  if (isOptions(fx)) ({\n    value: fx\n  } = makeOptions(fx));\n  if (isOptions(fy)) ({\n    value: fy\n  } = makeOptions(fy));\n  if (mark != null) mark = `${mark}`.toLowerCase();\n  return {\n    x,\n    y,\n    color,\n    size,\n    fx,\n    fy,\n    mark\n  };\n}\n\n// To apply heuristics based on the data types (values), realize the columns. We\n// could maybe look at the data.schema here, but Plot’s behavior depends on the\n// actual values anyway, so this probably is what we want.\nfunction materializeValue(data, options) {\n  const V = valueof(data, options.value);\n  if (V) V.label = labelof(options.value);\n  return V;\n}\nfunction makeOptions(value) {\n  return isReducer(value) ? {\n    reduce: value\n  } : {\n    value\n  };\n}\n\n// The distinct, count, sum, and proportion reducers are additive (stackable).\nfunction isZeroReducer(reduce) {\n  return /^(?:distinct|count|sum|proportion)$/i.test(reduce);\n}\n\n// The first, last, and mode reducers preserve the type of the aggregated values.\nfunction isSelectReducer(reduce) {\n  return /^(?:first|last|mode)$/i.test(reduce);\n}\n\n// https://github.com/observablehq/plot/blob/818562649280e155136f730fc496e0b3d15ae464/src/transforms/group.js#L236\nfunction isReducer(reduce) {\n  if (reduce == null) return false;\n  if (typeof reduce.reduceIndex === \"function\") return true;\n  if (typeof reduce.reduce === \"function\" && isObject(reduce)) return true; // N.B. array.reduce\n  if (/^p\\d{2}$/i.test(reduce)) return true;\n  switch (`${reduce}`.toLowerCase()) {\n    case \"first\":\n    case \"last\":\n    case \"count\":\n    case \"distinct\":\n    case \"sum\":\n    case \"proportion\":\n    case \"proportion-facet\": // TODO remove me?\n    case \"deviation\":\n    case \"min\":\n    case \"min-index\": // TODO remove me?\n    case \"max\":\n    case \"max-index\": // TODO remove me?\n    case \"mean\":\n    case \"median\":\n    case \"variance\":\n    case \"mode\":\n      // These are technically reducers, but I think we’d want to treat them as fields?\n      // case \"x\":\n      // case \"x1\":\n      // case \"x2\":\n      // case \"y\":\n      // case \"y1\":\n      // case \"y2\":\n      return true;\n  }\n  return false;\n}\nfunction isHighCardinality(value) {\n  return value ? new InternSet(value).size > value.length >> 1 : false;\n}\nconst impls = {\n  dot,\n  line,\n  lineX,\n  lineY,\n  areaX,\n  areaY,\n  ruleX,\n  ruleY,\n  barX,\n  barY,\n  rect,\n  rectX,\n  rectY,\n  cell,\n  bin,\n  binX,\n  binY,\n  group,\n  groupX,\n  groupY\n};\n\n// Instead of returning the mark or transform implementation directly, we return\n// the implementation name to facilitate code compilation (“eject to explicit\n// marks”). An implementation-to-name mapping needs to live somewhere for\n// compilation, and by having it in Plot we can more easily introduce a new mark\n// or transform implementation in Plot.auto without having to synchronize a\n// downstream change in the compiler.\nconst implNames = Object.fromEntries(Object.entries(impls).map(([name, impl]) => [impl, name]));","map":{"version":3,"names":["ascending","InternSet","marks","isColor","isNumeric","isObject","isOptions","isOrdinal","labelof","valueof","bin","binX","binY","group","groupX","groupY","areaX","areaY","barX","barY","cell","dot","frame","line","lineX","lineY","rect","rectX","rectY","ruleX","ruleY","autoSpec","data","options","normalizeOptions","x","y","color","size","X","materializeValue","Y","C","S","fx","fy","value","xValue","reduce","xReduce","zero","xZero","xOptions","yValue","yReduce","yZero","yOptions","colorValue","colorColor","colorReduce","sizeValue","sizeReduce","mark","undefined","isZeroReducer","Error","isMonotonic","Z","colorMode","markImpl","isHighCardinality","isSelectReducer","markOptions","z","r","tip","transformImpl","transformOptions","implNames","auto","spec","impls","frames","strokeOpacity","rules","values","previous","previousOrder","order","Math","sign","makeOptions","toLowerCase","V","label","isReducer","test","reduceIndex","length","Object","fromEntries","entries","map","name","impl"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/auto.js"],"sourcesContent":["import {ascending, InternSet} from \"d3\";\nimport {marks} from \"../mark.js\";\nimport {isColor, isNumeric, isObject, isOptions, isOrdinal, labelof, valueof} from \"../options.js\";\nimport {bin, binX, binY} from \"../transforms/bin.js\";\nimport {group, groupX, groupY} from \"../transforms/group.js\";\nimport {areaX, areaY} from \"./area.js\";\nimport {barX, barY} from \"./bar.js\";\nimport {cell} from \"./cell.js\";\nimport {dot} from \"./dot.js\";\nimport {frame} from \"./frame.js\";\nimport {line, lineX, lineY} from \"./line.js\";\nimport {rect, rectX, rectY} from \"./rect.js\";\nimport {ruleX, ruleY} from \"./rule.js\";\n\nexport function autoSpec(data, options) {\n  options = normalizeOptions(options);\n\n  // Greedily materialize columns for type inference; we’ll need them anyway to\n  // plot! Note that we don’t apply any type inference to the fx and fy\n  // channels, if present; these are always ordinal (at least for now).\n  const {x, y, color, size} = options;\n  const X = materializeValue(data, x);\n  const Y = materializeValue(data, y);\n  const C = materializeValue(data, color);\n  const S = materializeValue(data, size);\n\n  // Compute the default options.\n  let {\n    fx,\n    fy,\n    x: {value: xValue, reduce: xReduce, zero: xZero, ...xOptions},\n    y: {value: yValue, reduce: yReduce, zero: yZero, ...yOptions},\n    color: {value: colorValue, color: colorColor, reduce: colorReduce},\n    size: {value: sizeValue, reduce: sizeReduce}, // TODO constant radius?\n    mark\n  } = options;\n\n  // Determine the default reducer, if any.\n  if (xReduce === undefined)\n    xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? \"count\" : null;\n  if (yReduce === undefined)\n    yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? \"count\" : null;\n\n  // Determine the default size reducer, if any.\n  if (\n    sizeReduce === undefined &&\n    sizeValue == null &&\n    colorReduce == null &&\n    xReduce == null &&\n    yReduce == null &&\n    (xValue == null || isOrdinal(X)) &&\n    (yValue == null || isOrdinal(Y))\n  ) {\n    sizeReduce = \"count\";\n  }\n\n  // Determine the default zero-ness.\n  if (xZero === undefined) xZero = isZeroReducer(xReduce) ? true : undefined;\n  if (yZero === undefined) yZero = isZeroReducer(yReduce) ? true : undefined;\n\n  // TODO Shorthand: array of primitives should result in a histogram\n  if (xValue == null && yValue == null) throw new Error(\"must specify x or y\");\n  if (xReduce != null && yValue == null) throw new Error(\"reducing x requires y\");\n  if (yReduce != null && xValue == null) throw new Error(\"reducing y requires x\");\n\n  // Determine the default mark type.\n  if (mark === undefined) {\n    mark =\n      sizeValue != null || sizeReduce != null\n        ? \"dot\"\n        : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null // histogram or heatmap\n        ? \"bar\"\n        : xValue != null && yValue != null\n        ? isOrdinal(X) || isOrdinal(Y) || (xReduce == null && yReduce == null && !isMonotonic(X) && !isMonotonic(Y))\n          ? \"dot\"\n          : \"line\"\n        : xValue != null || yValue != null\n        ? \"rule\"\n        : null;\n  }\n\n  let Z; // may be set to null to disable series-by-color for line and area\n  let colorMode; // \"fill\" or \"stroke\"\n\n  // Determine the mark implementation.\n  let markImpl;\n  switch (mark) {\n    case \"dot\":\n      markImpl = dot;\n      colorMode = \"stroke\";\n      break;\n    case \"line\":\n      markImpl =\n        (X && Y) || xReduce != null || yReduce != null // same logic as area (see below), but default to line\n          ? yZero || yReduce != null || (X && isMonotonic(X))\n            ? lineY\n            : xZero || xReduce != null || (Y && isMonotonic(Y))\n            ? lineX\n            : line\n          : X // 1d line by index\n          ? lineX\n          : lineY;\n      colorMode = \"stroke\";\n      if (isHighCardinality(C)) Z = null; // TODO only if z not set by user\n      break;\n    case \"area\":\n      markImpl = !(yZero || yReduce != null) && (xZero || xReduce != null || (Y && isMonotonic(Y))) ? areaX : areaY; // favor areaY if unsure\n      colorMode = \"fill\";\n      if (isHighCardinality(C)) Z = null; // TODO only if z not set by user\n      break;\n    case \"rule\":\n      markImpl = X ? ruleX : ruleY;\n      colorMode = \"stroke\";\n      break;\n    case \"bar\":\n      markImpl =\n        xReduce != null // bin or group on y\n          ? isOrdinal(Y)\n            ? isSelectReducer(xReduce) && X && isOrdinal(X)\n              ? cell\n              : barX\n            : rectX\n          : yReduce != null // bin or group on x\n          ? isOrdinal(X)\n            ? isSelectReducer(yReduce) && Y && isOrdinal(Y)\n              ? cell\n              : barY\n            : rectY\n          : colorReduce != null || sizeReduce != null // bin or group on both x and y\n          ? X && isOrdinal(X) && Y && isOrdinal(Y)\n            ? cell\n            : X && isOrdinal(X)\n            ? barY\n            : Y && isOrdinal(Y)\n            ? barX\n            : rect\n          : X && isNumeric(X) && !(Y && isNumeric(Y))\n          ? barX // if y is temporal, treat as ordinal\n          : Y && isNumeric(Y) && !(X && isNumeric(X))\n          ? barY // if x is temporal, treat as ordinal\n          : cell;\n      colorMode = \"fill\";\n      break;\n    default:\n      throw new Error(`invalid mark: ${mark}`);\n  }\n\n  // Determine the mark options.\n  let markOptions = {\n    fx,\n    fy,\n    x: X ?? undefined, // treat null x as undefined for implicit stack\n    y: Y ?? undefined, // treat null y as undefined for implicit stack\n    [colorMode]: C ?? colorColor,\n    z: Z,\n    r: S ?? undefined, // treat null size as undefined for default constant radius\n    tip: true\n  };\n  let transformImpl;\n  let transformOptions = {[colorMode]: colorReduce ?? undefined, r: sizeReduce ?? undefined};\n  if (xReduce != null && yReduce != null) {\n    throw new Error(`cannot reduce both x and y`); // for now at least\n  } else if (yReduce != null) {\n    transformOptions.y = yReduce;\n    transformImpl = isOrdinal(X) ? groupX : binX;\n  } else if (xReduce != null) {\n    transformOptions.x = xReduce;\n    transformImpl = isOrdinal(Y) ? groupY : binY;\n  } else if (colorReduce != null || sizeReduce != null) {\n    if (X && Y) {\n      transformImpl = isOrdinal(X) && isOrdinal(Y) ? group : isOrdinal(X) ? binY : isOrdinal(Y) ? binX : bin;\n    } else if (X) {\n      transformImpl = isOrdinal(X) ? groupX : binX;\n    } else if (Y) {\n      transformImpl = isOrdinal(Y) ? groupY : binY;\n    }\n  }\n\n  // When using the bin transform, pass through additional options (e.g., thresholds).\n  if (transformImpl === bin || transformImpl === binX) markOptions.x = {value: X, ...xOptions};\n  if (transformImpl === bin || transformImpl === binY) markOptions.y = {value: Y, ...yOptions};\n\n  // If zero-ness is not specified, default based on whether the resolved mark\n  // type will include a zero baseline.\n  if (xZero === undefined)\n    xZero =\n      X &&\n      !(transformImpl === bin || transformImpl === binX) &&\n      (markImpl === barX || markImpl === areaX || markImpl === rectX || markImpl === ruleY);\n  if (yZero === undefined)\n    yZero =\n      Y &&\n      !(transformImpl === bin || transformImpl === binY) &&\n      (markImpl === barY || markImpl === areaY || markImpl === rectY || markImpl === ruleX);\n\n  return {\n    fx: fx ?? null,\n    fy: fy ?? null,\n    x: {\n      value: xValue ?? null,\n      reduce: xReduce ?? null,\n      zero: !!xZero,\n      ...xOptions\n    },\n    y: {\n      value: yValue ?? null,\n      reduce: yReduce ?? null,\n      zero: !!yZero,\n      ...yOptions\n    },\n    color: {\n      value: colorValue ?? null,\n      reduce: colorReduce ?? null,\n      ...(colorColor !== undefined && {color: colorColor})\n    },\n    size: {\n      value: sizeValue ?? null,\n      reduce: sizeReduce ?? null\n    },\n    mark,\n    markImpl: implNames[markImpl],\n    markOptions,\n    transformImpl: implNames[transformImpl],\n    transformOptions,\n    colorMode\n  };\n}\n\nexport function auto(data, options) {\n  const spec = autoSpec(data, options);\n  const {\n    fx,\n    fy,\n    x: {zero: xZero},\n    y: {zero: yZero},\n    markOptions,\n    transformOptions,\n    colorMode\n  } = spec;\n  const markImpl = impls[spec.markImpl];\n  const transformImpl = impls[spec.transformImpl];\n  // In the case of filled marks (particularly bars and areas) the frame and\n  // rules should come after the mark; in the case of stroked marks\n  // (particularly dots and lines) they should come before the mark.\n  const frames = fx != null || fy != null ? frame({strokeOpacity: 0.1}) : null;\n  const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];\n  const mark = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions) : markOptions);\n  return colorMode === \"stroke\" ? marks(frames, rules, mark) : marks(frames, mark, rules);\n}\n\n// TODO What about sorted within series?\nfunction isMonotonic(values) {\n  let previous;\n  let previousOrder;\n  for (const value of values) {\n    if (value == null) continue;\n    if (previous === undefined) {\n      previous = value;\n      continue;\n    }\n    const order = Math.sign(ascending(previous, value));\n    if (!order) continue; // skip zero, NaN\n    if (previousOrder !== undefined && order !== previousOrder) return false;\n    previous = value;\n    previousOrder = order;\n  }\n  return true;\n}\n\n// Allow x and y and other dimensions to be specified as shorthand field names\n// (but note that they can also be specified as a {transform} object such as\n// Plot.identity). We don’t support reducers for the faceting, but for symmetry\n// with x and y we allow facets to be specified as {value} objects.\nfunction normalizeOptions({x, y, color, size, fx, fy, mark} = {}) {\n  if (!isOptions(x)) x = makeOptions(x);\n  if (!isOptions(y)) y = makeOptions(y);\n  if (!isOptions(color)) color = isColor(color) ? {color} : makeOptions(color);\n  if (!isOptions(size)) size = makeOptions(size);\n  if (isOptions(fx)) ({value: fx} = makeOptions(fx));\n  if (isOptions(fy)) ({value: fy} = makeOptions(fy));\n  if (mark != null) mark = `${mark}`.toLowerCase();\n  return {x, y, color, size, fx, fy, mark};\n}\n\n// To apply heuristics based on the data types (values), realize the columns. We\n// could maybe look at the data.schema here, but Plot’s behavior depends on the\n// actual values anyway, so this probably is what we want.\nfunction materializeValue(data, options) {\n  const V = valueof(data, options.value);\n  if (V) V.label = labelof(options.value);\n  return V;\n}\n\nfunction makeOptions(value) {\n  return isReducer(value) ? {reduce: value} : {value};\n}\n\n// The distinct, count, sum, and proportion reducers are additive (stackable).\nfunction isZeroReducer(reduce) {\n  return /^(?:distinct|count|sum|proportion)$/i.test(reduce);\n}\n\n// The first, last, and mode reducers preserve the type of the aggregated values.\nfunction isSelectReducer(reduce) {\n  return /^(?:first|last|mode)$/i.test(reduce);\n}\n\n// https://github.com/observablehq/plot/blob/818562649280e155136f730fc496e0b3d15ae464/src/transforms/group.js#L236\nfunction isReducer(reduce) {\n  if (reduce == null) return false;\n  if (typeof reduce.reduceIndex === \"function\") return true;\n  if (typeof reduce.reduce === \"function\" && isObject(reduce)) return true; // N.B. array.reduce\n  if (/^p\\d{2}$/i.test(reduce)) return true;\n  switch (`${reduce}`.toLowerCase()) {\n    case \"first\":\n    case \"last\":\n    case \"count\":\n    case \"distinct\":\n    case \"sum\":\n    case \"proportion\":\n    case \"proportion-facet\": // TODO remove me?\n    case \"deviation\":\n    case \"min\":\n    case \"min-index\": // TODO remove me?\n    case \"max\":\n    case \"max-index\": // TODO remove me?\n    case \"mean\":\n    case \"median\":\n    case \"variance\":\n    case \"mode\":\n      // These are technically reducers, but I think we’d want to treat them as fields?\n      // case \"x\":\n      // case \"x1\":\n      // case \"x2\":\n      // case \"y\":\n      // case \"y1\":\n      // case \"y2\":\n      return true;\n  }\n  return false;\n}\n\nfunction isHighCardinality(value) {\n  return value ? new InternSet(value).size > value.length >> 1 : false;\n}\n\nconst impls = {\n  dot,\n  line,\n  lineX,\n  lineY,\n  areaX,\n  areaY,\n  ruleX,\n  ruleY,\n  barX,\n  barY,\n  rect,\n  rectX,\n  rectY,\n  cell,\n  bin,\n  binX,\n  binY,\n  group,\n  groupX,\n  groupY\n};\n\n// Instead of returning the mark or transform implementation directly, we return\n// the implementation name to facilitate code compilation (“eject to explicit\n// marks”). An implementation-to-name mapping needs to live somewhere for\n// compilation, and by having it in Plot we can more easily introduce a new mark\n// or transform implementation in Plot.auto without having to synchronize a\n// downstream change in the compiler.\nconst implNames = Object.fromEntries(Object.entries(impls).map(([name, impl]) => [impl, name]));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}