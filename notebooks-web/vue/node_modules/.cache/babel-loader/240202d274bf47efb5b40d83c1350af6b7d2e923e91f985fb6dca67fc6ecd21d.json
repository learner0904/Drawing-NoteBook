{"ast":null,"code":"import { pathRound as path, symbolCircle } from \"d3\";\nimport { create } from \"../context.js\";\nimport { negative, positive } from \"../defined.js\";\nimport { Mark } from \"../mark.js\";\nimport { identity, maybeFrameAnchor, maybeNumberChannel, maybeTuple } from \"../options.js\";\nimport { applyChannelStyles, applyDirectStyles, applyFrameAnchor, applyIndirectStyles, applyTransform } from \"../style.js\";\nimport { maybeSymbolChannel } from \"../symbol.js\";\nimport { template } from \"../template.js\";\nimport { sort } from \"../transforms/basic.js\";\nimport { maybeIntervalMidX, maybeIntervalMidY } from \"../transforms/interval.js\";\nconst defaults = {\n  ariaLabel: \"dot\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5\n};\nexport function withDefaultSort(options) {\n  return options.sort === undefined && options.reverse === undefined ? sort({\n    channel: \"-r\"\n  }, options) : options;\n}\nexport class Dot extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x,\n      y,\n      r,\n      rotate,\n      symbol = symbolCircle,\n      frameAnchor\n    } = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vsymbol, csymbol] = maybeSymbolChannel(symbol);\n    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: y,\n        scale: \"y\",\n        optional: true\n      },\n      r: {\n        value: vr,\n        scale: \"r\",\n        filter: positive,\n        optional: true\n      },\n      rotate: {\n        value: vrotate,\n        optional: true\n      },\n      symbol: {\n        value: vsymbol,\n        scale: \"auto\",\n        optional: true\n      }\n    }, withDefaultSort(options), defaults);\n    this.r = cr;\n    this.rotate = crotate;\n    this.symbol = csymbol;\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n\n    // Give a hint to the symbol scale; this allows the symbol scale to choose\n    // appropriate default symbols based on whether the dots are filled or\n    // stroked, and for the symbol legend to match the appearance of the dots.\n    const {\n      channels\n    } = this;\n    const {\n      symbol: symbolChannel\n    } = channels;\n    if (symbolChannel) {\n      const {\n        fill: fillChannel,\n        stroke: strokeChannel\n      } = channels;\n      symbolChannel.hint = {\n        fill: fillChannel ? fillChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.fill ?? \"currentColor\",\n        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? \"color\" : \"currentColor\" : this.stroke ?? \"none\"\n      };\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x,\n      y\n    } = scales;\n    const {\n      x: X,\n      y: Y,\n      r: R,\n      rotate: A,\n      symbol: S\n    } = channels;\n    const {\n      r,\n      rotate,\n      symbol\n    } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const circle = symbol === symbolCircle;\n    const size = R ? undefined : r * r * Math.PI;\n    if (negative(r)) index = [];\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {\n      x: X && x,\n      y: Y && y\n    }).call(g => g.selectAll().data(index).enter().append(circle ? \"circle\" : \"path\").call(applyDirectStyles, this).call(circle ? selection => {\n      selection.attr(\"cx\", X ? i => X[i] : cx).attr(\"cy\", Y ? i => Y[i] : cy).attr(\"r\", R ? i => R[i] : r);\n    } : selection => {\n      selection.attr(\"transform\", template`translate(${X ? i => X[i] : cx},${Y ? i => Y[i] : cy})${A ? i => ` rotate(${A[i]})` : rotate ? ` rotate(${rotate})` : ``}`).attr(\"d\", R && S ? i => {\n        const p = path();\n        S[i].draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : R ? i => {\n        const p = path();\n        symbol.draw(p, R[i] * R[i] * Math.PI);\n        return p;\n      } : S ? i => {\n        const p = path();\n        S[i].draw(p, size);\n        return p;\n      } : (() => {\n        const p = path();\n        symbol.draw(p, size);\n        return p;\n      })());\n    }).call(applyChannelStyles, this, channels)).node();\n  }\n}\nexport function dot(data, {\n  x,\n  y,\n  ...options\n} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = maybeTuple(x, y);\n  return new Dot(data, {\n    ...options,\n    x,\n    y\n  });\n}\nexport function dotX(data, {\n  x = identity,\n  ...options\n} = {}) {\n  return new Dot(data, maybeIntervalMidY({\n    ...options,\n    x\n  }));\n}\nexport function dotY(data, {\n  y = identity,\n  ...options\n} = {}) {\n  return new Dot(data, maybeIntervalMidX({\n    ...options,\n    y\n  }));\n}\nexport function circle(data, options) {\n  return dot(data, {\n    ...options,\n    symbol: \"circle\"\n  });\n}\nexport function hexagon(data, options) {\n  return dot(data, {\n    ...options,\n    symbol: \"hexagon\"\n  });\n}","map":{"version":3,"names":["pathRound","path","symbolCircle","create","negative","positive","Mark","identity","maybeFrameAnchor","maybeNumberChannel","maybeTuple","applyChannelStyles","applyDirectStyles","applyFrameAnchor","applyIndirectStyles","applyTransform","maybeSymbolChannel","template","sort","maybeIntervalMidX","maybeIntervalMidY","defaults","ariaLabel","fill","stroke","strokeWidth","withDefaultSort","options","undefined","reverse","channel","Dot","constructor","data","x","y","r","rotate","symbol","frameAnchor","vrotate","crotate","vsymbol","csymbol","vr","cr","value","scale","optional","filter","channels","symbolChannel","fillChannel","strokeChannel","hint","render","index","scales","dimensions","context","X","Y","R","A","S","cx","cy","circle","size","Math","PI","call","g","selectAll","enter","append","selection","attr","i","p","draw","node","dot","dotX","dotY","hexagon"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/dot.js"],"sourcesContent":["import {pathRound as path, symbolCircle} from \"d3\";\nimport {create} from \"../context.js\";\nimport {negative, positive} from \"../defined.js\";\nimport {Mark} from \"../mark.js\";\nimport {identity, maybeFrameAnchor, maybeNumberChannel, maybeTuple} from \"../options.js\";\nimport {\n  applyChannelStyles,\n  applyDirectStyles,\n  applyFrameAnchor,\n  applyIndirectStyles,\n  applyTransform\n} from \"../style.js\";\nimport {maybeSymbolChannel} from \"../symbol.js\";\nimport {template} from \"../template.js\";\nimport {sort} from \"../transforms/basic.js\";\nimport {maybeIntervalMidX, maybeIntervalMidY} from \"../transforms/interval.js\";\n\nconst defaults = {\n  ariaLabel: \"dot\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5\n};\n\nexport function withDefaultSort(options) {\n  return options.sort === undefined && options.reverse === undefined ? sort({channel: \"-r\"}, options) : options;\n}\n\nexport class Dot extends Mark {\n  constructor(data, options = {}) {\n    const {x, y, r, rotate, symbol = symbolCircle, frameAnchor} = options;\n    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);\n    const [vsymbol, csymbol] = maybeSymbolChannel(symbol);\n    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        r: {value: vr, scale: \"r\", filter: positive, optional: true},\n        rotate: {value: vrotate, optional: true},\n        symbol: {value: vsymbol, scale: \"auto\", optional: true}\n      },\n      withDefaultSort(options),\n      defaults\n    );\n    this.r = cr;\n    this.rotate = crotate;\n    this.symbol = csymbol;\n    this.frameAnchor = maybeFrameAnchor(frameAnchor);\n\n    // Give a hint to the symbol scale; this allows the symbol scale to choose\n    // appropriate default symbols based on whether the dots are filled or\n    // stroked, and for the symbol legend to match the appearance of the dots.\n    const {channels} = this;\n    const {symbol: symbolChannel} = channels;\n    if (symbolChannel) {\n      const {fill: fillChannel, stroke: strokeChannel} = channels;\n      symbolChannel.hint = {\n        fill: fillChannel\n          ? fillChannel.value === symbolChannel.value\n            ? \"color\"\n            : \"currentColor\"\n          : this.fill ?? \"currentColor\",\n        stroke: strokeChannel\n          ? strokeChannel.value === symbolChannel.value\n            ? \"color\"\n            : \"currentColor\"\n          : this.stroke ?? \"none\"\n      };\n    }\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, r: R, rotate: A, symbol: S} = channels;\n    const {r, rotate, symbol} = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const circle = symbol === symbolCircle;\n    const size = R ? undefined : r * r * Math.PI;\n    if (negative(r)) index = [];\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(circle ? \"circle\" : \"path\")\n          .call(applyDirectStyles, this)\n          .call(\n            circle\n              ? (selection) => {\n                  selection\n                    .attr(\"cx\", X ? (i) => X[i] : cx)\n                    .attr(\"cy\", Y ? (i) => Y[i] : cy)\n                    .attr(\"r\", R ? (i) => R[i] : r);\n                }\n              : (selection) => {\n                  selection\n                    .attr(\n                      \"transform\",\n                      template`translate(${X ? (i) => X[i] : cx},${Y ? (i) => Y[i] : cy})${\n                        A ? (i) => ` rotate(${A[i]})` : rotate ? ` rotate(${rotate})` : ``\n                      }`\n                    )\n                    .attr(\n                      \"d\",\n                      R && S\n                        ? (i) => {\n                            const p = path();\n                            S[i].draw(p, R[i] * R[i] * Math.PI);\n                            return p;\n                          }\n                        : R\n                        ? (i) => {\n                            const p = path();\n                            symbol.draw(p, R[i] * R[i] * Math.PI);\n                            return p;\n                          }\n                        : S\n                        ? (i) => {\n                            const p = path();\n                            S[i].draw(p, size);\n                            return p;\n                          }\n                        : (() => {\n                            const p = path();\n                            symbol.draw(p, size);\n                            return p;\n                          })()\n                    );\n                }\n          )\n          .call(applyChannelStyles, this, channels)\n      )\n      .node();\n  }\n}\n\nexport function dot(data, {x, y, ...options} = {}) {\n  if (options.frameAnchor === undefined) [x, y] = maybeTuple(x, y);\n  return new Dot(data, {...options, x, y});\n}\n\nexport function dotX(data, {x = identity, ...options} = {}) {\n  return new Dot(data, maybeIntervalMidY({...options, x}));\n}\n\nexport function dotY(data, {y = identity, ...options} = {}) {\n  return new Dot(data, maybeIntervalMidX({...options, y}));\n}\n\nexport function circle(data, options) {\n  return dot(data, {...options, symbol: \"circle\"});\n}\n\nexport function hexagon(data, options) {\n  return dot(data, {...options, symbol: \"hexagon\"});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}