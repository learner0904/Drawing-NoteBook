{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { group, pathRound as path, select, Delaunay } from \"d3\";\nimport { create } from \"../context.js\";\nimport { maybeCurve } from \"../curve.js\";\nimport { defined } from \"../defined.js\";\nimport { Mark } from \"../mark.js\";\nimport { markers, applyMarkers } from \"../marker.js\";\nimport { constant, maybeTuple, maybeZ } from \"../options.js\";\nimport { applyPosition } from \"../projection.js\";\nimport { applyFrameAnchor, applyTransform } from \"../style.js\";\nimport { applyChannelStyles, applyDirectStyles, applyIndirectStyles } from \"../style.js\";\nimport { basic, initializer } from \"../transforms/basic.js\";\nimport { exclusiveFacets } from \"../transforms/exclusiveFacets.js\";\nimport { maybeGroup } from \"../transforms/group.js\";\nconst delaunayLinkDefaults = {\n  ariaLabel: \"delaunay link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nconst delaunayMeshDefaults = {\n  ariaLabel: \"delaunay mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nconst hullDefaults = {\n  ariaLabel: \"hull\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeMiterlimit: 1\n};\nconst voronoiDefaults = {\n  ariaLabel: \"voronoi\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\nconst voronoiMeshDefaults = {\n  ariaLabel: \"voronoi mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\nclass DelaunayLink extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x,\n      y,\n      z,\n      curve,\n      tension\n    } = options;\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: y,\n        scale: \"y\",\n        optional: true\n      },\n      z: {\n        value: z,\n        optional: true\n      }\n    }, options, delaunayLinkDefaults);\n    this.curve = maybeCurve(curve, tension);\n    markers(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x,\n      y\n    } = scales;\n    const {\n      x: X,\n      y: Y,\n      z: Z\n    } = channels;\n    const {\n      curve\n    } = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X ? i => X[i] : constant(cx);\n    const yi = Y ? i => Y[i] : constant(cy);\n    const mark = this;\n    function links(index) {\n      let i = -1;\n      const newIndex = [];\n      const newChannels = {};\n      for (const k in channels) newChannels[k] = [];\n      const X1 = [];\n      const X2 = [];\n      const Y1 = [];\n      const Y2 = [];\n      function link(ti, tj) {\n        ti = index[ti];\n        tj = index[tj];\n        newIndex.push(++i);\n        X1[i] = xi(ti);\n        Y1[i] = yi(ti);\n        X2[i] = xi(tj);\n        Y2[i] = yi(tj);\n        for (const k in channels) newChannels[k].push(channels[k][tj]);\n      }\n      const {\n        halfedges,\n        hull,\n        triangles\n      } = Delaunay.from(index, xi, yi);\n      for (let i = 0; i < halfedges.length; ++i) {\n        // inner edges\n        const j = halfedges[i];\n        if (j > i) link(triangles[i], triangles[j]);\n      }\n      for (let i = 0; i < hull.length; ++i) {\n        // convex hull\n        link(hull[i], hull[(i + 1) % hull.length]);\n      }\n      select(this).selectAll().data(newIndex).enter().append(\"path\").call(applyDirectStyles, mark).attr(\"d\", i => {\n        const p = path();\n        const c = curve(p);\n        c.lineStart();\n        c.point(X1[i], Y1[i]);\n        c.point(X2[i], Y2[i]);\n        c.lineEnd();\n        return p;\n      }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels, context);\n    }\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {\n      x: X && x,\n      y: Y && y\n    }).call(Z ? g => g.selectAll().data(group(index, i => Z[i]).values()).enter().append(\"g\").each(links) : g => g.datum(index).each(links)).node();\n  }\n}\nclass AbstractDelaunayMark extends Mark {\n  constructor(data, options = {}, defaults, zof = ({\n    z\n  }) => z) {\n    const {\n      x,\n      y\n    } = options;\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: y,\n        scale: \"y\",\n        optional: true\n      },\n      z: {\n        value: zof(options),\n        optional: true\n      }\n    }, options, defaults);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x,\n      y\n    } = scales;\n    const {\n      x: X,\n      y: Y,\n      z: Z\n    } = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X ? i => X[i] : constant(cx);\n    const yi = Y ? i => Y[i] : constant(cy);\n    const mark = this;\n    function mesh(index) {\n      const delaunay = Delaunay.from(index, xi, yi);\n      select(this).append(\"path\").datum(index[0]).call(applyDirectStyles, mark).attr(\"d\", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);\n    }\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {\n      x: X && x,\n      y: Y && y\n    }).call(Z ? g => g.selectAll().data(group(index, i => Z[i]).values()).enter().append(\"g\").each(mesh) : g => g.datum(index).each(mesh)).node();\n  }\n}\nclass DelaunayMesh extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, delaunayMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay) {\n    return delaunay.render();\n  }\n}\nclass Hull extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, hullDefaults, maybeZ);\n  }\n  _render(delaunay) {\n    return delaunay.renderHull();\n  }\n}\nclass Voronoi extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x,\n      y,\n      z\n    } = options;\n    super(data, {\n      x: {\n        value: x,\n        scale: \"x\",\n        optional: true\n      },\n      y: {\n        value: y,\n        scale: \"y\",\n        optional: true\n      },\n      z: {\n        value: z,\n        optional: true\n      }\n    }, initializer(options, function (data, facets, channels, scales, dimensions, context) {\n      let {\n        x: X,\n        y: Y,\n        z: Z\n      } = channels;\n      ({\n        x: X,\n        y: Y\n      } = applyPosition(channels, scales, context));\n      Z = Z?.value;\n      const C = new Array((X ?? Y).length).fill(null);\n      const [cx, cy] = applyFrameAnchor(this, dimensions);\n      const xi = X ? i => X[i] : constant(cx);\n      const yi = Y ? i => Y[i] : constant(cy);\n      for (let I of facets) {\n        if (X) I = I.filter(i => defined(xi(i)));\n        if (Y) I = I.filter(i => defined(yi(i)));\n        for (const [, J] of maybeGroup(I, Z)) {\n          const delaunay = Delaunay.from(J, xi, yi);\n          const voronoi = voronoiof(delaunay, dimensions);\n          for (let i = 0, n = J.length; i < n; ++i) {\n            C[J[i]] = voronoi.renderCell(i);\n          }\n        }\n      }\n      return {\n        data,\n        facets,\n        channels: {\n          cells: {\n            value: C\n          }\n        }\n      };\n    }), voronoiDefaults);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x,\n      y\n    } = scales;\n    const {\n      x: X,\n      y: Y,\n      cells: C\n    } = channels;\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {\n      x: X && x,\n      y: Y && y\n    }).call(g => {\n      g.selectAll().data(index).enter().append(\"path\").call(applyDirectStyles, this).attr(\"d\", i => C[i]).call(applyChannelStyles, this, channels);\n    }).node();\n  }\n}\nclass VoronoiMesh extends AbstractDelaunayMark {\n  constructor(data, options) {\n    super(data, options, voronoiMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay, dimensions) {\n    return voronoiof(delaunay, dimensions).render();\n  }\n}\nfunction voronoiof(delaunay, dimensions) {\n  const {\n    width,\n    height,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft\n  } = dimensions;\n  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);\n}\nfunction delaunayMark(DelaunayMark, data, {\n  x,\n  y,\n  ...options\n} = {}) {\n  [x, y] = maybeTuple(x, y);\n  return new DelaunayMark(data, {\n    ...options,\n    x,\n    y\n  });\n}\nexport function delaunayLink(data, options) {\n  return delaunayMark(DelaunayLink, data, options);\n}\nexport function delaunayMesh(data, options) {\n  return delaunayMark(DelaunayMesh, data, options);\n}\nexport function hull(data, options) {\n  return delaunayMark(Hull, data, options);\n}\nexport function voronoi(data, {\n  x,\n  y,\n  initializer,\n  ...options\n} = {}) {\n  return delaunayMark(Voronoi, data, {\n    ...basic({\n      ...options,\n      x,\n      y\n    }, exclusiveFacets),\n    initializer\n  });\n}\nexport function voronoiMesh(data, options) {\n  return delaunayMark(VoronoiMesh, data, options);\n}","map":{"version":3,"names":["group","pathRound","path","select","Delaunay","create","maybeCurve","defined","Mark","markers","applyMarkers","constant","maybeTuple","maybeZ","applyPosition","applyFrameAnchor","applyTransform","applyChannelStyles","applyDirectStyles","applyIndirectStyles","basic","initializer","exclusiveFacets","maybeGroup","delaunayLinkDefaults","ariaLabel","fill","stroke","strokeMiterlimit","delaunayMeshDefaults","strokeOpacity","hullDefaults","strokeWidth","voronoiDefaults","voronoiMeshDefaults","DelaunayLink","constructor","data","options","x","y","z","curve","tension","value","scale","optional","render","index","scales","channels","dimensions","context","X","Y","Z","cx","cy","xi","i","yi","mark","links","newIndex","newChannels","k","X1","X2","Y1","Y2","link","ti","tj","push","halfedges","hull","triangles","from","length","j","selectAll","enter","append","call","attr","p","c","lineStart","point","lineEnd","g","values","each","datum","node","AbstractDelaunayMark","defaults","zof","mesh","delaunay","_render","DelaunayMesh","Hull","renderHull","Voronoi","facets","C","Array","I","filter","J","voronoi","voronoiof","n","renderCell","cells","VoronoiMesh","width","height","marginTop","marginRight","marginBottom","marginLeft","delaunayMark","DelaunayMark","delaunayLink","delaunayMesh","voronoiMesh"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/delaunay.js"],"sourcesContent":["import {group, pathRound as path, select, Delaunay} from \"d3\";\nimport {create} from \"../context.js\";\nimport {maybeCurve} from \"../curve.js\";\nimport {defined} from \"../defined.js\";\nimport {Mark} from \"../mark.js\";\nimport {markers, applyMarkers} from \"../marker.js\";\nimport {constant, maybeTuple, maybeZ} from \"../options.js\";\nimport {applyPosition} from \"../projection.js\";\nimport {applyFrameAnchor, applyTransform} from \"../style.js\";\nimport {applyChannelStyles, applyDirectStyles, applyIndirectStyles} from \"../style.js\";\nimport {basic, initializer} from \"../transforms/basic.js\";\nimport {exclusiveFacets} from \"../transforms/exclusiveFacets.js\";\nimport {maybeGroup} from \"../transforms/group.js\";\n\nconst delaunayLinkDefaults = {\n  ariaLabel: \"delaunay link\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nconst delaunayMeshDefaults = {\n  ariaLabel: \"delaunay mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\n\nconst hullDefaults = {\n  ariaLabel: \"hull\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 1.5,\n  strokeMiterlimit: 1\n};\n\nconst voronoiDefaults = {\n  ariaLabel: \"voronoi\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nconst voronoiMeshDefaults = {\n  ariaLabel: \"voronoi mesh\",\n  fill: null,\n  stroke: \"currentColor\",\n  strokeOpacity: 0.2\n};\n\nclass DelaunayLink extends Mark {\n  constructor(data, options = {}) {\n    const {x, y, z, curve, tension} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: z, optional: true}\n      },\n      options,\n      delaunayLinkDefaults\n    );\n    this.curve = maybeCurve(curve, tension);\n    markers(this, options);\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, z: Z} = channels;\n    const {curve} = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X ? (i) => X[i] : constant(cx);\n    const yi = Y ? (i) => Y[i] : constant(cy);\n    const mark = this;\n\n    function links(index) {\n      let i = -1;\n      const newIndex = [];\n      const newChannels = {};\n      for (const k in channels) newChannels[k] = [];\n      const X1 = [];\n      const X2 = [];\n      const Y1 = [];\n      const Y2 = [];\n\n      function link(ti, tj) {\n        ti = index[ti];\n        tj = index[tj];\n        newIndex.push(++i);\n        X1[i] = xi(ti);\n        Y1[i] = yi(ti);\n        X2[i] = xi(tj);\n        Y2[i] = yi(tj);\n        for (const k in channels) newChannels[k].push(channels[k][tj]);\n      }\n\n      const {halfedges, hull, triangles} = Delaunay.from(index, xi, yi);\n      for (let i = 0; i < halfedges.length; ++i) {\n        // inner edges\n        const j = halfedges[i];\n        if (j > i) link(triangles[i], triangles[j]);\n      }\n      for (let i = 0; i < hull.length; ++i) {\n        // convex hull\n        link(hull[i], hull[(i + 1) % hull.length]);\n      }\n\n      select(this)\n        .selectAll()\n        .data(newIndex)\n        .enter()\n        .append(\"path\")\n        .call(applyDirectStyles, mark)\n        .attr(\"d\", (i) => {\n          const p = path();\n          const c = curve(p);\n          c.lineStart();\n          c.point(X1[i], Y1[i]);\n          c.point(X2[i], Y2[i]);\n          c.lineEnd();\n          return p;\n        })\n        .call(applyChannelStyles, mark, newChannels)\n        .call(applyMarkers, mark, newChannels, context);\n    }\n\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {x: X && x, y: Y && y})\n      .call(\n        Z\n          ? (g) =>\n              g\n                .selectAll()\n                .data(group(index, (i) => Z[i]).values())\n                .enter()\n                .append(\"g\")\n                .each(links)\n          : (g) => g.datum(index).each(links)\n      )\n      .node();\n  }\n}\n\nclass AbstractDelaunayMark extends Mark {\n  constructor(data, options = {}, defaults, zof = ({z}) => z) {\n    const {x, y} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: zof(options), optional: true}\n      },\n      options,\n      defaults\n    );\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, z: Z} = channels;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const xi = X ? (i) => X[i] : constant(cx);\n    const yi = Y ? (i) => Y[i] : constant(cy);\n    const mark = this;\n\n    function mesh(index) {\n      const delaunay = Delaunay.from(index, xi, yi);\n      select(this)\n        .append(\"path\")\n        .datum(index[0])\n        .call(applyDirectStyles, mark)\n        .attr(\"d\", mark._render(delaunay, dimensions))\n        .call(applyChannelStyles, mark, channels);\n    }\n\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {x: X && x, y: Y && y})\n      .call(\n        Z\n          ? (g) =>\n              g\n                .selectAll()\n                .data(group(index, (i) => Z[i]).values())\n                .enter()\n                .append(\"g\")\n                .each(mesh)\n          : (g) => g.datum(index).each(mesh)\n      )\n      .node();\n  }\n}\n\nclass DelaunayMesh extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, delaunayMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay) {\n    return delaunay.render();\n  }\n}\n\nclass Hull extends AbstractDelaunayMark {\n  constructor(data, options = {}) {\n    super(data, options, hullDefaults, maybeZ);\n  }\n  _render(delaunay) {\n    return delaunay.renderHull();\n  }\n}\n\nclass Voronoi extends Mark {\n  constructor(data, options = {}) {\n    const {x, y, z} = options;\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: z, optional: true}\n      },\n      initializer(options, function (data, facets, channels, scales, dimensions, context) {\n        let {x: X, y: Y, z: Z} = channels;\n        ({x: X, y: Y} = applyPosition(channels, scales, context));\n        Z = Z?.value;\n        const C = new Array((X ?? Y).length).fill(null);\n        const [cx, cy] = applyFrameAnchor(this, dimensions);\n        const xi = X ? (i) => X[i] : constant(cx);\n        const yi = Y ? (i) => Y[i] : constant(cy);\n        for (let I of facets) {\n          if (X) I = I.filter((i) => defined(xi(i)));\n          if (Y) I = I.filter((i) => defined(yi(i)));\n          for (const [, J] of maybeGroup(I, Z)) {\n            const delaunay = Delaunay.from(J, xi, yi);\n            const voronoi = voronoiof(delaunay, dimensions);\n            for (let i = 0, n = J.length; i < n; ++i) {\n              C[J[i]] = voronoi.renderCell(i);\n            }\n          }\n        }\n        return {data, facets, channels: {cells: {value: C}}};\n      }),\n      voronoiDefaults\n    );\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x, y} = scales;\n    const {x: X, y: Y, cells: C} = channels;\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {x: X && x, y: Y && y})\n      .call((g) => {\n        g.selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .attr(\"d\", (i) => C[i])\n          .call(applyChannelStyles, this, channels);\n      })\n      .node();\n  }\n}\n\nclass VoronoiMesh extends AbstractDelaunayMark {\n  constructor(data, options) {\n    super(data, options, voronoiMeshDefaults);\n    this.fill = \"none\";\n  }\n  _render(delaunay, dimensions) {\n    return voronoiof(delaunay, dimensions).render();\n  }\n}\n\nfunction voronoiof(delaunay, dimensions) {\n  const {width, height, marginTop, marginRight, marginBottom, marginLeft} = dimensions;\n  return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);\n}\n\nfunction delaunayMark(DelaunayMark, data, {x, y, ...options} = {}) {\n  [x, y] = maybeTuple(x, y);\n  return new DelaunayMark(data, {...options, x, y});\n}\n\nexport function delaunayLink(data, options) {\n  return delaunayMark(DelaunayLink, data, options);\n}\n\nexport function delaunayMesh(data, options) {\n  return delaunayMark(DelaunayMesh, data, options);\n}\n\nexport function hull(data, options) {\n  return delaunayMark(Hull, data, options);\n}\n\nexport function voronoi(data, {x, y, initializer, ...options} = {}) {\n  return delaunayMark(Voronoi, data, {...basic({...options, x, y}, exclusiveFacets), initializer});\n}\n\nexport function voronoiMesh(data, options) {\n  return delaunayMark(VoronoiMesh, data, options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}