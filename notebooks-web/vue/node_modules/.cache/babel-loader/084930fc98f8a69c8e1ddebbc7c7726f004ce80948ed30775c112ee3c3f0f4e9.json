{"ast":null,"code":"import { area as shapeArea } from \"d3\";\nimport { create } from \"../context.js\";\nimport { maybeCurve } from \"../curve.js\";\nimport { Mark } from \"../mark.js\";\nimport { first, indexOf, maybeZ, second } from \"../options.js\";\nimport { applyDirectStyles, applyIndirectStyles, applyTransform, applyGroupedChannelStyles, groupIndex } from \"../style.js\";\nimport { maybeDenseIntervalX, maybeDenseIntervalY } from \"../transforms/bin.js\";\nimport { maybeIdentityX, maybeIdentityY } from \"../transforms/identity.js\";\nimport { maybeStackX, maybeStackY } from \"../transforms/stack.js\";\nconst defaults = {\n  ariaLabel: \"area\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\nexport class Area extends Mark {\n  constructor(data, options = {}) {\n    const {\n      x1,\n      y1,\n      x2,\n      y2,\n      z,\n      curve,\n      tension\n    } = options;\n    super(data, {\n      x1: {\n        value: x1,\n        scale: \"x\"\n      },\n      y1: {\n        value: y1,\n        scale: \"y\"\n      },\n      x2: {\n        value: x2,\n        scale: \"x\",\n        optional: true\n      },\n      y2: {\n        value: y2,\n        scale: \"y\",\n        optional: true\n      },\n      z: {\n        value: maybeZ(options),\n        optional: true\n      }\n    }, options, defaults);\n    this.z = z;\n    this.curve = maybeCurve(curve, tension);\n  }\n  filter(index) {\n    return index;\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {\n      x1: X1,\n      y1: Y1,\n      x2: X2 = X1,\n      y2: Y2 = Y1\n    } = channels;\n    return create(\"svg:g\", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call(g => g.selectAll().data(groupIndex(index, [X1, Y1, X2, Y2], this, channels)).enter().append(\"path\").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(\"d\", shapeArea().curve(this.curve).defined(i => i >= 0).x0(i => X1[i]).y0(i => Y1[i]).x1(i => X2[i]).y1(i => Y2[i]))).node();\n  }\n}\nexport function area(data, options) {\n  if (options === undefined) return areaY(data, {\n    x: first,\n    y: second\n  });\n  return new Area(data, options);\n}\nexport function areaX(data, options) {\n  const {\n    y = indexOf,\n    ...rest\n  } = maybeDenseIntervalY(options);\n  return new Area(data, maybeStackX(maybeIdentityX({\n    ...rest,\n    y1: y,\n    y2: undefined\n  })));\n}\nexport function areaY(data, options) {\n  const {\n    x = indexOf,\n    ...rest\n  } = maybeDenseIntervalX(options);\n  return new Area(data, maybeStackY(maybeIdentityY({\n    ...rest,\n    x1: x,\n    x2: undefined\n  })));\n}","map":{"version":3,"names":["area","shapeArea","create","maybeCurve","Mark","first","indexOf","maybeZ","second","applyDirectStyles","applyIndirectStyles","applyTransform","applyGroupedChannelStyles","groupIndex","maybeDenseIntervalX","maybeDenseIntervalY","maybeIdentityX","maybeIdentityY","maybeStackX","maybeStackY","defaults","ariaLabel","strokeWidth","strokeLinecap","strokeLinejoin","strokeMiterlimit","Area","constructor","data","options","x1","y1","x2","y2","z","curve","tension","value","scale","optional","filter","index","render","scales","channels","dimensions","context","X1","Y1","X2","Y2","call","g","selectAll","enter","append","attr","defined","i","x0","y0","node","undefined","areaY","x","y","areaX","rest"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/area.js"],"sourcesContent":["import {area as shapeArea} from \"d3\";\nimport {create} from \"../context.js\";\nimport {maybeCurve} from \"../curve.js\";\nimport {Mark} from \"../mark.js\";\nimport {first, indexOf, maybeZ, second} from \"../options.js\";\nimport {\n  applyDirectStyles,\n  applyIndirectStyles,\n  applyTransform,\n  applyGroupedChannelStyles,\n  groupIndex\n} from \"../style.js\";\nimport {maybeDenseIntervalX, maybeDenseIntervalY} from \"../transforms/bin.js\";\nimport {maybeIdentityX, maybeIdentityY} from \"../transforms/identity.js\";\nimport {maybeStackX, maybeStackY} from \"../transforms/stack.js\";\n\nconst defaults = {\n  ariaLabel: \"area\",\n  strokeWidth: 1,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n  strokeMiterlimit: 1\n};\n\nexport class Area extends Mark {\n  constructor(data, options = {}) {\n    const {x1, y1, x2, y2, z, curve, tension} = options;\n    super(\n      data,\n      {\n        x1: {value: x1, scale: \"x\"},\n        y1: {value: y1, scale: \"y\"},\n        x2: {value: x2, scale: \"x\", optional: true},\n        y2: {value: y2, scale: \"y\", optional: true},\n        z: {value: maybeZ(options), optional: true}\n      },\n      options,\n      defaults\n    );\n    this.z = z;\n    this.curve = maybeCurve(curve, tension);\n  }\n  filter(index) {\n    return index;\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {x1: X1, y1: Y1, x2: X2 = X1, y2: Y2 = Y1} = channels;\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, scales, 0, 0)\n      .call((g) =>\n        g\n          .selectAll()\n          .data(groupIndex(index, [X1, Y1, X2, Y2], this, channels))\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .call(applyGroupedChannelStyles, this, channels)\n          .attr(\n            \"d\",\n            shapeArea()\n              .curve(this.curve)\n              .defined((i) => i >= 0)\n              .x0((i) => X1[i])\n              .y0((i) => Y1[i])\n              .x1((i) => X2[i])\n              .y1((i) => Y2[i])\n          )\n      )\n      .node();\n  }\n}\n\nexport function area(data, options) {\n  if (options === undefined) return areaY(data, {x: first, y: second});\n  return new Area(data, options);\n}\n\nexport function areaX(data, options) {\n  const {y = indexOf, ...rest} = maybeDenseIntervalY(options);\n  return new Area(data, maybeStackX(maybeIdentityX({...rest, y1: y, y2: undefined})));\n}\n\nexport function areaY(data, options) {\n  const {x = indexOf, ...rest} = maybeDenseIntervalX(options);\n  return new Area(data, maybeStackY(maybeIdentityY({...rest, x1: x, x2: undefined})));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}