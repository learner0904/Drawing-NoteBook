{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { rgb } from \"d3\";\nimport { createContext } from \"./context.js\";\nimport { legendRamp } from \"./legends/ramp.js\";\nimport { legendSwatches, legendSymbols } from \"./legends/swatches.js\";\nimport { inherit, isScaleOptions } from \"./options.js\";\nimport { normalizeScale } from \"./scales.js\";\nconst legendRegistry = new Map([[\"symbol\", legendSymbols], [\"color\", legendColor], [\"opacity\", legendOpacity]]);\nexport function legend(options = {}) {\n  for (const [key, value] of legendRegistry) {\n    const scale = options[key];\n    if (isScaleOptions(scale)) {\n      // e.g., ignore {color: \"red\"}\n      const context = createContext(options);\n      let hint;\n      // For symbol legends, pass a hint to the symbol scale.\n      if (key === \"symbol\") {\n        const {\n          fill,\n          stroke = fill === undefined && isScaleOptions(options.color) ? \"color\" : undefined\n        } = options;\n        hint = {\n          fill,\n          stroke\n        };\n      }\n      return value(normalizeScale(key, scale, hint), legendOptions(context, scale, options), key => isScaleOptions(options[key]) ? normalizeScale(key, options[key]) : null);\n    }\n  }\n  throw new Error(\"unknown legend type; no scale found\");\n}\nexport function exposeLegends(scales, context, defaults = {}) {\n  return (key, options) => {\n    if (!legendRegistry.has(key)) throw new Error(`unknown legend type: ${key}`);\n    if (!(key in scales)) return;\n    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults[key], options), key => scales[key]);\n  };\n}\nfunction legendOptions({\n  className,\n  ...context\n}, {\n  label,\n  ticks,\n  tickFormat\n} = {}, options) {\n  return inherit(options, {\n    className,\n    ...context\n  }, {\n    label,\n    ticks,\n    tickFormat\n  });\n}\nfunction legendColor(color, {\n  legend = true,\n  ...options\n}) {\n  if (legend === true) legend = color.type === \"ordinal\" ? \"swatches\" : \"ramp\";\n  if (color.domain === undefined) return; // no identity legend\n  switch (`${legend}`.toLowerCase()) {\n    case \"swatches\":\n      return legendSwatches(color, options);\n    case \"ramp\":\n      return legendRamp(color, options);\n    default:\n      throw new Error(`unknown legend type: ${legend}`);\n  }\n}\nfunction legendOpacity({\n  type,\n  interpolate,\n  ...scale\n}, {\n  legend = true,\n  color = rgb(0, 0, 0),\n  ...options\n}) {\n  if (!interpolate) throw new Error(`${type} opacity scales are not supported`);\n  if (legend === true) legend = \"ramp\";\n  if (`${legend}`.toLowerCase() !== \"ramp\") throw new Error(`${legend} opacity legends are not supported`);\n  return legendColor({\n    type,\n    ...scale,\n    interpolate: interpolateOpacity(color)\n  }, {\n    legend,\n    ...options\n  });\n}\nfunction interpolateOpacity(color) {\n  const {\n    r,\n    g,\n    b\n  } = rgb(color) || rgb(0, 0, 0); // treat invalid color as black\n  return t => `rgba(${r},${g},${b},${t})`;\n}\nexport function createLegends(scales, context, options) {\n  const legends = [];\n  for (const [key, value] of legendRegistry) {\n    const o = options[key];\n    if (o?.legend && key in scales) {\n      const legend = value(scales[key], legendOptions(context, scales[key], o), key => scales[key]);\n      if (legend != null) legends.push(legend);\n    }\n  }\n  return legends;\n}","map":{"version":3,"names":["rgb","createContext","legendRamp","legendSwatches","legendSymbols","inherit","isScaleOptions","normalizeScale","legendRegistry","Map","legendColor","legendOpacity","legend","options","key","value","scale","context","hint","fill","stroke","undefined","color","legendOptions","Error","exposeLegends","scales","defaults","has","get","className","label","ticks","tickFormat","type","domain","toLowerCase","interpolate","interpolateOpacity","r","g","b","t","createLegends","legends","o","push"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/legends.js"],"sourcesContent":["import {rgb} from \"d3\";\nimport {createContext} from \"./context.js\";\nimport {legendRamp} from \"./legends/ramp.js\";\nimport {legendSwatches, legendSymbols} from \"./legends/swatches.js\";\nimport {inherit, isScaleOptions} from \"./options.js\";\nimport {normalizeScale} from \"./scales.js\";\n\nconst legendRegistry = new Map([\n  [\"symbol\", legendSymbols],\n  [\"color\", legendColor],\n  [\"opacity\", legendOpacity]\n]);\n\nexport function legend(options = {}) {\n  for (const [key, value] of legendRegistry) {\n    const scale = options[key];\n    if (isScaleOptions(scale)) {\n      // e.g., ignore {color: \"red\"}\n      const context = createContext(options);\n      let hint;\n      // For symbol legends, pass a hint to the symbol scale.\n      if (key === \"symbol\") {\n        const {fill, stroke = fill === undefined && isScaleOptions(options.color) ? \"color\" : undefined} = options;\n        hint = {fill, stroke};\n      }\n      return value(normalizeScale(key, scale, hint), legendOptions(context, scale, options), (key) =>\n        isScaleOptions(options[key]) ? normalizeScale(key, options[key]) : null\n      );\n    }\n  }\n  throw new Error(\"unknown legend type; no scale found\");\n}\n\nexport function exposeLegends(scales, context, defaults = {}) {\n  return (key, options) => {\n    if (!legendRegistry.has(key)) throw new Error(`unknown legend type: ${key}`);\n    if (!(key in scales)) return;\n    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults[key], options), (key) => scales[key]);\n  };\n}\n\nfunction legendOptions({className, ...context}, {label, ticks, tickFormat} = {}, options) {\n  return inherit(options, {className, ...context}, {label, ticks, tickFormat});\n}\n\nfunction legendColor(color, {legend = true, ...options}) {\n  if (legend === true) legend = color.type === \"ordinal\" ? \"swatches\" : \"ramp\";\n  if (color.domain === undefined) return; // no identity legend\n  switch (`${legend}`.toLowerCase()) {\n    case \"swatches\":\n      return legendSwatches(color, options);\n    case \"ramp\":\n      return legendRamp(color, options);\n    default:\n      throw new Error(`unknown legend type: ${legend}`);\n  }\n}\n\nfunction legendOpacity({type, interpolate, ...scale}, {legend = true, color = rgb(0, 0, 0), ...options}) {\n  if (!interpolate) throw new Error(`${type} opacity scales are not supported`);\n  if (legend === true) legend = \"ramp\";\n  if (`${legend}`.toLowerCase() !== \"ramp\") throw new Error(`${legend} opacity legends are not supported`);\n  return legendColor({type, ...scale, interpolate: interpolateOpacity(color)}, {legend, ...options});\n}\n\nfunction interpolateOpacity(color) {\n  const {r, g, b} = rgb(color) || rgb(0, 0, 0); // treat invalid color as black\n  return (t) => `rgba(${r},${g},${b},${t})`;\n}\n\nexport function createLegends(scales, context, options) {\n  const legends = [];\n  for (const [key, value] of legendRegistry) {\n    const o = options[key];\n    if (o?.legend && key in scales) {\n      const legend = value(scales[key], legendOptions(context, scales[key], o), (key) => scales[key]);\n      if (legend != null) legends.push(legend);\n    }\n  }\n  return legends;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}