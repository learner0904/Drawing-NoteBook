{"ast":null,"code":"import { max, min, quantile } from \"d3\";\nimport { marks } from \"../mark.js\";\nimport { identity } from \"../options.js\";\nimport { groupX, groupY, groupZ } from \"../transforms/group.js\";\nimport { map } from \"../transforms/map.js\";\nimport { barX, barY } from \"./bar.js\";\nimport { dot } from \"./dot.js\";\nimport { ruleX, ruleY } from \"./rule.js\";\nimport { tickX, tickY } from \"./tick.js\";\n\n// Returns a composite mark for producing a horizontal box plot, applying the\n// necessary statistical transforms. The boxes are grouped by y, if present.\nexport function boxX(data, {\n  x = identity,\n  y = null,\n  r,\n  fill = \"#ccc\",\n  fillOpacity,\n  stroke = \"currentColor\",\n  strokeOpacity,\n  strokeWidth = 2,\n  sort,\n  ...options\n} = {}) {\n  const group = y != null ? groupY : groupZ;\n  return marks(ruleY(data, group({\n    x1: loqr1,\n    x2: hiqr2\n  }, {\n    x,\n    y,\n    stroke,\n    strokeOpacity,\n    ...options\n  })), barX(data, group({\n    x1: \"p25\",\n    x2: \"p75\"\n  }, {\n    x,\n    y,\n    fill,\n    fillOpacity,\n    ...options\n  })), tickX(data, group({\n    x: \"p50\"\n  }, {\n    x,\n    y,\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    sort,\n    ...options\n  })), dot(data, map({\n    x: oqr\n  }, {\n    x,\n    y,\n    z: y,\n    r,\n    stroke,\n    strokeOpacity,\n    ...options\n  })));\n}\n\n// Returns a composite mark for producing a vertical box plot, applying the\n// necessary statistical transforms. The boxes are grouped by x, if present.\nexport function boxY(data, {\n  y = identity,\n  x = null,\n  r,\n  fill = \"#ccc\",\n  fillOpacity,\n  stroke = \"currentColor\",\n  strokeOpacity,\n  strokeWidth = 2,\n  sort,\n  ...options\n} = {}) {\n  const group = x != null ? groupX : groupZ;\n  return marks(ruleX(data, group({\n    y1: loqr1,\n    y2: hiqr2\n  }, {\n    x,\n    y,\n    stroke,\n    strokeOpacity,\n    ...options\n  })), barY(data, group({\n    y1: \"p25\",\n    y2: \"p75\"\n  }, {\n    x,\n    y,\n    fill,\n    fillOpacity,\n    ...options\n  })), tickY(data, group({\n    y: \"p50\"\n  }, {\n    x,\n    y,\n    stroke,\n    strokeOpacity,\n    strokeWidth,\n    sort,\n    ...options\n  })), dot(data, map({\n    y: oqr\n  }, {\n    x,\n    y,\n    z: x,\n    r,\n    stroke,\n    strokeOpacity,\n    ...options\n  })));\n}\n\n// A map function that returns only outliers, returning NaN for non-outliers\nfunction oqr(values) {\n  const r1 = loqr1(values);\n  const r2 = hiqr2(values);\n  return values.map(v => v < r1 || v > r2 ? v : NaN);\n}\nfunction loqr1(values) {\n  const lo = quartile1(values) * 2.5 - quartile3(values) * 1.5;\n  return min(values, d => d >= lo ? d : NaN);\n}\nfunction hiqr2(values) {\n  const hi = quartile3(values) * 2.5 - quartile1(values) * 1.5;\n  return max(values, d => d <= hi ? d : NaN);\n}\nfunction quartile1(values) {\n  return quantile(values, 0.25);\n}\nfunction quartile3(values) {\n  return quantile(values, 0.75);\n}","map":{"version":3,"names":["max","min","quantile","marks","identity","groupX","groupY","groupZ","map","barX","barY","dot","ruleX","ruleY","tickX","tickY","boxX","data","x","y","r","fill","fillOpacity","stroke","strokeOpacity","strokeWidth","sort","options","group","x1","loqr1","x2","hiqr2","oqr","z","boxY","y1","y2","values","r1","r2","v","NaN","lo","quartile1","quartile3","d","hi"],"sources":["D:/Notebooks/notebooks-web/vue/node_modules/@observablehq/plot/src/marks/box.js"],"sourcesContent":["import {max, min, quantile} from \"d3\";\nimport {marks} from \"../mark.js\";\nimport {identity} from \"../options.js\";\nimport {groupX, groupY, groupZ} from \"../transforms/group.js\";\nimport {map} from \"../transforms/map.js\";\nimport {barX, barY} from \"./bar.js\";\nimport {dot} from \"./dot.js\";\nimport {ruleX, ruleY} from \"./rule.js\";\nimport {tickX, tickY} from \"./tick.js\";\n\n// Returns a composite mark for producing a horizontal box plot, applying the\n// necessary statistical transforms. The boxes are grouped by y, if present.\nexport function boxX(\n  data,\n  {\n    x = identity,\n    y = null,\n    r,\n    fill = \"#ccc\",\n    fillOpacity,\n    stroke = \"currentColor\",\n    strokeOpacity,\n    strokeWidth = 2,\n    sort,\n    ...options\n  } = {}\n) {\n  const group = y != null ? groupY : groupZ;\n  return marks(\n    ruleY(data, group({x1: loqr1, x2: hiqr2}, {x, y, stroke, strokeOpacity, ...options})),\n    barX(data, group({x1: \"p25\", x2: \"p75\"}, {x, y, fill, fillOpacity, ...options})),\n    tickX(data, group({x: \"p50\"}, {x, y, stroke, strokeOpacity, strokeWidth, sort, ...options})),\n    dot(data, map({x: oqr}, {x, y, z: y, r, stroke, strokeOpacity, ...options}))\n  );\n}\n\n// Returns a composite mark for producing a vertical box plot, applying the\n// necessary statistical transforms. The boxes are grouped by x, if present.\nexport function boxY(\n  data,\n  {\n    y = identity,\n    x = null,\n    r,\n    fill = \"#ccc\",\n    fillOpacity,\n    stroke = \"currentColor\",\n    strokeOpacity,\n    strokeWidth = 2,\n    sort,\n    ...options\n  } = {}\n) {\n  const group = x != null ? groupX : groupZ;\n  return marks(\n    ruleX(data, group({y1: loqr1, y2: hiqr2}, {x, y, stroke, strokeOpacity, ...options})),\n    barY(data, group({y1: \"p25\", y2: \"p75\"}, {x, y, fill, fillOpacity, ...options})),\n    tickY(data, group({y: \"p50\"}, {x, y, stroke, strokeOpacity, strokeWidth, sort, ...options})),\n    dot(data, map({y: oqr}, {x, y, z: x, r, stroke, strokeOpacity, ...options}))\n  );\n}\n\n// A map function that returns only outliers, returning NaN for non-outliers\nfunction oqr(values) {\n  const r1 = loqr1(values);\n  const r2 = hiqr2(values);\n  return values.map((v) => (v < r1 || v > r2 ? v : NaN));\n}\n\nfunction loqr1(values) {\n  const lo = quartile1(values) * 2.5 - quartile3(values) * 1.5;\n  return min(values, (d) => (d >= lo ? d : NaN));\n}\n\nfunction hiqr2(values) {\n  const hi = quartile3(values) * 2.5 - quartile1(values) * 1.5;\n  return max(values, (d) => (d <= hi ? d : NaN));\n}\n\nfunction quartile1(values) {\n  return quantile(values, 0.25);\n}\n\nfunction quartile3(values) {\n  return quantile(values, 0.75);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}